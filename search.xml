<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>simple_test_time_scaling</title>
      <link href="/post/1451647021.html"/>
      <url>/post/1451647021.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>目标检测论文阅读笔记（1）</title>
      <link href="/post/654684277.html"/>
      <url>/post/654684277.html</url>
      
        <content type="html"><![CDATA[<h1 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h1><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1kC4y1N7Nt/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">【入门级目标检测发展概述及概念简介】</a></p></blockquote><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测论文阅读笔记（1）/image-20250427221219580.png" alt="image-20250427221219580"></p><p>视觉定位+深度学习的经典论文。做法也是经典的2-Stage方法，<strong>先生成一系列的候选框，然后将候选框进行裁剪。之后将每个裁剪后图片通过CNN去预测类别，从而得到不同类别的检测框</strong>。</p><p>但主要问题是：</p><ol><li>直接裁剪图像，再送到CNN开销比较大。论文中2k张图片，假设裁剪后的图片是1KB，那2k张都是将近2MB了。<code>batch size</code>更大的时候这样裁剪更低效。所以之后的Fast R-CNN等优化方法都在特征上进行裁剪。在图片上裁剪的少之又少了。</li><li>RP总会有重叠的，之后难以避免要用到NMS（非极大值抑制）来去掉冗余框，<strong>也就避免不了NMS的缺点：耗时长和对人物重合效果不好</strong>。</li><li><strong>CNN的输出类别是固定的</strong>，所以类别是有限的，对新的类别又要重新训练。</li></ol><h1 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h1><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1kC4y1N7Nt/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">【入门级目标检测发展概述及概念简介】</a></p></blockquote><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测论文阅读笔记（1）/image-20250427223358856.png" alt="image-20250427223358856"></p><p>像论文中所说：当时在生成候选框（RP）阶段，很多2-Stage方法可以通过一些算法，迅速将候选物体位置的数量缩小到少数（例如，1-2k），过滤掉大多数背景样本。但是1-Stage方法就没法过滤，因为一阶段方法不生成RP，它必须处理更大数量的候选对象位置，这些位置通常是在图像中规则采样得到的（比如基于Anchor）。</p><p>所以文章提出了<strong>Focal Loss</strong>，目的是调整难分辨的样本的权重更高，易分辨的样本的权重变低，如果模型想要Loss低，就要在难分辨的样本上（也就是非背景样本上）做对，对模型提出了更高的要求。（就不能浑水摸鱼了）</p><p>相对于这个Loss，模型就显得没那么重要了，后面也没看有人用过。</p><h1 id="DERT"><a href="#DERT" class="headerlink" title="DERT"></a>DERT</h1><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1Pm411D7Ej/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">【一个视频看懂为什么DETR不需要NMS|目标检测相关】</a></p></blockquote><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测论文阅读笔记（1）/DETR_framework.jpg" alt="DETR 代码解读 - Shihan’s homepage"></p><p>DERT是几乎第一个端到端的，不需要任何后处理的模型。其先用CNN提取图像特征，然后将图像特征加上位置编码（transformer需要）后送入encoder，让特征中包含全局的信息。然后用可学习的Query，希望不同的Query关注不同的区域，然后每个Qurey得到的结果会经过全连接层生成类别和检测框。</p><p>在DERT之前的模型总是离不开后处理方法，也就是大部分离不开NMS。因为检测的框可能会重复。DERT用可学习的Query使得不同的Query只关注不同的部分，因此还给Query加了位置编码。而且transformer decoder在生成输出的时候，第二个Query也可以看到之前的Query，以避免生成同一个框。</p><p>encoder的作用是使图像特征中包含全局特征，自回归的decoder的作用是让Query间能相互交流，不同Query也被设计成负责不同的位置。</p><h1 id="GLIP"><a href="#GLIP" class="headerlink" title="GLIP"></a>GLIP</h1><blockquote><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/633352647">博客</a></li><li><a href="https://www.bilibili.com/video/BV1FV4y1p7Lm/?spm_id_from=333.1007.top_right_bar_window_history.content.click">视频</a></li><li><a href="https://www.bilibili.com/video/BV1SD4y157mT/?spm_id_from=333.1007.top_right_bar_window_history.content.click">视频2</a></li></ol></blockquote><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测论文阅读笔记（1）/OHBOJOQ7ACQCK.png" alt="img"></p><p>GLIP将目标检测和视觉定位的任务统一了起来。它认为目标检测就是不给出提示词的视觉定位任务。所以它将不同的类别串成一个句子，就像这里将Person，Bicycle等概念串在一起，就变成了目标检测任务。</p><p>想法比较简单，将文本通过文本编码器编码成向量，将图片也通过视觉编码器编码成向量，并在其中做了Cross Attention融合。下面的视觉编码器还负责出框。然后用RP的特征向量和文本的特征向量计算相似度。希望RP的内容和其真实的标签对应的文本特征向量尽可能相似，而和不相关的文本特征向量尽可能远。这部分是计算Alignment Loss。然后RP框还有一个Localization Loss（是IoU的Loss）。</p><h1 id="GroundingDINO"><a href="#GroundingDINO" class="headerlink" title="GroundingDINO"></a>GroundingDINO</h1><blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/627646794">十分钟解读Grounding DINO</a></p></blockquote><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测论文阅读笔记（1）/image-20250428160155776.png" alt="image-20250428160155776"></p><p>感觉基础思想和CLIP差不多，都是算文本特征和图像特征，然后两个Loss：Contrastive loss、Localization loss。区别在于特征提取的时候更复杂，做特征的增强和混合等做的更多。</p><hr><p>碎碎念：本来是在做Grounding方向的，结果读了几篇目标检测的论文，读完之后才发现有点不对劲😣</p>]]></content>
      
      
      <categories>
          
          <category> 在文献里迷路的日子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测入门</title>
      <link href="/post/1892840876.html"/>
      <url>/post/1892840876.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/image-20250426200143940.png" alt="image-20250426200143940"></p><p>检测任务一般分为两步：</p><ol><li>检测出预测框（回归）</li><li>将预测框中的物体分类（分类）</li></ol><blockquote><p>同时用到了回归和分类。比如在这张图中就需要框出人和猫两个检测框，然后再对检测框做分类</p></blockquote><p>所以标签（<code>ground_truth</code>）需要检测框坐标（<code>bbox</code>）和类别标签。类别标签有一个集合，比如有80个类别，模型就只会在图像中检测出这80个类别。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="Region-proposals-RP"><a href="#Region-proposals-RP" class="headerlink" title="Region proposals(RP)"></a>Region proposals(RP)</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/image-20250426201201376.png" alt="image-20250426201201376"></p><p>中文叫做备选框。输入一张图像，可以得到很多候选框，每一个候选框可以看成一个被检测出来的目标，之后这些候选框就被拿去分类。就可以知道这个候选框对应的类别。就完成了目标检测的任务</p><h3 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h3><p>IoU的计算公式为两个框的交集除以并集</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/sensors-22-09080-g007.png" alt="Influence of Insufficient Dataset Augmentation on IoU and Detection ..."></p><h3 id="NMS（non-maximum-suppression）"><a href="#NMS（non-maximum-suppression）" class="headerlink" title="NMS（non-maximum suppression）"></a>NMS（non-maximum suppression）</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/225e1f8b06cadb4cb441b32158768f31.png" alt="NMS技术总结（NMS原理、多类别NMS、NMS的缺陷、NMS的改进思路、各种NMS方法） - CV技术指南（公众号） - 博客园"></p><p>中文叫非极大值抑制。因为一个人可能有多个框都预测到这一个人，所以要用一种方法合并这些框，或者说叫过滤冗余框。</p><p>但NMS也有缺点，比如两个人重叠在一起了，就有可能被NMS过滤成同一个人。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="1-Stage和2-Stage"><a href="#1-Stage和2-Stage" class="headerlink" title="1-Stage和2-Stage"></a>1-Stage和2-Stage</h3><p>1-Stage的模型分为Anchor-based和Anchor-free的。Anchor-based相当于用预定义的Anchor代替了RP，之后预测Anchor的类别和预测offset。</p><p>2-Stage是先生成RP，然后再做分类。分类的时候一般还要微调（refine）检测框的大小（或称为预测offset）。</p><h3 id="Anchor-based-和-Anchor-free"><a href="#Anchor-based-和-Anchor-free" class="headerlink" title="Anchor-based 和 Anchor-free"></a>Anchor-based 和 Anchor-free</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/anchors.png" alt="5 Significant Object Detection Challenges and Solutions"></p><p>Anchor是定义出的一系列有固定长宽比、scale的框。对于每个小网格，都会画出很多Anchor框。上图中对每个小网格都画了三个Anchor框。</p><p>Anchor-based：如果有100个网格，每个网格有9个Anchor。那总共就预测900的Anchor的类别（和offset）就可以了。这样神经网络的输出维度就固定了，而且每个神经元预测的Anchor的大小也固定了，就不会出现一个神经元一会要预测大框一会要预测小框，Loss会比较稳定。经典的模型：RetinaNet。</p><p>但Anchor的长宽比、角度、scale这些都是预定义好的。有时候要识别的东西是不规则的形状的，或者长宽比时大时小，那表现就会差。而且计算量比较大。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/v2-f0871ea7277c2b6129a0c7c7142e8bec_r.jpg" alt="【Anchor Free】CenterNet的详细解析 - 知乎"></p><blockquote><p>Center net 论文配图</p></blockquote><p>Anchor-free：抛弃了Anchor。经典的模型：Center Net、FCOS。Center Net把人物当成关键点来预测，然后再预测这个关键点的长宽，就能绘制出矩形框（但太依赖一个点的预测结果，所以召回率比较低）；FCOS就用多个关键点来预测，就不依赖于一个点的预测结果了。</p><h3 id="End-to-end"><a href="#End-to-end" class="headerlink" title="End-to-end"></a>End-to-end</h3><p>有一些模型在检测出来之后还要做后处理，端到端的模型就省略了这一步。</p><h1 id="发展概述"><a href="#发展概述" class="headerlink" title="发展概述"></a>发展概述</h1><h2 id="开山之作"><a href="#开山之作" class="headerlink" title="开山之作"></a>开山之作</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/目标检测入门/image-20250426201201376.png" alt="image-20250426201201376"></p><p>最早的是RCNN，将卷积网络（深度学习）引入到目标检测任务中。之后在这篇文章上衍生出了改进版Fast RCNN和Faster RCNN。</p><p>RCNN是典型的2-Stage模型。先得到候选框RP，然后再把裁剪出的图像送卷积神经网络CNN。</p><p>Fast RCNN等后续改进，因为觉得每次把图像裁剪下来耗时太长，所以在特征上进行裁剪。</p><h2 id="one-stage的崛起"><a href="#one-stage的崛起" class="headerlink" title="one-stage的崛起"></a>one-stage的崛起</h2><p>在RetinaNet这篇文章中，提出了新的Focal Loss，使得one-stage的方法追平甚至超过了two-stage的方法。</p><p>因为原来，在RP中，正样本（检测出来有物体的框）比较多。而Anchor因为是预定义的，所以很多可能框中根本就没有物体，所以负样本比较多。因为易分辨的负样本较多，所有时候是是模型把易分辨的负样本都找出来了，但真正困难的正样本并没有找出来，而因为最后是加权平均，所以Loss还是低。</p><p>所以就对Loss进行调整，调整难分辨的样本的权重更高，易分辨的样本的权重变低，如果模型想要Loss低，就要“啃硬骨头”。</p><p>当时很多one-stage算法都是Anchor-based算法。</p><h2 id="端到端"><a href="#端到端" class="headerlink" title="端到端"></a>端到端</h2><p>之前的算法都需要NMS来解决冗余框问题。因为在预测不同框的时候没有信息传递。后面的模型用LSTM、Transformer这些模型来完成信息的交流。</p><p>后面还有比较新的Pix2Seq、GLIP等这种特别的模型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.bilibili.com/video/BV1kC4y1N7Nt/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">【入门级目标检测发展概述及概念简介】</a>（超棒！目标检测小白也能听懂！）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 在文献里迷路的日子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从策略梯度到GRPO</title>
      <link href="/post/4288241426.html"/>
      <url>/post/4288241426.html</url>
      
        <content type="html"><![CDATA[<h1 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h1><blockquote><p>参考：<a href="https://www.bilibili.com/video/BV1tj5jz2EkE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">B站视频</a></p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="经验轨迹-τ"><a href="#经验轨迹-τ" class="headerlink" title="经验轨迹$τ$"></a>经验轨迹$τ$</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/从策略梯度到GRPO/3f7e-b206749e5cdf89f558f69472a437f380.png" alt="南大本科生论文获NeurIPS Poster！俞扬团队首次揭示强化学习「记忆池」最优利用方法|记忆|俞扬|南大_新浪新闻"></p><p>智能体可以感知到当前的环境状态，然后作出行为，会影响环境的状态并从环境中得到奖励。这里将状态表示为$s$，智能体的行为表示为$a$，智能体得到的奖励为$r$。</p><p>那么智能体与环境交互一次的经验轨迹为 $ \tau = s_0, a_0, r_1, s_1, \cdots, a_{T - 1}, r_T, s_T $，其中 $ T $ 为终止时刻。就是状态、智能体采取的动作、智能体得到的奖励、下一状态……的一个数列。</p><h3 id="经验轨迹的概率-P-theta-tau"><a href="#经验轨迹的概率-P-theta-tau" class="headerlink" title="经验轨迹的概率 $ P_\theta(\tau) $"></a>经验轨迹的概率 $ P_\theta(\tau) $</h3><p>经验轨迹出现的概率由环境和智能体两部分决定：</p><script type="math/tex; mode=display">\begin{align*}P_\theta(\tau) &= p(s_0) \cdot \pi_\theta(a_0 \mid s_0) \cdot p(s_1 \mid s_0, a_0) \cdot \pi_\theta(a_1 \mid s_1) \cdots \pi_\theta(a_{T - 1} \mid s_{T - 1}) \cdot p(s_T \mid s_{T - 1}, a_{T - 1}) \\&= p(s_0) \prod_{i = 0}^{T - 1} \pi_\theta(a_i \mid s_i) \cdot p(s_{i + 1} \mid s_i, a_i)\end{align*}</script><p>在这里，$p(s_0)$ 代表的是初始状态$s_0$出现的概率，$ \pi_\theta(a_0 \mid s_0) $代表的是在初始状态初始状态$s_0$下Agent选择行为$a_0$的概率（跟策略$\pi$有关），$p(s_1 \mid s_0, a_0)$代表着在Agent选择动作$a_0$和$s_0$的状态下，转移到$s_1$的概率。</p><blockquote><p>其中，策略$\pi$受参数$\theta$影响，$ p(s_0) $ 和 $ p(s’ \mid s, a) $ 由环境决定，与 $ \theta $ 无关。</p><p>经验轨迹出现的概率与$\theta$有关的就只有$ \pi_\theta(a_0 \mid s_0) $。</p></blockquote><h3 id="累积回报-R-tau"><a href="#累积回报-R-tau" class="headerlink" title="累积回报 $ R(\tau) $"></a>累积回报 $ R(\tau) $</h3><p>每一次行动，智能体都会得到一个奖励，将这次行动$r_1\cdots r_T$所有的奖励加起来就能得到累计回报。其是经验轨迹的函数，因为策略一个经验轨迹可以计算出一个累计回报。</p><script type="math/tex; mode=display">R(\tau) = r_1 + r_2 + \cdots + r_{T - 1} + r_T = \sum_{t = 1}^T r_t</script><h3 id="累积期望回报-bar-R-theta"><a href="#累积期望回报-bar-R-theta" class="headerlink" title="累积期望回报 $ \bar{R}_\theta $"></a>累积期望回报 $ \bar{R}_\theta $</h3><p>真实的累积回报为采样得到累积回报的期望，即：</p><script type="math/tex; mode=display">\bar{R}_\theta = E_{\tau \sim P_\theta(\tau)}[R_\tau] = \sum_\tau R(\tau)P_\theta(\tau)</script><p>在选定一个策略$\pi$的情况下（也就是选择参数$\theta$的情况下），可以得到每一个策略轨迹$\tau$出现的概率和通过策略轨迹$\tau$得到的累计回报。所以将所有的策略轨迹加权求和，就可以得到在策略$\pi$的情况下的一个累计期望回报 $ \bar{R}_\theta $。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>策略梯度的想法是，找到一个策略$\pi$使得能得到的累积期望回报最大。</strong></p><script type="math/tex; mode=display">\arg\max_{\theta} \bar{R}_\theta</script><p><strong>而又因为 $ \bar{R}_\theta $是$\theta$的函数，所以可以通过求导的方式找到$\theta$使得 $ \bar{R}_\theta $最大。</strong>所以首先要对其求梯度。</p><p>对 $ \bar{R}_\theta $ 关于 $ \theta $ 求梯度：</p><script type="math/tex; mode=display">\nabla \bar{R}_\theta = \sum_\tau R(\tau) \nabla P_\theta(\tau) = \sum_\tau R(\tau) P_\theta(\tau) \frac{\nabla P_\theta(\tau)}{P_\theta(\tau)}</script><blockquote><p>因为$R(\tau) $跟策略是无关的，给定了经验轨迹就能计算出一个累计回报。</p></blockquote><p>由于 </p><script type="math/tex; mode=display">\nabla \log y = \frac{\nabla y}{y}</script><p>那么 </p><script type="math/tex; mode=display">\nabla \bar{R}_\theta = \sum_\tau R(\tau)P_\theta(\tau)\nabla \log P_\theta(\tau) = E_{\tau \sim P_\theta(\tau)}[R(\tau)\nabla \log P_\theta(\tau)]</script><blockquote><p>因为转为$\log$之后可以将$P_\theta(\tau)$中的乘法拆为加法。</p></blockquote><p>上面期望符号可以通过采样消除，即 $N$ 次采样后，得到 </p><script type="math/tex; mode=display">\nabla \bar{R}_\theta = \frac{1}{N} \sum_{n=1}^N R(\tau^n)\nabla \log P_\theta(\tau^n)</script><blockquote><p>因为真实的经验轨迹的概率分布是未知的，所以只能靠多次采样来近似期望。</p></blockquote><p>对 $P_\theta(\tau)$ 求对数，得到 </p><script type="math/tex; mode=display">\begin{align*} \log P_\theta(\tau) &= \log p(s_0) + \log \pi_\theta(a_0 \mid s_0) + \log p(s_1 \mid s_0,a_0) + \log \pi_\theta(a_1 \mid s_1) + \cdots + \log \pi_\theta(a_{T - 1} \mid s_{T - 1}) + \log p(s_T \mid s_{T - 1},a_{T - 1}) \\ &= \log p(s_0) + \sum_{t = 0}^{T - 1} [\log \pi_\theta(a_t \mid s_t) + \log p(s_{t + 1} \mid s_t,a_t)] \end{align*}</script><p>对 $\log P_\theta(\tau)$ 关于 $\theta$ 求梯度，由于 $p(s’ \mid s,a)$ 与 $\theta$ 无关，因此全部被消掉，得到 </p><script type="math/tex; mode=display">\nabla \log P_\theta(\tau) = \sum_{t = 0}^{T - 1} \nabla \log \pi_\theta(a_t \mid s_t)</script><p>将 $\nabla \log P_\theta(\tau)$ 代入 $\nabla \bar{R}_\theta$，得到策略梯度： </p><script type="math/tex; mode=display">\nabla \bar{R}_\theta = \frac{1}{N} \sum_{n = 1}^N R(\tau^n) \sum_{t = 0}^{T - 1} \nabla \log \pi_\theta(a_t^n \mid s_t^n) = \frac{1}{N} \sum_{n = 1}^N \sum_{t = 0}^{T - 1} R(\tau^n)\nabla \log \pi_\theta(a_t^n \mid s_t^n)</script><p>然后用$\theta+\eta\nabla \bar{R}_\theta $就可以优化$\theta$使得累积期望回报越来越高。其中$\eta $是学习率。</p><p>总结一下，就是通过多次采样，得到多条经验轨迹，然后将每条经验轨迹得到的累计奖励做加权求和，从而得到平均累计奖励。通过梯度上升的方式，对$\theta$求导，得到平均累计奖励最大的时候的$\theta$。</p><h1 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h1><blockquote><p>全称叫Trusted Region Policy Optimization。</p><p>参考：<a href="https://www.bilibili.com/video/BV1YC4y1M7GW/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">基本思想</a>、<a href="https://www.bilibili.com/video/BV1aB4y1T7Fb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">算法讲解</a>、<a href="https://zhuanlan.zhihu.com/p/605886935">公式推导</a>、<a href="https://zhuanlan.zhihu.com/p/491587841">手写推导</a></p><p>这里的公式真是太复杂了TvT</p></blockquote><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>普通的策略梯度有一个问题，就是采样导致的随机性太强了。当步长不合适时，更新的参数所对应的策略是一个更不好的策略，当利用这个更不好的策略进行采样学习时，再次更新的参数会更差，因此很容易导致越学越差，最后崩溃。</p><p>TRPO的思想是，当策略更新后，累积期望回报的值不能更差。这样TRPO就可以逐渐接近最优解。</p><h2 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Trust-Region"><a href="#Trust-Region" class="headerlink" title="Trust Region"></a>Trust Region</h3><p>Trust Region就是TRPO的前两个词，中文为置信域。</p><p>它的想法是如果想要在$x \in X$中找到一个函数$f(x)$的最大值。而$f(x)$又不好求解，就可以在一个小邻域内，做$f(x)$的一个近似，在近似函数上找最大值。类似泰勒展开的思想。</p><p>形式化的表达如下，假设问题是：</p><script type="math/tex; mode=display">\text { Find } \boldsymbol{\theta}^{\star}=\underset{\boldsymbol{\theta}}{\operatorname{argmax}} J(\boldsymbol{\theta}) .</script><p>要通过迭代找出最优的 $\boldsymbol{\theta}$ ，假设上一步迭代得到的解为 $\boldsymbol{\theta}_{\text{old}}$ 。那么设 $\mathcal{N}(\boldsymbol{\theta}_{\text{old}})$ 为 $\boldsymbol{\theta}_{\text{old}}$ 的一个邻域，例如： $\mathcal{N}(\boldsymbol{\theta}_{\text{old}})=\{\boldsymbol{\theta}||\boldsymbol{\theta}-\boldsymbol{\theta}_{\text{old}}|_{2} \leq \Delta\}$ 。 若存在一个函数 $ L(\boldsymbol{\theta} \mid \boldsymbol{\theta}_{\text{old}})$ 能在 $\mathcal{N}(\boldsymbol{\theta}_{\text{old}})$ 内很好地近似 $J(\boldsymbol{\theta})$ ，则 $\mathcal{N}(\boldsymbol{\theta}_{\text{old}})$ 被称为Trust Region。</p><h3 id="折扣回报函数"><a href="#折扣回报函数" class="headerlink" title="折扣回报函数"></a>折扣回报函数</h3><p>定义折扣回报函数 $\eta(\pi)$ 为：</p><script type="math/tex; mode=display">\eta(\pi)=\mathbb{E}_{s_{0}, a_{0}, \ldots}\left[\sum_{t=0}^{\infty} \gamma^{t} r\left(s_{t}\right)\right]</script><p>其中$\gamma $是折扣因子。整条式子的意思是，一条经验轨迹是从$t=0$时刻到$t=\infty$，其中经过了一系列状态$s_0$到$s_\infty$，每个状态得到的奖励为$ r\left(s_{t}\right)$。因为未来的奖励相对及时奖励更没有吸引力，所以$t=0$的奖励没有折扣，而从$t=1$开始，就要给奖励乘上$t$个折扣因子$\gamma $。</p><p>所以回报函数 $\eta(\pi)$ 和累计回报其实是类似的，代表Agent能得到的奖励，只不过加上了折扣率。</p><h3 id="优势函数"><a href="#优势函数" class="headerlink" title="优势函数"></a>优势函数</h3><p>设$Q_{\pi}\left(s, a\right)$是在策略$\pi$，状态$s$下，选择动作$a$所能获得的奖励值。那就可以算出在策略$\pi$下，状态$s$的价值：</p><script type="math/tex; mode=display">V_{\pi}(s)=\pi\left(a_{1} \mid s\right) Q_{\pi}\left(s, a_{1}\right)+\cdots+\pi\left(a_{n} \mid s\right) Q_{\pi}\left(s, a_{n}\right)</script><p>定义$A_{\pi}(s, a)=Q_{\pi}(s, a)-V_{\pi}(s)$为优势函数。因为$\pi\left(a_{i} \mid s\right)$是在状态$s$下选择动作$a$的概率，所以$V_{\pi}(s)$等于$Q_{\pi}\left(s, a_i\right)$的加权均值。如果$A_{\pi}(s, a)$大于0，则说明选择动作$a$，得到的价值比平均值更大。</p><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/371156865">参考文章</a></p></blockquote><p>其的想法是当想求$X$关于某一个函数$f(x)$的期望时，即求$E=\mathbb{E}_{x \sim p(x)}[f(x)]$。如果随机变量 $X$ 无法直接从原始分布 $p(x)$ 下采样，那么可以另辟蹊径，从一个简单，可采样，定义域与 $p(x)$ 相同的概率分布 $\tilde{p}(x)$中进行采样。由于最终目标是求 $E = \mathbb{E}_{x \sim p(x)}[f(x)]$，那么可以进行简单的推导：</p><script type="math/tex; mode=display">\begin{aligned}E & =\mathbb{E}_{x \sim p(x)}[f(x)] \\& =\int_{x} p(x) f(x) d x \\& =\int_{x} \tilde{p}(x) \frac{p(x)}{\tilde{p}(x)} f(x) d x \\& =\mathbb{E}_{x \sim \tilde{p}(x)}\left[\frac{p(x)}{\tilde{p}(x)} f(x)\right]\end{aligned}</script><p>此时可以发现，原始问题转化成了求概率分布 $\tilde{p}(x)$ 下 $\frac{p(x)}{\tilde{p}(x)} f(x)$ 的期望，而此时概率分布 $\tilde{p}(x)$ 是我们寻找的一个简单，可采样的分布，且 $p(x), f(x)$ 都可以将样本 $x$ 输入到 $p$ 和 $f$ 中得到。那么依然可以通过蒙特卡洛法，从 $\tilde{p}(x)$ 中采样大量的样本来近似计算。</p><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><blockquote><p>网上看到的博客用了和刚才策略梯度的另一套符号，所以无奈下只能换了一套符号。</p></blockquote><p>因为TRPO算法想累积期望回报的值不能更差，所以就希望新的$\eta(\tilde{\pi})$会比原先的$\eta(\pi)$更大。也就是希望$\eta(\tilde{\pi})-\eta(\pi)&gt;0$。</p><p>所以就要知道$\eta(\tilde{\pi})-\eta(\pi)$的结果是什么，然后再更新策略的时候使之大于0即可。</p><p>针对这一想法，Sham Kakade于2002年提出了以下等式：</p><script type="math/tex; mode=display">\eta(\tilde{\pi})=\eta(\pi)+\mathbb{E}_{s_{0}, a_{0}, \cdots \sim \tilde{\pi}}\left[\sum_{t=0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right]</script><blockquote><p>证明过程为：</p><script type="math/tex; mode=display">\begin{aligned} &\mathbb{E}_{\tau \mid \tilde{\pi}}\left[\sum_{t = 0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right] \\ &= \mathbb{E}_{\tau \mid \tilde{\pi}}\left[\sum_{t = 0}^{\infty} \gamma^{t}\left(Q_{\pi}(s_t, a_t)-V_{\pi}\left(s_{t}\right)\right)\right] \quad \text{（优势函数定义）} \\ &= \mathbb{E}_{\tau \mid \tilde{\pi}}\left[\sum_{t = 0}^{\infty} \gamma^{t}\left(r\left(s_{t}\right)+\gamma V_{\pi}\left(s_{t + 1}\right)-V_{\pi}\left(s_{t}\right)\right)\right]  \\ &= \mathbb{E}_{\tau \mid \tilde{\pi}}\left[\sum_{t=0}^{\infty} \gamma^{t}r(s_{t}) + \sum_{t=0}^{\infty}\gamma^{t+1}V_{\pi}(s_{t+1}) - \sum_{t=0}^{\infty}\gamma^{t}V_{\pi}(s_{t})\right] \quad \text{（线性性质拆分求和）} \\ &= \mathbb{E}_{\tau \mid \tilde{\pi}}\left[-V_{\pi}(s_{0}) + \sum_{t=0}^{\infty}\gamma^{t}r(s_{t})\right]  \\ &= -\mathbb{E}_{\tau \mid \tilde{\pi}}\left[V_{\pi}(s_{0})\right] + \mathbb{E}_{\tau \mid \tilde{\pi}}\left[\sum_{t=0}^{\infty}\gamma^{t}r(s_{t})\right]  \\ &= -\eta(\pi) + \eta(\tilde{\pi})\end{aligned}</script><p>其中：</p><ul><li>$\sum_{t=0}^{\infty} \gamma^{t+1} V_{\pi}\left(s_{t+1}\right)-\sum_{t=0}^{\infty} \gamma^{t} V_{\pi}\left(s_{t}\right)$，因为前者的第1项就是后者的第2项，所以相减之后只保留了后者的第二项$-V_{\pi}\left(s_{0}\right)$。</li><li>$\sum_{t=0}^{\infty} \gamma^{t} r\left(s_{t}\right)$就是折扣回报函数的定义。就等价于$V_{\tilde\pi}\left(s_{0}\right)$，因为前面是在$\tilde\pi$策略下求期望。</li><li>$V_{\pi}\left(s_{0}\right)$的意思是$s_0$在$\pi$策略下的价值，也就是Agent能获得的价值，和折扣回报函数是一个意思！</li></ul></blockquote><p>可以将$\mathbb{E}_{s_{0}, a_{0}, \cdots \sim \tilde{\pi}}\left[\sum_{t=0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right]$拆开，因为其代表的是不同的经验轨迹$\tau$下，采取策略$\tilde\pi$所能获得的所有经过折扣的优势函数的值的期望。所以：</p><script type="math/tex; mode=display">\begin{align*}\mathbb{E}_{s_0, a_0, \dots \sim \tilde{\pi}}\left[ \sum_{t=0}^{\infty} \gamma^t A_{\pi}(s_t, a_t) \right]&= \sum_{t=0}^{\infty} \gamma^t \mathbb{E}_{s_t, a_t\sim \tilde{\pi}} \left[ A_{\pi}(s_t, a_t) \right] \quad \text{（线性期望性质）} \\&= \sum_{t=0}^{\infty} \gamma^t \sum_{s} P(s_t = s \mid \tilde{\pi}) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a) \quad \text{（状态-动作联合分布分解）} \\&= \sum_{t=0}^{\infty} \sum_{s} \gamma^t P(s_t = s \mid \tilde{\pi}) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a) \quad \text{（交换求和顺序）} \end{align*}</script><blockquote><p>其中：</p><ul><li>$\mathbb{E}_{s_{t}, a_{t} \sim \tilde{\pi}}\left[A_{\pi}\left(s_{t}, a_{t}\right)\right]$就是在$\tilde\pi$策略下，在$t$时刻，不同的$s_t,a_t$所能得到的均值。是一个联合分布，所以均值为：$\sum_{s} \sum_{a} P(s_t=s ,a\mid \tilde{\pi}) A_{\pi}(s, a)$，然后再拆成条件概率就可以得到$\sum_{s} P\left(s_{t}=s \mid \tilde{\pi}\right) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a)$</li><li>由于  $P\left(s_{t}=s \mid \tilde{\pi}\right) \sum_{a} \tilde{\pi}(a \mid s) \gamma^{t} A_{\pi}(s, a)  $是收敛的（有限MDP过程），因此两个求和符号可交换位置。</li></ul></blockquote><p>最终可以写成$\sum_{t=0}^{\infty} \sum_{s} \gamma^t P(s_t = s \mid \tilde{\pi}) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a) $</p><p>定义 $\rho_{\pi}$ 为：</p><script type="math/tex; mode=display">\rho_{\pi}(s)=P\left(s_{0}=s|\pi\right)+\gamma P\left(s_{1}=s|\pi\right)+\gamma^{2} P\left(s_{2}=s|\pi\right)+\ldots=\sum_{t = 0}^{\infty} \gamma^{t} P\left(s_{t}=s|\pi\right)</script><p>就可以将上式进一步写成：</p><script type="math/tex; mode=display">\sum_{s} \rho_{\tilde{\pi}}(s) \sum_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)</script><p>所以$\eta(\tilde{\pi})=\eta(\pi)+\sum_{s} \rho_{\tilde{\pi}}(s) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a)$</p><blockquote><p>这里如果$\sum_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)&gt;0$的话，整个式子就是非负的，$\eta(\tilde{\pi})$也是非减的，但有时候可能因为噪声？导致$\sum_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)&lt;0$。所以也不是绝对递增的。这里我也没太搞清楚。</p></blockquote><p>这时状态$s$的分布由新的策略产生，对新的策略严重依赖。也就是$\rho_{\tilde{\pi}}(s)$依赖新策略。这导致很难找到最大的$\sum_{s} \rho_{\tilde{\pi}}(s) \sum_{a} \tilde{\pi}(a \mid s) A^{\pi}(s, a)$。因为每个新策略都会导致$\rho_{\tilde{\pi}}(s)$不一样，所以就采取旧的策略$\rho_{\pi}(s)$所对应的状态分布代替$\rho_{\tilde{\pi}}(s)$。当新旧参数很接近时，用旧的状态分布代替新的状态分布是合理的。</p><p><strong>这里就是Trust Region的应用，因为$\rho_{\tilde{\pi}}(s)$难求，所以在限制旧策略$\pi$和新策略$\tilde \pi$接近的情况下，用$\rho_{\pi}(s)$代替$\rho_{\tilde{\pi}}(s)$</strong>。这里作者用了KL散度来约束旧策略$\pi$和新策略$\tilde\pi$接近。</p><p>所以原来的代价函数变成了$L_{\pi}(\tilde{\pi})=\eta(\pi)+\sum_{s} \rho_{\pi}(s) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a)$。希望找到新的$\tilde \pi$使得代价函数最大。化成数学形式如下：</p><script type="math/tex; mode=display">\underset{\theta}{\operatorname{maxmize}}\quad\sum_{s} \rho_{\pi}(s) \sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a)\\s.t. \quad D_{KL}\left(\theta_{\text {old }}, \theta\right) \leq \delta</script><p>但到这里还没结束，还有一个技巧：重要性采样。使得上面这个目标更容易优化。</p><p>首先是重要性采样，对于$\sum_{a} \tilde{\pi}(a \mid s) A_{\pi}(s, a)$，直接计算新策略下的期望收益需要重新采样（$ \tilde{\pi}(a \mid s)$是个概率，求和之后是加权平均，也就是期望）。所以就要用<strong>重要性采样</strong>找到一个简单的分布方便求期望。</p><p>用重要性采样的定义，可以写出：</p><script type="math/tex; mode=display">\sum_{a} \tilde{\pi}\left(a \mid s\right) A_{\pi}\left(s, a\right)=\mathbb{E}_{a \sim \pi}\left[\frac{\tilde{\pi}\left(a \mid s\right)}{\pi\left(a \mid s\right)} A_{\pi}\left(s, a\right)\right]</script><p>所以原式就变成了</p><script type="math/tex; mode=display">\underset{\theta}{\operatorname{maxmize}}\quad\sum_{s} \rho_{\pi}(s) \mathbb{E}_{a \sim \pi}\left[\frac{\tilde{\pi}\left(a \mid s\right)}{\pi\left(a \mid s\right)} A_{\pi}\left(s, a\right)\right]\\s.t. \quad D_{KL}\left(\theta_{\text {old }}, \theta\right) \leq \delta</script><p>然后刚才说到：</p><script type="math/tex; mode=display">\rho_{\pi}(s)=P\left(s_{0}=s|\pi\right)+\gamma P\left(s_{1}=s|\pi\right)+\gamma^{2} P\left(s_{2}=s|\pi\right)+\ldots=\sum_{t = 0}^{\infty} \gamma^{t} P\left(s_{t}=s|\pi\right)</script><p>所以，将$\sum_{s} \rho_{\pi}(s)$写开：</p><script type="math/tex; mode=display">\sum_{s} \rho_{\pi}(s)=\sum_{s} \sum_{t=0}^{\infty} \gamma^{t} P\left(s_{t}=s \mid \pi\right) .</script><p>然后交换求和顺序</p><script type="math/tex; mode=display">\sum_{s} \rho_{\pi}(s)=\sum_{t=0}^{\infty} \gamma^{t} \sum_{s} P\left(s_{t}=s \mid \pi\right)</script><p>因为$\sum_{s} P\left(s_{t}=s \mid \pi\right)=1$（概率的归一性），所以$\sum_{s} \rho_{\pi}(s)=\sum_{t=0}^{\infty} \gamma^{t} \cdot 1=\sum_{t=0}^{\infty} \gamma^{t}$，这里的$\sum_{t = 0}^{\infty} \gamma^{t}$是一个几何级数，然后通过无穷级数求和的公式，可以知道，当公比 $|\gamma|&lt;1$ 时，无穷几何级数 $\sum_{t=0}^{\infty} \gamma^{t}$ 收敛，其和为：</p><script type="math/tex; mode=display">\frac{1}{1-\gamma}</script><p>所以可知$\sum_{s} \rho_{\pi}(s)\cdot(1-\gamma)=1$，所以$\rho_{\pi}(s)\cdot(1-\gamma)$是一个概率。</p><p>那么</p><script type="math/tex; mode=display">\frac{1}{1-\gamma}\sum_{s} \rho_{\pi}(s)\cdot(1-\gamma)\cdot f(s)=\frac{1}{1-\gamma} E_{s \sim \tilde{\rho}_{\pi}}[f(s)]</script><p>所以最后整个式子就可以化成：</p><script type="math/tex; mode=display">\begin{array}{ll}\underset{\theta}{\operatorname{maxmize}} & \frac{1}{1-\gamma} \mathbb{E}_{s \sim \tilde{\rho}_{\pi},a \sim \pi}\left(\frac{\tilde{\pi}(a \mid s)}{\pi(a \mid s)} A_{\pi}(s, a)\right) \\\text { subject to } & D_{\mathrm{KL}}\left(\theta_{\text {old }}, \theta\right) \leq \delta\end{array}</script><blockquote><p>剩下的求解就是最优化范畴了，这里就不写啦，感兴趣的可以自己去探究。</p></blockquote><h1 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h1><blockquote><p>全称叫Proximal Policy Optimization。</p><p>参考：<a href="https://www.bilibili.com/video/BV1YC4y1M7GW/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">B站视频</a>、<a href="https://www.bilibili.com/video/BV11J4m137fY/?spm_id_from=333.1387.search.video_card.click">可视化</a></p></blockquote><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><p>TRPO的问题是KL散度本身就难算，它还在约束条件里，所以就更难了。所以后面就提出了PPO，是对TRPO的优化。一是将约束放在优化目标中，就变成了无约束优化问题。二是将KL散度去掉，改成更容易计算的限制。前者是PPO-penalty，后者是PPO-clip，PPO-clip是对PPO-penalty的优化。</p><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><h3 id="PPO-penalty"><a href="#PPO-penalty" class="headerlink" title="PPO-penalty"></a>PPO-penalty</h3><p>PPO-penalty通过将TRPO的约束放在优化目标中，使TRPO变成了一个无约束优化问题。数学形式如下：</p><script type="math/tex; mode=display">\underset{\theta}{\operatorname{maxmize}} \quad  \frac{1}{1-\gamma} \mathbb{E}_{s \sim \tilde{\rho}_{\pi},a \sim \pi}\left(\frac{\tilde{\pi}(a \mid s)}{\pi(a \mid s)} A_{\pi}(s, a)\right)-\beta  D_{\mathrm{KL}}\left(\theta_{\text {old }}, \theta\right)</script><p>只是将约束简单的放到了目标函数当中。</p><h3 id="PPO-clip"><a href="#PPO-clip" class="headerlink" title="PPO-clip"></a>PPO-clip</h3><p>PPO-penalty虽然变成了无约束优化问题，但是还是需要计算KL散度，还是很难算。既然只是要限制$\theta$相对于$\theta_{old}$不要更新太多。PPO-clip采取了一个很简单的方法，就是将$\frac{\tilde{\pi}(a \mid s)}{\pi_{\theta}(a \mid s)}$限制在一个范围内，这样新策略选出来的行为和旧策略选出来的行为就不会差太多。</p><p>所以要优化函数的数学形式如下：</p><script type="math/tex; mode=display">\underset{\theta}{\operatorname{maxmize}} \quad \min \left(\frac{\tilde\pi(a \mid s)}{\pi_{}(a \mid s)} A_{\pi}(s, a), \quad \operatorname{clip}\left(\frac{\tilde\pi(a \mid s)}{\pi_{}(a \mid s)}, 1-\epsilon, 1+\epsilon\right) A_{\pi}(s, a)\right)</script><p>这样新策略$\tilde \pi$选择行为$a$的概率和旧策略$\pi$差太多的时候，新策略就会被限制，避免策略变化的幅度太大。</p><h1 id="GRPO"><a href="#GRPO" class="headerlink" title="GRPO"></a>GRPO</h1><blockquote><p>终于到GRPO了。感动</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1pXA5eyEEg/?spm_id_from=333.1387.search.video_card.click&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">B站视频</a></p></blockquote><h2 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h2><p>GRPO算法在DeepSeekMath论文中提出，下面是摘自论文中的图。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/从策略梯度到GRPO/image-20250424174425849.png" alt="image-20250424174425849"></p><p>在PPO算法中，需要通过计算$V_\pi(s)$来得到优势函数$A(s,a)$的值，而为了计算$V_\pi(s)$，又需要一个神经网络。而GRPO就通过其他方法计算了优势函数$A(s,a)$的值，就不需要用神经网络拟合$V_\pi(s)$了。</p><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><p>还是看论文中的配图，GRPO的策略模型会生成很多个输出$o_1\cdots o_G$，如果是大语言模型，就会生成多个回答。然后通过奖励函数，就可以计算出多个奖励$r_1\cdots r_G$。然后用：</p><script type="math/tex; mode=display">\hat{A}_{i,t}=\widetilde{r}_{i}=\frac{r_{i}-\operatorname{mean}(\mathbf{r})}{\operatorname{std}(\mathbf{r})}</script><blockquote><p>这里的$t$代表的是token，因为论文中讲的是大模型</p></blockquote><p>就可以计算出优势函数的值。</p><p>最后定义出来的目标函数如下（截自论文）：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{J}_{G R P O}(\theta) & =\mathbb{E}\left[q \sim P(Q),\left\{o_{i}\right\}_{i=1}^{G} \sim \pi_{\theta_{o l d}}(O \mid q)\right] \\& \frac{1}{G} \sum_{i=1}^{G} \frac{1}{\left|o_{i}\right|} \sum_{t=1}^{\left|o_{i}\right|}\left\{\min \left[\frac{\pi_{\theta}\left(o_{i, t} \mid q, o_{i,<t}\right)}{\pi_{\theta_{o l d}}\left(o_{i, t} \mid q, o_{i,<t}\right)} \hat{A}_{i, t}, \operatorname{clip}\left(\frac{\pi_{\theta}\left(o_{i, t} \mid q, o_{i,<t}\right)}{\pi_{\theta_{\text {old }}\left(o_{i, t} \mid q, o_{i,<t}\right)}}, 1-\varepsilon, 1+\varepsilon\right) \hat{A}_{i, t}\right]-\beta \mathbb{D}_{K L}\left[\pi_{\theta}| | \pi_{r e f}\right]\right\}\end{aligned}</script><p>$\min$里面的部分和PPO一样，只不过计算优势函数的方式变了，不再需要神经网络拟合了，然后还加了一项KL散度，论文里说是做一个正则项。</p>]]></content>
      
      
      <categories>
          
          <category> 在文献里迷路的日子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决DeepSpeed offload时找不到动态库的问题</title>
      <link href="/post/1070898293.html"/>
      <url>/post/1070898293.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在DeepSpeed Offload时候需要编译并加载一个动态库，使得Adam优化器可以从GPU卸载到CPU。可以用以下方法测试编译是否成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> deepspeed</span><br><span class="line">deepspeed.ops.op_builder.CPUAdamBuilder().load()</span><br></pre></td></tr></table></figure><p>我刚开始的时候遇到了报错，提示找不到其中的一个动态链接库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/xxx/miniconda3/envs/Visual-RFT/<span class="built_in">bin</span>/../lib/gcc/x86_64 - conda - linux - gnu/<span class="number">11.2</span><span class="number">.0</span>/../../../../x86_64 - conda - linux - gnu/<span class="built_in">bin</span>/ld: cannot find - lcurand: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果要编译动态库，需要用到CUDA Toolkit，而且要是官网下载的（Conda/Pytorch安装的CUDA Toolkit是不全的）。</p><p>所以需要：</p><ol><li>下载安装CUDA Toolkit</li><li>设置环境变量让DeepSpeed可以找到（因为我是非ROOT用户安装的，我装在了<code>~/CUDA12.2</code>下）</li></ol><p>然后这样初始化即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initial_deepspeed</span>():</span><br><span class="line">    cuda_lib_path = os.path.expanduser(<span class="string">&quot;~/CUDA12.2/lib64&quot;</span>)</span><br><span class="line">    nvjitlink_lib_path = os.path.expanduser(</span><br><span class="line">        <span class="string">&quot;~/miniconda3/envs/Visual-RFT/lib/python3.10/site-packages/nvidia/nvjitlink/lib&quot;</span></span><br><span class="line">    )</span><br><span class="line">    conda_lib_path = os.path.expandvars(<span class="string">&quot;$CONDA_PREFIX/lib&quot;</span>)</span><br><span class="line">    cuda_bin_path = os.path.expanduser(<span class="string">&quot;~/CUDA12.2/bin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 LD_LIBRARY_PATH（追加到原值）</span></span><br><span class="line">    os.environ[<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>] = <span class="string">&quot;:&quot;</span>.join(<span class="built_in">filter</span>(<span class="literal">None</span>, [</span><br><span class="line">        cuda_lib_path,</span><br><span class="line">        nvjitlink_lib_path,</span><br><span class="line">        conda_lib_path,</span><br><span class="line">        os.environ.get(<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    ]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 CUDA_PATH（直接覆盖）</span></span><br><span class="line">    os.environ[<span class="string">&quot;CUDA_PATH&quot;</span>] = os.path.expanduser(<span class="string">&quot;~/CUDA12.2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置 PATH（追加到原值）</span></span><br><span class="line">    os.environ[<span class="string">&quot;PATH&quot;</span>] = <span class="string">&quot;:&quot;</span>.join(<span class="built_in">filter</span>(<span class="literal">None</span>, [</span><br><span class="line">        os.environ.get(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">        cuda_bin_path</span><br><span class="line">    ]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> deepspeed</span><br><span class="line"></span><br><span class="line">    deepspeed.ops.op_builder.CPUAdamBuilder().load()</span><br></pre></td></tr></table></figure><p>设置好环境变量就可以初始化成功了，但要在<code>import deepspeed</code>之前就设置好环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用fast-reid提取人物特征</title>
      <link href="/post/158142455.html"/>
      <url>/post/158142455.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近要做人物的识别，有些图片没有正脸，所以要用到ReID相关的技术（有正脸就很好处理，用人脸检测现在有很多现成的库）。在网上找了一圈没找到很适合入门的教程，于是打算在这里写一下我是怎么用<code>fast-reid</code>库来做人物的特征向量的提取的。方便之后的人入坑。</p><blockquote><p>现成的<code>reid</code>的库我就只找到了<code>torchreid</code>和<code>fast-reid</code>。前者我尝试了，但没跑起来，而且代码好久没维护了，<code>fast-reid</code>是京东近年来发布的，品质更有保障，所以就选了后者。</p></blockquote><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><code>fast-reid</code>并不像一些Python包可以直接用<code>pip install fastreid</code>安装，它的<a href="https://github.com/JDAI-CV/fast-reid">项目地址</a>中并没有提到能用pip直接安装，所以装起来有点麻烦。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先先创建一个虚拟环境，<code>.venv</code>或者<code>conda</code>都可以。然后安装一些依赖（<code>fast-reid</code>需要用到，在<a href="https://github.com/JDAI-CV/fast-reid/blob/master/INSTALL.md">项目的文档里也提到了</a>）：</p><ol><li><code>Pytorch ≥ 1.6</code></li><li><code>torchvision</code>（装和<code>Pytorch</code>版本兼容的）</li><li><code>yacs</code></li><li><code>gdown</code></li><li><code>sklearn</code></li><li><code>termcolor</code> </li><li><code>tabulate</code> </li><li><code>faiss</code></li></ol><p>前面七个每个都用<code>pip install packet_name</code>安装就可以了。如果速度慢或者网络错误记得加上<code>-i https://mirrors.aliyun.com/pypi/simple/</code>，换成阿里镜像源。</p><p>最后一个的安装有些麻烦，推荐不用pip安装，用<code>conda install -c pytorch faiss-cpu</code>就可以从<code>pytorch</code>官方的渠道下载<code>faiss</code>，又快又简单。</p><blockquote><p>如果需要GPU版本的<code>faiss</code>可以<code>conda install -c pytorch faiss-gpu</code></p></blockquote><h2 id="安装fast-reid"><a href="#安装fast-reid" class="headerlink" title="安装fast-reid"></a>安装<code>fast-reid</code></h2><p>可以用<code>git clone</code>也可以直接下载<a href="https://github.com/JDAI-CV/fast-reid/tree/master/fastreid">这个文件夹</a>。做特征提取只需要用到项目代码中的<code>fastreid</code>、<code>configs</code>就可以了。</p><ul><li><code>fastreid</code>文件夹中是京东写好的库</li><li><code>configs</code>里是一些配置文件，也下下来，<code>fastreid</code>中的代码要用到</li></ul><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>最后还要下载一个你喜欢的模型做特征提取，在<a href="https://github.com/JDAI-CV/fast-reid/blob/master/MODEL_ZOO.md">这里</a>找一个你喜欢的模型下载。</p><p>我用的是Resnet50，下载链接为：<a href="https://github.com/JDAI-CV/fast-reid/releases/download/v0.1.1/market_bot_R50.pth">https://github.com/JDAI-CV/fast-reid/releases/download/v0.1.1/market_bot_R50.pth</a></p><p>直接<code>wget url</code>就可以了，如果嫌麻烦直接复制下面的代码，下载Resnet50：（可能不开VPN网络不是很好）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/JDAI-CV/fast-reid/releases/download/v0.1.1/market_bot_R50.pth</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>把文件夹还有模型文件按以下形式整理好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">├── configs</span><br><span class="line">├── fastreid</span><br><span class="line">├── market_bot_R50.pth</span><br></pre></td></tr></table></figure><p>然后新建一个Python文件，复制以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author:  xingyu liao</span></span><br><span class="line"><span class="string">@contact: sherlockliao01@gmail.com</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastreid.engine <span class="keyword">import</span> DefaultPredictor</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mp.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> RuntimeError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureExtractionDemo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg, parallel=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            cfg (CfgNode):</span></span><br><span class="line"><span class="string">            parallel (bool) whether to run the model in different processes from visualization.:</span></span><br><span class="line"><span class="string">                Useful since the visualization logic can be slow.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.cfg = cfg</span><br><span class="line">        self.parallel = parallel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> parallel:</span><br><span class="line">            self.num_gpus = torch.cuda.device_count()</span><br><span class="line">            self.predictor = AsyncPredictor(cfg, self.num_gpus)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.predictor = DefaultPredictor(cfg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_on_image</span>(<span class="params">self, original_image</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            original_image (np.ndarray): an image of shape (H, W, C) (in BGR order).</span></span><br><span class="line"><span class="string">                This is the format used by OpenCV.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            predictions (np.ndarray): normalized feature of the model.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># the model expects RGB inputs</span></span><br><span class="line">        original_image = original_image[:, :, ::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># Apply pre-processing to image.</span></span><br><span class="line">        image = cv2.resize(original_image, <span class="built_in">tuple</span>(self.cfg.INPUT.SIZE_TEST[::-<span class="number">1</span>]), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">        <span class="comment"># Make shape with a new batch dimension which is adapted for</span></span><br><span class="line">        <span class="comment"># network input</span></span><br><span class="line">        image = torch.as_tensor(image.astype(<span class="string">&quot;float32&quot;</span>).transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))[<span class="literal">None</span>]</span><br><span class="line">        predictions = self.predictor(image)</span><br><span class="line">        <span class="keyword">return</span> predictions</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_on_loader</span>(<span class="params">self, data_loader</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parallel:</span><br><span class="line">            buffer_size = self.predictor.default_buffer_size</span><br><span class="line"></span><br><span class="line">            batch_data = deque()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> cnt, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">                batch_data.append(batch)</span><br><span class="line">                self.predictor.put(batch[<span class="string">&quot;images&quot;</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= buffer_size:</span><br><span class="line">                    batch = batch_data.popleft()</span><br><span class="line">                    predictions = self.predictor.get()</span><br><span class="line">                    <span class="keyword">yield</span> predictions, batch[<span class="string">&quot;targets&quot;</span>].cpu().numpy(), batch[<span class="string">&quot;camids&quot;</span>].cpu().numpy()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(batch_data):</span><br><span class="line">                batch = batch_data.popleft()</span><br><span class="line">                predictions = self.predictor.get()</span><br><span class="line">                <span class="keyword">yield</span> predictions, batch[<span class="string">&quot;targets&quot;</span>].cpu().numpy(), batch[<span class="string">&quot;camids&quot;</span>].cpu().numpy()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> batch <span class="keyword">in</span> data_loader:</span><br><span class="line">                predictions = self.predictor(batch[<span class="string">&quot;images&quot;</span>])</span><br><span class="line">                <span class="keyword">yield</span> predictions, batch[<span class="string">&quot;targets&quot;</span>].cpu().numpy(), batch[<span class="string">&quot;camids&quot;</span>].cpu().numpy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncPredictor</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A predictor that runs the model asynchronously, possibly on &gt;1 GPUs.</span></span><br><span class="line"><span class="string">    Because when the amount of data is large.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_StopToken</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_PredictWorker</span>(mp.Process):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg, task_queue, result_queue</span>):</span><br><span class="line">            self.cfg = cfg</span><br><span class="line">            self.task_queue = task_queue</span><br><span class="line">            self.result_queue = result_queue</span><br><span class="line">            <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">            predictor = DefaultPredictor(self.cfg)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                task = self.task_queue.get()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(task, AsyncPredictor._StopToken):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                idx, data = task</span><br><span class="line">                result = predictor(data)</span><br><span class="line">                self.result_queue.put((idx, result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg, num_gpus: <span class="built_in">int</span> = <span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            cfg (CfgNode):</span></span><br><span class="line"><span class="string">            num_gpus (int): if 0, will run on CPU</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_workers = <span class="built_in">max</span>(num_gpus, <span class="number">1</span>)</span><br><span class="line">        self.task_queue = mp.Queue(maxsize=num_workers * <span class="number">3</span>)</span><br><span class="line">        self.result_queue = mp.Queue(maxsize=num_workers * <span class="number">3</span>)</span><br><span class="line">        self.procs = []</span><br><span class="line">        <span class="keyword">for</span> gpuid <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(num_gpus, <span class="number">1</span>)):</span><br><span class="line">            cfg = cfg.clone()</span><br><span class="line">            cfg.defrost()</span><br><span class="line">            cfg.MODEL.DEVICE = <span class="string">&quot;cuda:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(gpuid) <span class="keyword">if</span> num_gpus &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span></span><br><span class="line">            self.procs.append(</span><br><span class="line">                AsyncPredictor._PredictWorker(cfg, self.task_queue, self.result_queue)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self.put_idx = <span class="number">0</span></span><br><span class="line">        self.get_idx = <span class="number">0</span></span><br><span class="line">        self.result_rank = []</span><br><span class="line">        self.result_data = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> self.procs:</span><br><span class="line">            p.start()</span><br><span class="line"></span><br><span class="line">        atexit.register(self.shutdown)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, image</span>):</span><br><span class="line">        self.put_idx += <span class="number">1</span></span><br><span class="line">        self.task_queue.put((self.put_idx, image))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        self.get_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.result_rank) <span class="keyword">and</span> self.result_rank[<span class="number">0</span>] == self.get_idx:</span><br><span class="line">            res = self.result_data[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">del</span> self.result_data[<span class="number">0</span>], self.result_rank[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># Make sure the results are returned in the correct order</span></span><br><span class="line">            idx, res = self.result_queue.get()</span><br><span class="line">            <span class="keyword">if</span> idx == self.get_idx:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            insert = bisect.bisect(self.result_rank, idx)</span><br><span class="line">            self.result_rank.insert(insert, idx)</span><br><span class="line">            self.result_data.insert(insert, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.put_idx - self.get_idx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, image</span>):</span><br><span class="line">        self.put(image)</span><br><span class="line">        <span class="keyword">return</span> self.get()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> self.procs:</span><br><span class="line">            self.task_queue.put(AsyncPredictor._StopToken())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default_buffer_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.procs) * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torch.backends <span class="keyword">import</span> cudnn</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastreid.config <span class="keyword">import</span> get_cfg</span><br><span class="line"><span class="keyword">from</span> fastreid.utils.logger <span class="keyword">import</span> setup_logger</span><br><span class="line"><span class="keyword">from</span> fastreid.utils.file_io <span class="keyword">import</span> PathManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取配置文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_cfg</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># load config from file and command-line arguments</span></span><br><span class="line">    cfg = get_cfg()</span><br><span class="line">    <span class="comment"># add_partialreid_config(cfg)</span></span><br><span class="line">    cfg.merge_from_file(args.config_file)</span><br><span class="line">    cfg.merge_from_list(args.opts)</span><br><span class="line">    cfg.freeze()</span><br><span class="line">    <span class="keyword">return</span> cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_parser</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Feature extraction with reid models&quot;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--config-file&quot;</span>,  <span class="comment"># config路径，通常包含模型配置文件</span></span><br><span class="line">        metavar=<span class="string">&quot;FILE&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;path to config file&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--parallel&quot;</span>,  <span class="comment"># 是否并行</span></span><br><span class="line">        action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;If use multiprocess for feature extraction.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--input&quot;</span>,  <span class="comment"># 输入图像路径</span></span><br><span class="line">        nargs=<span class="string">&quot;+&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;A list of space separated input images; &quot;</span></span><br><span class="line">             <span class="string">&quot;or a single glob pattern such as &#x27;directory/*.webp&#x27;&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--output&quot;</span>,  <span class="comment"># 输出结果路径</span></span><br><span class="line">        default=<span class="string">&#x27;demo_output&#x27;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&#x27;path to save features&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;--opts&quot;</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;Modify config options using the command-line &#x27;KEY VALUE&#x27; pairs&quot;</span>,</span><br><span class="line">        default=[],</span><br><span class="line">        nargs=argparse.REMAINDER,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postprocess</span>(<span class="params">features</span>):</span><br><span class="line">    <span class="comment"># Normalize feature to compute cosine distance</span></span><br><span class="line">    features = F.normalize(features)  <span class="comment"># 特征归一化</span></span><br><span class="line">    features = features.cpu().data.numpy()</span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_feature_extractor</span>(<span class="params">model_path=<span class="string">&quot;./market_bot_R50.pth&quot;</span>,config_file=<span class="string">&quot;./configs/Market1501/bagtricks_R50.yml&quot;</span>,parallel=<span class="literal">False</span></span>):</span><br><span class="line">    args = get_parser().parse_args([])  <span class="comment"># </span></span><br><span class="line">    args.config_file= config_file</span><br><span class="line">    args.opts.extend([<span class="string">&quot;MODEL.WEIGHTS&quot;</span>, model_path])</span><br><span class="line">    args.parallel = parallel <span class="comment"># 是否并行</span></span><br><span class="line"></span><br><span class="line">    cfg = setup_cfg(args)  <span class="comment"># 读取cfg文件</span></span><br><span class="line">    <span class="keyword">return</span> FeatureExtractionDemo(cfg, parallel=args.parallel)  <span class="comment"># 加载特征提取器，也就是加载模型</span></span><br></pre></td></tr></table></figure><p>简单解释一下代码，从开头一直到<code>postprocess</code>函数的定义，都是抄的<code>demo/predictor.py</code>里面的代码，因为该文件中已经实现了一个特征提取的模型<code>FeatureExtractionDemo</code>，给定<code>cv2</code>读取的一张图片，就可以返回其的特征向量。</p><p>后面的<code>get_feature_extractor</code>是我加的，用来初始化这个<code>FeatureExtractionDemo</code>。其中：</p><ul><li><code>model_path</code>是下载好的预训练模型的路径</li><li><code>config_file</code>是配置文件，我就用的<code>&quot;./configs/Market1501/bagtricks_R50.yml&quot;</code>，其他配置文件没试过</li><li><code>parallel</code>是是否启用并行化</li></ul><p><code>args = get_parser().parse_args([])</code>创建了一个默认的<code>args</code>，这样就不用命令行传参，可以直接用函数的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args.config_file= config_file</span><br><span class="line">args.opts.extend([<span class="string">&quot;MODEL.WEIGHTS&quot;</span>, model_path])</span><br><span class="line">args.parallel = parallel <span class="comment"># 是否并行</span></span><br></pre></td></tr></table></figure><p>后面的就是<code>demo/predictor.py</code>的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfg = setup_cfg(args)  <span class="comment"># 读取cfg文件</span></span><br><span class="line"><span class="keyword">return</span> FeatureExtractionDemo(cfg, parallel=args.parallel)  <span class="comment"># 加载特征提取器，也就是加载模型</span></span><br></pre></td></tr></table></figure><p>然后就可以通过这样的方式来创建特征提取模型，然后传入<code>cv2</code>读取的结果，就能得到特征向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">model=get_feature_extractor()</span><br><span class="line"></span><br><span class="line">img_path=<span class="string">&quot;path/to/your/image&quot;</span></span><br><span class="line">img=cv2.imread(img_path)</span><br><span class="line">feature=model.run_on_image(img)</span><br><span class="line"><span class="built_in">print</span>(feature.shape)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 在文献里迷路的日子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搬家记</title>
      <link href="/post/670212549.html"/>
      <url>/post/670212549.html</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>原先的博客运行在我的Windows笔记本上，因为平时不怎么用该笔记本，传输文件都用ToDesk，不是很方便。更重要的是，如果哪天它坏掉了，那我就得重新配置一次环境，还要重新配置一次Hexo。环境还是小事，Windows备份也麻烦，如果哪天磁盘坏了，写过的博客就整个不见了。</p><p>总之，想着不能让我的博客绑定在这个Windows笔记本上。痛定思痛😭，决定将其整个环境搬迁到Docker当中。</p><h1 id="迁移过程"><a href="#迁移过程" class="headerlink" title="迁移过程"></a>迁移过程</h1><h2 id="服务器的选择"><a href="#服务器的选择" class="headerlink" title="服务器的选择"></a>服务器的选择</h2><p>因为：</p><ol><li>需要配置Docker以及Node.js环境，我不想在自己笔记本上装太多东西。</li><li>需要让女友也能将博客上传。</li></ol><p>所以我选择将Hexo博客运行在一个服务器上。搜索了一圈，发现阿里云天工开物计划可以白嫖服务器。配置还不错：</p><ol><li>2核CPU</li><li>2G内存</li><li>50G硬盘</li><li>每月20G免费流量</li><li>自带公网IP</li></ol><p>最重要的是免费，还是包年的。于是我打算把Hexo部署在上面。</p><p>领取的方法可见<a href="https://www.bilibili.com/opus/1043397734079397891?spm_id_from=333.1387.0.0">《如何白嫖阿里云服务器？》</a></p><h2 id="打包Hexo博客"><a href="#打包Hexo博客" class="headerlink" title="打包Hexo博客"></a>打包Hexo博客</h2><p>迁移的第一步就是把原先的博客整个打包，我把整个Hexo博客都存在了一个Blog文件夹下，所以只需要把这个文件夹压缩就好了。</p><p>除了写的博客以外，另一个需要迁移的就是Hexo的环境。主要就是<code>git</code>、<code>Node.js</code>这两个。前者没有什么需要迁移的，而后者要迁移的就是<code>npm</code>安装的包。</p><p>想要看到<code>npm</code>底下安装了什么，只需要运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list</span><br></pre></td></tr></table></figure><p>我就安装了这些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-- hexo-abbrlink@2.2.1</span><br><span class="line">+-- hexo-deployer-git@4.0.0</span><br><span class="line">+-- hexo-generator-archive@2.0.0</span><br><span class="line">+-- hexo-generator-category@2.0.0</span><br><span class="line">+-- hexo-generator-index@3.0.0</span><br><span class="line">+-- hexo-generator-search@2.4.3</span><br><span class="line">+-- hexo-generator-tag@2.0.0</span><br><span class="line">+-- hexo-lazyload-image@1.0.13</span><br><span class="line">+-- hexo-math@5.0.0</span><br><span class="line">+-- hexo-renderer-ejs@2.0.0</span><br><span class="line">+-- hexo-renderer-kramed@0.1.4</span><br><span class="line">+-- hexo-renderer-mathjax@0.6.0</span><br><span class="line">+-- hexo-renderer-pug@3.0.0</span><br><span class="line">+-- hexo-renderer-stylus@3.0.1</span><br><span class="line">+-- hexo-server@3.0.0</span><br><span class="line">+-- hexo-theme-landscape@1.0.0</span><br><span class="line">`-- hexo@7.2.0</span><br></pre></td></tr></table></figure><p>把这些信息整理好之后就可以开始正式迁移了</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>只需要在服务器上先安装Docker，之后的环境就在Docker里面配置。Docker的安装，参考这个<a href="https://blog.csdn.net/u011278722/article/details/137673353">博客</a>。</p><p>简而言之就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装前先卸载操作系统默认安装的docker，</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装必要支持</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阿里源（推荐使用阿里的gpg KEY）</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">#阿里apt源</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新源</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装最新版本的Docker</span></span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><blockquote><p>这里是一些解释，可以直接跳过不看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br></pre></td></tr></table></figure><p><code>apt-transport-https</code>：用于通过 HTTPS 协议来传输软件包的工具，确保软件包下载的安全性。</p><p><code>ca-certificates</code>：包含证书颁发机构（CA）的证书，用于验证 HTTPS 连接的安全性。</p><p><code>curl</code>：一个用于从服务器传输数据的命令行工具，常用于下载文件。</p><p><code>software-properties-common</code>：提供了一些用于管理软件源和软件属性的通用工具。</p><p><code>gnupg</code>：GNU Privacy Guard，用于处理 GPG（GNU Privacy Guard）密钥，用于验证软件包的签名。</p><p><code>lsb-release</code>：用于获取系统的发行版信息，如 Ubuntu 的版本代号等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>GPG 密钥用于确保数据的安全性和完整性，以及验证数据的发送者身份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>这条命令的作用是为当前的 Ubuntu 系统配置阿里云的 Docker CE 软件源，以便通过 <code>apt</code> 命令方便地安装和更新 Docker 相关软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>安装 Docker 相关的软件包，包括 Docker Engine（docker-ce）、Docker 命令行工具（docker-ce-cli）和容器运行时（containerd.io）。通过执行这条指令，可以在系统中安装 Docker，以便进行容器化应用的部署和管理。</p></blockquote><h3 id="配置Hexo运行环境"><a href="#配置Hexo运行环境" class="headerlink" title="配置Hexo运行环境"></a>配置Hexo运行环境</h3><p>因为是在Docker中运行Hexo，所以在Docker里配置Hexo环境。Docker入门可以参考<a href="https://zhuanlan.zhihu.com/p/23599229">这篇文章</a>。</p><p>虽然可以先启动一个镜像（可以看成迷你虚拟机），再在这个迷你虚拟机里配置环境。但是这样可重复性就比较差，所以我采用编写Dockerfile的形式来配置环境（可以把Dockerfile看成包含要在迷你虚拟机里执行的一系列指令的文本文件）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Node.js作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">16.15</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置阿里云镜像源(Debian系统)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s|http://deb.debian.org/debian|http://mirrors.aliyun.com/debian|g&#x27;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i <span class="string">&#x27;s|http://security.debian.org/debian-security|http://mirrors.aliyun.com/debian-security|g&#x27;</span> /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Git</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo配置</span></span><br><span class="line"><span class="comment"># Hexo配置</span></span><br><span class="line"><span class="comment"># 全局安装Hexo CLI</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g hexo-cli</span></span><br><span class="line"><span class="comment"># 全局安装其他插件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g hexo-deployer-git --save</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g hexo-abbrlink hexo-generator-search hexo-lazyload-image hexo-math hexo-renderer-kramed hexo-renderer-mathjax hexo-renderer-pug --save</span></span><br><span class="line"><span class="comment"># 全局SEO相关插件（可选）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install -g hexo-generator-sitemap hexo-generator-baidu-sitemap@0.1.4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python配置</span></span><br><span class="line"><span class="comment"># 安装Python</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3 python3-pip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH配置</span></span><br><span class="line"><span class="comment"># 生成 SSH 密钥</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span> -f /root/.ssh/id_rsa -N <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="comment"># 将GitHub的SSH主机密钥添加到容器的known_hosts文件中</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> ssh-keyscan github.com &gt;&gt; /root/.ssh/known\_hosts</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露服务端口（本地预览用）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本开始部署,把./Volumn挂载到/app下</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>,<span class="string">&quot;/app/Volumn/scripts/start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>这里主要执行了以下几步：</p><ul><li>把apt换到阿里云，默认源是国外的，阿里云服务器访问不了。</li><li>安装git、Node.js</li><li>安装Hexo需要用到的一系列插件（这里是全局安装）。但如果之前用过Hexo，并在Blog项目下安装了这些插件。那理论上可以直接用项目下的插件，也就是你迁移过来的文件夹中的插件，就不需要再全局安装了。</li><li>安装Python以及pip（可选，因为我用脚本自动化发布博客）</li><li>配置SSH，并信任GitHub网站（要不然没法<code>git pull</code>将博客发布到网站上）</li><li>设置了镜像启动时运行脚本</li></ul><p>然后就构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hexo-blog .</span><br></pre></td></tr></table></figure><blockquote><p>意思是在当前文件夹下，用<code>./Dockerfile</code>来构建名为<code>hexo-blog</code>的镜像</p></blockquote><p>构建完毕之后就可以启动镜像了</p><h2 id="Docker启动！"><a href="#Docker启动！" class="headerlink" title="Docker启动！"></a>Docker启动！</h2><h3 id="拷贝SSH公钥"><a href="#拷贝SSH公钥" class="headerlink" title="拷贝SSH公钥"></a>拷贝SSH公钥</h3><p>首先需要用以下方式启动制作好的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v ./Volumn:/app/Volumn -it hexo-blog bash</span><br></pre></td></tr></table></figure><p><code>-v ./Volumn:/app/Volumn</code>意思是将<code>./Volumn</code>文件夹（不包含<code>Volumn</code>文件夹）整个<strong>同步</strong>到容器（运行起来的镜像，相当于代码和进程之间的关系）的<code>/app/Volumn</code>下。之后对<code>./Volumn</code>中的任何修改都会同步到Docker容器中，反之亦然。我在<code>./Volumn</code>下面放了我打包过来的Blog文件夹，还有一些脚本，方便我上传博客。</p><p>另外，<code>-it hexo-blog bash</code>意思是交互式启动<code>hexo-blog</code>镜像，然后用<code>bash</code>命令代替之前写的<code>CMD [&quot;bash&quot;,&quot;/app/Volumn/scripts/start.sh&quot;]</code>。因为这里要进去拷贝镜像中的SSH公钥，放到github的setting中。这样才能用SSH的方式来执行<code>git pull</code>（也就是<code>hexo d</code>）。</p><blockquote><p>注意这里是先把<code>./Volumn</code>同步到<code>/app/Volumn</code>，再执行命令（CMD里设置的命令）。并且<code>./Volumn</code>会覆盖原来<code>/app/Volumn</code>中的所有内容。之前不知道还踩坑了😭</p></blockquote><p>通过以下命令就能得到SSH公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /root/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后把公钥放到github的setting中。</p><h3 id="正式启动Docker"><a href="#正式启动Docker" class="headerlink" title="正式启动Docker"></a>正式启动Docker</h3><p>拷贝完之后用以下方式就可以启动博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v ./Volumn:/app/Volumn -d hexo-blog</span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>参数表示后台执行（Docker你自己去执行自己的吧！我不管你啦！）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">git config --global --add safe.directory /app/Volumn/Blog/.deploy_git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /app/Volumn</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ./Blog</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"><span class="built_in">cd</span> ./scripts</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">python3 ./main.py</span><br></pre></td></tr></table></figure><p>我给我的博客设置了一些自动化，所以<code>/app/Volumn/scripts/start.sh</code>脚本最后启动了一个Python程序。定期到<code>/app/Volumn/Articles</code>中检查我有没有新的文章，并帮我自动发布。</p><h1 id="SMB文件服务器配置"><a href="#SMB文件服务器配置" class="headerlink" title="SMB文件服务器配置"></a>SMB文件服务器配置</h1><p>SMB的配置又是一件麻烦事情，本来以为是最简单的事情。因为Mac的Finder可以通过SMB将文件上传到服务器，我想上传到<code>/app/Volumn/Articles</code>中，这样就能让脚本帮我自动发布文章了。</p><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>参考这篇<a href="https://blog.csdn.net/weixin_44894962/article/details/105574864">文章</a></p><p>首先先要在服务器端安装 Samba</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install samba</span><br></pre></td></tr></table></figure><p>然后启动Samba并看其的运行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start smb nmb //启动服务器</span><br><span class="line">systemctl status smb nmb //查看服务器状态</span><br></pre></td></tr></table></figure><p>然后需要去更改Samba的配置文件，添加你想要共享的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在配置文件最下面添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">comment = Common share</span><br><span class="line">path = /home/samba</span><br><span class="line">browseable = <span class="built_in">yes</span></span><br><span class="line">guest ok = no</span><br><span class="line">writable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><blockquote><p><code>[common]</code>里的<code>common</code>代表共享出去的名字，起一个自己喜欢的就好，比如我写的就是<code>[hexo]</code></p><p><code>comment</code>是注释，不怎么需要管</p><p><code>path = /home/samba</code>是你要共享的文件夹的路径。注意！这里要特别注意这个路径上所有文件夹的权限。比如我之前想共享<code>/root</code>文件夹下的一个文件夹，但是这个文件夹是只有root用户才能查看的。Samba就不能打开这个文件夹，就会报错。路径上的文件夹，起码要给其他用户<code>r</code>和<code>x</code>的权限，这样Samba才能列出这个文件夹下有哪些文件夹。才能通过路径一步步找到你想共享的文件夹。最好就是共享普通用户的文件夹。并设置类似<code>chmod 777</code>或者<code>chmod 755</code>这样的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browseable = <span class="built_in">yes</span></span><br><span class="line">guest ok = no</span><br><span class="line">writable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>这几条指令意思是可读、不允许游客访问（一定要登录）、可修改</p></blockquote><p>然后要记得创建<code>path</code>所指向的文件夹（或者预先存在也可以）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/samba    //建立文件夹</span><br><span class="line"><span class="built_in">chmod</span> 777 /home/samba //授权</span><br></pre></td></tr></table></figure><p>这样就能建立一个共享文件夹啦。</p><p>然后需要添加一个用户，这里不给他通过其他方式登录<code>-s /sbin/nologin</code>，让其只作为其他人共享文件夹所需要输入的账户密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /sbin/nologin sambauser  //创建账户</span><br><span class="line">smbpasswd -a sambauser //添加账户,然后输入你的密码并确认密码</span><br></pre></td></tr></table></figure><h3 id="阿里云服务器需要的特别配置"><a href="#阿里云服务器需要的特别配置" class="headerlink" title="阿里云服务器需要的特别配置"></a>阿里云服务器需要的特别配置</h3><p>因为139和445端口是网络攻击重灾区，所以阿里云的服务器默认封锁这两个端口，即使你想开也打不开。而SMB刚好需要这两个端口，所以需要去配置文件里改一个端口。还是在刚才的<code>/etc/samba/smb.conf</code>，在里面<code>[global]</code>下加入这一行<code>smb ports=4455</code>。让SMB服务监听4455端口，以后客户端就用这个端口来访问服务器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Browsing/Identification ###</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change this to the workgroup/NT-domain name your Samba server will part of</span></span><br><span class="line">   workgroup = WORKGROUP</span><br><span class="line"></span><br><span class="line"><span class="comment"># server string is the equivalent of the NT Description field</span></span><br><span class="line">   server string = %h server (Samba, Ubuntu)</span><br><span class="line">   smb ports=4455</span><br></pre></td></tr></table></figure><p>然后重启一下SMB服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart smb</span><br></pre></td></tr></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>这里我用的是Mac，打开Finder，点击前往，连接服务器。然后输入<code>smb://服务器ip地址:4455/common</code>，这里<code>common</code>填写之前在配置文件添加的自己起的共享出去的名字。然后输入用户名密码，就可以连接成功了</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本来以为Docker是比较难配置的部分，没想到是SMB弄了我几个小时😡</p>]]></content>
      
      
      <categories>
          
          <category> 手记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/post/284249815.html"/>
      <url>/post/284249815.html</url>
      
        <content type="html"><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><h2 id="图论基础概念"><a href="#图论基础概念" class="headerlink" title="图论基础概念"></a>图论基础概念</h2><ul><li><p><strong>有限图</strong>：顶点数和边数有限的图称为有限图。</p></li><li><p><strong>平凡图</strong>：只有一个顶点的图。</p></li><li><p><strong>零图</strong>：一个没有边的图被称为零图。</p></li><li><p><strong>n阶图</strong>：顶点数为n的图。</p></li><li><p><strong>$(n,m)$图</strong>：顶点数为 <em>𝑛</em> 的图，边数为 <em>𝑚</em> 的图</p></li><li><p><strong>边的重数</strong>：连接两个相同顶点的边的条数</p></li><li><p><strong>环</strong> ：端点重合为一点的边</p></li><li><p><strong>简单图</strong>：无环无重边的图；其余的图称为复合图</p></li><li><p>顶点 <em>𝑢</em> 与 <em>𝑣</em> 相邻接</p><ul><li><p>顶点 <em>𝑢</em> 与 <em>𝑣</em> 间有边相连接</p></li><li><p><em>𝑢</em> 与 <em>𝑣</em> 称为边的两个端点</p></li><li><p>通常规定一个顶点与自身是邻接的</p></li></ul></li><li><p>顶点 <em>𝑢</em> 与边 <em>𝑒</em> 相关联：顶点 <em>𝑢</em> 是边 <em>𝑒</em> 的端点</p></li><li><p>边 $e_1$与边 $e_2$相邻接：边 $e_1$ 与边 $e_2$​​ 有公共端点</p></li><li><p><strong>途径</strong>：有限非空序列 $ w = v_0e_1v_1e_2v_2 \ldots e_kv_k $，$ e_i $ 端点 $ v_{i-1}, v_i $。途径长度为边数；$ v_0, v_k $ 分别为起点终点。</p></li><li><p><strong>迹</strong>：边不重复的途径。</p></li><li><strong>路</strong>：顶点不重复的途径。</li><li><strong>闭途径、闭迹与圈</strong>：起点终点重合的途径、迹、路。闭迹也称为回路。长度为 $ k $ 的圈称为$k$圈，$𝑘$ 为奇数（偶数）时称为奇（偶）圈</li><li><strong>顶点间距离</strong>：$ u, v $ 间最短路长度 $ d(u, v) $。</li><li><strong>顶点间的连通性</strong>：$ u, v $ 间存在途径。</li><li><strong>连通图</strong>：连通图中任意两点连通。若图 $ G $ 不连通，则其补图连通。</li><li><strong>连通分支</strong>：非连通图极大连通部分。连通分支个数，称为分支数。</li><li><strong>图的直径</strong>：$ d(G) = \max \{d(u, v) | u, v \in V \}$。</li></ul><h1 id="Peterson图"><a href="#Peterson图" class="headerlink" title="Peterson图"></a>Peterson图</h1><p>Peterson图是K5的线图的补图。Petersen图的同构多种多样，其自同构有120种。</p><p><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320203608407.png" alt="image-20240320203608407"></p><h2 id="图同构"><a href="#图同构" class="headerlink" title="图同构"></a>图同构</h2><p>同构图：顶点数相同，边数相同，结构相同</p><p><strong>数学定义：</strong> 两个图 $ G_1 = (V_1, E_1) $ 和 $ G_2 = (V_2, E_2) $ 是同构的，如果存在一个双射 $ f: V_1 \rightarrow V_2 $，使得对于所有 $ u, v \in V_1 $，$ (u, v) \in E_1 $ 当且仅当 $ (f(u), f(v)) \in E_2 $​。且 $xy$ 和 $m(x)m(y)$ 重数相同，称$G_1, G_2$​ 同构。<strong>关键在于找到这个双射</strong>。</p><h1 id="几种典型的图"><a href="#几种典型的图" class="headerlink" title="几种典型的图"></a>几种典型的图</h1><h2 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h2><p>$n$个顶点的完全图：$n$阶完全图，用$K_n$​表示</p><p>$𝐾_𝑛$ 的边数为 $\frac{n(n-1)}{2}$</p><p><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320204443140.png" alt="image-20240320204443140"></p><h2 id="偶图"><a href="#偶图" class="headerlink" title="偶图"></a>偶图</h2><p><strong>点集可以分解为两个子集 $𝑋$ 和 $𝑌$，使得每条边的一个端点在 $𝑋$ 中，另一个在 $𝑌$ 中</strong></p><p>性质：</p><ol><li>偶图中没有环与三角形，可以有重边。</li><li>完全偶图：$𝑋 (𝑌)$ 的每个顶点与 $𝑌 (𝑋)$ 的每个顶点相连，任取 $𝑋, 𝑌$ 中各一点均有边相连</li><li>$k$正则偶图：每个顶点度数均为$k$，$k$正则偶图的两个顶点子集包含顶点个数相等。</li></ol><h2 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h2><p>$对于一个简单图  G=(V, E) , 令集合  E_{1}=\{u v \mid u \neq v, u, v \in V\} 称图  H=\left(V, E_{1} \backslash E\right)  为  G  的补图$</p><p>注意：</p><ol><li>只有简单图才能定义补图</li><li>图和其补图顶点集合相同</li><li>任意一对顶点相邻的充分必要条件是它们在补图中不相邻</li><li><em>𝑛</em> 阶简单图边数与其补图边数之和等于 $𝐾_𝑛$ 的边数 $\frac{n(n-1)}{2}$</li></ol><h3 id="自补图"><a href="#自补图" class="headerlink" title="自补图"></a>自补图</h3><p>如果 <em>𝐺</em> 与其补图同构，则称 <em>𝐺</em> 为自补图。<strong>并不是任意一个简单图都是自补图</strong></p><p><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320205606253.png" alt="image-20240320205606253"></p><p><mark>定理</mark></p><script type="math/tex; mode=display">若 𝑛 阶图 𝐺 是自补图，则有 𝑛 = 4𝑘 或 4𝑘 + 1</script><blockquote><p>利用 <em>𝑛</em> 阶图边数与其补图边数之和为 $𝐾_𝑛$​ 的边数</p></blockquote><h1 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h1><p><strong>顶点度</strong>：在图 $ G $ 中，顶点 $ v $ 的度 $ d(v) $ 是指与 $ v $​ 关联的边的数目。</p><p>相关概念：</p><ul><li><strong>最小度</strong>：图 $ G $ 的最小度 $ \delta(G) $ 是所有顶点中度数最小的值。</li><li><strong>最大度</strong>：图 $ G $ 的最大度 $ \Delta(G) $ 是所有顶点中度数最大的值。</li><li><strong>奇点</strong>：度数为奇数的顶点称为奇点。</li><li><strong>偶点</strong>：度数为偶数的顶点称为偶点。</li><li><strong>正则图</strong>：设 $ G = (V, E) $ 为简单图，如果对所有节点 $ v $ 有 $ d(v) = k $，则称 $ G $ 为 $ k $ 正则图。这意味着图中的每个顶点都有相同的度数 $ k $。</li></ul><h2 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a><mark>握手定理</mark></h2><p>握手定理：</p><script type="math/tex; mode=display">任意图中所有顶点的度的和等于边数的 2 倍</script><p>推论：</p><ul><li>任何图中，奇点个数为偶数</li><li>正则图的阶数和度数不同时为奇数</li></ul><h2 id="图的度序列"><a href="#图的度序列" class="headerlink" title="图的度序列"></a>图的度序列</h2><p>图 $G$ 的各个点的度 $d_1, d_2, \ldots, d_n$ 构成的<strong>递增</strong>非负整数组 $(d_1, d_2, \ldots, d_n)$ 称为 $G$ 的度序列。</p><ul><li><strong>一个图的度序列与序列中元素排列无关</strong>。</li><li><strong>每个图对应唯一一个度序列</strong>。</li><li>同构的图具有相同的度序列。</li></ul><h3 id="度序列判别定理"><a href="#度序列判别定理" class="headerlink" title="度序列判别定理"></a>度序列判别定理</h3><p><mark>定理：</mark></p><p>非负整数组 $(d_1, d_2, \ldots, d_n)$ 是图的度序列的<strong>充分必要条件</strong>是该序列中元素的总和为偶数。</p><blockquote><ul><li><p><strong>充分性</strong>：构造对应度序列的图</p><ul><li><p>数组中为奇数的数字个数必为偶数</p></li><li><p>若 $𝑑_i$ 为偶数，则在与之对应的点作 $\frac{𝑑_𝑖}{2}$ 个环</p></li><li><p>对于剩下的偶数个奇数，两两配对后分别在每配对点间先连一条边，然后在每个顶点做环</p></li></ul></li><li><p><strong>必要性</strong>：握手定理得到，一个图的度数和为偶数。</p></li></ul></blockquote><h3 id="图序列"><a href="#图序列" class="headerlink" title="图序列"></a>图序列</h3><p>一个非负整数组如果是某<strong>简单图</strong>的度序列，我们称它为可图序列，简称图序列</p><ul><li><p>存在问题：什么样的非负整数组是图序列？(彻底解决)</p></li><li><p>计数问题：一个图序列对应多少不同构的图？（解决的不好）</p></li><li><p>构造问题：如何画出图序列对应的所有不同构图？（没有解决）</p></li></ul><h4 id="图序列判别定理（Havel-Hakimi-定理）"><a href="#图序列判别定理（Havel-Hakimi-定理）" class="headerlink" title="图序列判别定理（Havel-Hakimi 定理）"></a>图序列判别定理（Havel-Hakimi 定理）</h4><p><mark>定理：</mark></p><p>给定一个非负整数序列 $(d_1, d_2, \ldots, d_n)$，其中 $d_1 \geq d_2 \geq \ldots \geq d_n$，则该序列是图序列的充分必要条件是：对于序列 $(d_2 - 1, d_3 - 1, \ldots, d_{d_1+1} - 1, d_{d_1+2}, \ldots, d_n)$，它也是一个图序列。</p><p><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320212013566.png" alt="image-20240320212013566"></p><h2 id="度的性质"><a href="#度的性质" class="headerlink" title="度的性质"></a>度的性质</h2><p><mark>定理：</mark></p><script type="math/tex; mode=display">一个简单图 𝐺 的 n 个点的度不能互不相同，也就是必有两个点度数相等</script><blockquote><p>证明：鸽笼原理</p><ol><li><strong>情形 1：图 $G$​ 没有孤立点</strong><ul><li>在没有孤立点的情况下，每个顶点的度数 $d(v)$ 必须满足 $1 \leq d(v) \leq n - 1$。</li><li>根据鸽笼原理，由于有 $n$ 个顶点和 $n - 1$ 个可能的度数，至少有两个顶点的度数相同。</li></ul></li><li><strong>情形 2：图 $G$ 只有一个孤立点</strong><ul><li>假设 $G_1$ 是图 $G$ 去掉孤立点后的部分。</li><li>在 $G_1$ 中，每个非孤立顶点的度数 $d(v)$ 满足 $1 \leq d(v) \leq n - 2$。</li><li>同样根据鸽笼原理，由于 $G_1$ 有 $n - 1$ 个顶点和 $n - 2$ 个可能的度数，至少有两个顶点的度数相同。</li></ul></li><li><strong>情形 3：图 $G$ 有两个以上的孤立点</strong><ul><li>如果图 $G$ 有两个或更多的孤立点，那么在这些孤立点之间不存在边。</li><li>在这种情况下，定理显然成立，因为孤立点的度数为 0，而其他非孤立点的度数至少为 1。</li><li>因此，至少有两个顶点的度数相同（即，孤立点的度数相同）。</li></ul></li></ol></blockquote><h1 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h1><p>如果图 $ H $ 的顶点集 $ V(H) $ 是图 $ G $ 的顶点集 $ V(G) $ 的子集，并且 $ H $ 的边集 $ E(H) $ 是 $ G $ 的边集 $ E(G) $ 的子集，则称 $ H $ 为 $ G $ 的子图，记为 $ H \subseteq G $。</p><ul><li>如果 $ H $ 不等于 $ G $，则称 $ H $ 为 $ G $ 的真子图。</li></ul><p><strong>点导出子图</strong>：</p><ul><li>对于 $ V’ \subseteq V(G) $，以 $ V’ $ 为顶点集，包括所有两个端点都在 $ V’ $ 中的 $ G $ 的边所组成的图，称为 $ G $ 的点导出子图，记为 $ G(V’) $。</li></ul><p><strong>边导出子图</strong>：</p><ul><li>对于 $ E’ \subseteq E(G) $，以 $ E’ $ 为边集，由 $ E’ $ 中所有端点构成的点集所组成的图，称为 $ G $ 的边导出子图，记为 $ G(E’) $。</li></ul><p><strong>生成子图</strong>：</p><ul><li>如果图 $ G $ 的一个子图包含 $ G $ 的所有顶点，则称该子图为 $ G $ 的一个生成子图。</li></ul><p><strong>简单图的生成子图数量</strong>：</p><ul><li>对于一个具有 $ m $ 条边的简单图 $ G $，它有 $ 2^m $ 个生成子图。<h1 id="图运算"><a href="#图运算" class="headerlink" title="图运算"></a>图运算</h1></li></ul><ol><li><strong>删点</strong>: $ G - V $ - 删除顶点集 $ V $ 中的顶点及相关联的边。</li><li><strong>删边</strong>: $ G - E $ - 删除边集 $ E $ 中的边，不删除顶点。</li><li><strong>并运算</strong>: $ G + H $ - 将两个图中的点和边合并成新图，适用于不相交的图。</li><li><strong>交运算</strong></li><li><strong>差运算</strong>: $ G - H $ - 从 $ G $ 中删除 $ H $ 中的边得到新图。</li><li><strong>对称差运算（环和）</strong>: $ G \Delta H = (G \cup H) - (G \cap H) $ - 两个图的并集与交集的差集。</li><li><strong>联运算</strong>: 未具体定义，将两个不相交图的每个顶点相互连接。</li></ol><h2 id="积运算"><a href="#积运算" class="headerlink" title="积运算"></a>积运算</h2><p>在图论中，积运算是将两个图组合成一个新的图的方法。具体定义如下：</p><ul><li><strong>定义</strong>：设 $ G_1 = (V_1, E_1) $ 和 $ G_2 = (V_2, E_2) $ 是两个图。</li><li><strong>操作</strong>：构造一个新的图，其顶点集为 $ V = V_1 \times V_2 $，即两个顶点集的笛卡尔积。</li><li><strong>连接规则</strong>：对于 $ V $ 中的任意两点 $ u = (u_1, u_2) $ 和 $ v = (v_1, v_2) $，当满足以下条件之一时，将 $ u $ 和 $ v $ 连接：<ul><li>$ u_1 = v_1 $ 且 $ u_2 $ 与 $ v_2 $ 在 $ G_2 $ 中相邻；</li><li>$ u_2 = v_2 $ 且 $ u_1 $ 与 $ v_1 $ 在 $ G_1 $ 中相邻。</li></ul></li><li><strong>结果</strong>：通过这种方式构造的新图称为 $ G_1 $ 与 $ G_2 $ 的积图，记为 $ G_1 \times G_2 $​。</li><li><strong>举例</strong>：可以用于定义超立方体<br><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320213540484.png" alt="image-20240320213540484"></li></ul><h2 id="合成运算"><a href="#合成运算" class="headerlink" title="合成运算"></a>合成运算</h2><p>合成运算是图论中另一种将两个图组合成新图的方法。具体定义如下：</p><ul><li><strong>定义</strong>：设 $ G_1 = (V_1, E_1) $ 和 $ G_2 = (V_2, E_2) $ 是两个图。</li><li><strong>操作</strong>：构造一个新的图，其顶点集为 $ V = V_1 \times V_2 $，即两个顶点集的笛卡尔积。</li><li><strong>连接规则</strong>：对于 $ V $ 中的任意两点 $ u = (u_1, u_2) $ 和 $ v = (v_1, v_2) $，当满足以下条件之一时，将 $ u $ 和 $ v $ 连接：<ul><li>$ u_1 $ 与 $ v_1 $ 在 $ G_1 $ 中相邻；</li><li>$ u_1 = v_1 $ 且 $ u_2 $ 与 $ v_2 $ 在 $ G_2 $ 中相邻。</li></ul></li><li><strong>结果</strong>：通过这种方式构造的新图称为 $ G_1 $ 与 $ G_2 $ 的合成图，记为 $ G_1 [G_2] $。</li><li><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320213713765.png" alt="image-20240320213713765"></li></ul><h1 id="偶图判定定理"><a href="#偶图判定定理" class="headerlink" title="偶图判定定理"></a>偶图判定定理</h1><p><mark>定理：</mark></p><script type="math/tex; mode=display">一个图是偶图当且当它不包含奇圈</script><blockquote><h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>假设 $ G $ 是一个偶图 $ (X, Y) $，且 $ C = v_0v_1 \ldots v_kv_0 $ 是 $ G $ 中的一个圈。不失一般性，我们假定 $ v_0 \in X $。那么，根据偶图的定义，$ v_{2i} \in X $ 且 $ v_{2i+1} \in Y $。因此，$ v_k \in Y $。所以，$ C $ 是一个偶圈。</p><h2 id="充分性"><a href="#充分性" class="headerlink" title="充分性"></a>充分性</h2><p>在图 $ G $ 中任意选取一个点 $ u $，我们定义集合 $ V $ 的分类如下：</p><ul><li><p>$ X = \{ x | d(u, x) = 2k, x \in V(G) \} $</p></li><li><p>$ Y = \{ y | d(u, y) = 2k + 1, y \in V(G) \} $<br>我们需要证明的是 $ X $ 中的任意两点 $ v $ 和 $ w $ 不邻接。<br>假设 $ v $ 和 $ w $ 是 $ X $ 中的任意两个顶点。设 $ P $ 是一条最短的 $ (u, v) $ 路径，而 $ Q $ 是一条最短的 $ (u, w) $ 路径。设 $ z $ 是 $ P $ 和 $ Q $ 的最后一个交点。</p><p><img src="/Users/wanhuabai/Library/Application Support/typora-user-images/image-20240320215713259.png" alt="image-20240320215713259">由于 $ P $ 和 $ Q $ 是最短路径，$ P $ 和 $ Q $ 中从 $ u $ 到 $ z $ 的段长度相同，因此它们的奇偶性也相同。又因为 $ P $ 和 $ Q $ 的长度均为偶数，所以 $ P $ 和 $ Q $ 中从 $ z $ 到 $ v $ 的段和从 $ z $ 到 $ w $ 的段奇偶性也相同。<br>如果 $ v $ 与 $ w $ 邻接，那么我们可以得到一个奇圈，这与 $ G $ 是偶图的事实相矛盾。因此，$ v $ 和 $ w $ 不邻接。这证明了 $ G $ 是一个偶图。</p></li></ul></blockquote><h1 id="图的代数表示"><a href="#图的代数表示" class="headerlink" title="图的代数表示"></a>图的代数表示</h1><p>代数表示主要有邻接矩阵、关联矩阵</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>定义：$\text { 设 } G \text { 为 } n \text { 阶图, } V=\left\{v_{1}, \cdots, v_{n}\right\} \text {, 邻接矩阵 } A(G)=\left(a_{i j}\right)$。其中$a_{ij}$是$v_i$,$v_j$​之间的边数。</p><p>性质：</p><ul><li>其具有非负性与对称性</li><li>同一图的不同形式的邻接矩阵是相似矩阵</li><li>如果 $𝐺$ 为简单图，$𝐴(𝐺)$​​ 为布尔矩阵</li></ul><p><mark>定理</mark>： $G$  连通的充分必要条件是  $A(G)$  不与矩阵  $\left(\begin{array}{l}A_{11}, 0 \\ 0, A_{22}\end{array}\right)$  相似, 非连通图的邻接矩阵一定能够写成准对角矩阵形式。</p><p><mark>定理</mark>：$\text { 记 } A^{k} \text { 的元素为 }\left\{a_{i j}^{k}\right\}, a_{i j}^{k} \text { 为 } v_{i} \text { 到 } v_{j} \text { 长度为 } k \text { 的途径条数 }$。</p><ul><li>推论：对简单图,  $A^{2}$  的元素  $a_{i i}^{2}$  是  $v_{i}$  的度数;  $A^{3}$  的元素  $a_{i i}^{3}$  是含  $v_{i}$  的三角形个数的 2 倍</li></ul><h1 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>算法流程：</p><ol><li><p>初始化：所有结点都未被访问，将源点的距离设为0，其他结点的距离设为$\infty$​</p></li><li><p>循环$n$次：</p><ul><li><p>找到表中还没被访问的、距离不为$\infty$​的结点。如果没有，则退出循环。</p></li><li><p>将该结点设置为已被访问</p></li><li><p>更新表中的距离为$min(「到结点j的距离」,「到结点i的距离」+「结点i到j的距离」)$​​</p><blockquote><p>如果有路径数组，则需要在更新最短距离的同时更新路径。如果到<code>节点i的距离</code>+<code>结点i到j的距离</code>更小，则<code>paths[j]=i</code></p></blockquote></li></ul></li></ol><p>算法的时间复杂度为$O(n^2)$</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化</span></span><br><span class="line">Distance_Matrix=...<span class="comment">#邻接矩阵</span></span><br><span class="line">min_distance=[infinity _ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">visited=[false _ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">paths=[<span class="literal">None</span> _ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化到start节点的距离为0</span></span><br><span class="line">min_distance[start]=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  <span class="comment">#找出还没被访问的且距离最小的节点的索引</span></span><br><span class="line">  index=get_next_node_index(visited,min_distance)</span><br><span class="line">  <span class="keyword">if</span> index=<span class="literal">None</span>:<span class="comment">#如果没有这样的节点，则说明不是连通的，退出循环</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#更新路径表和距离表</span></span><br><span class="line">  <span class="keyword">for</span> next_node_index <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> Distance_Matrix[index][next_node_index]!=infinity:<span class="comment">#找到了一个和当前点邻接的结点</span></span><br><span class="line">      <span class="keyword">if</span> min_distance[next_node_index]&lt;Distance_Matrix[index][next_node_index]+distance[index]:</span><br><span class="line">        min_distance[next_node_index]=Distance_Matrix[index][next_node_index]+distance[index]</span><br><span class="line">        paths[next_node_index]=index</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford最短路算法"><a href="#Bellman-Ford最短路算法" class="headerlink" title="Bellman-Ford最短路算法"></a>Bellman-Ford最短路算法</h2><p>算法流程：</p><ol><li><p>初始化：将源点的距离设为0，其他结点的距离设为$\infty$。path数组初始化为null。</p></li><li><p>循环$n-1$次：对所有的边$e(i,j)$，如果$d(j)&gt;d(i)+e(i,j)$。（d[i]是源点到i点的最短距离）</p><ul><li>$d(j)=d(i)+e(i,j)$</li><li>$path[j]=i$​​</li></ul><blockquote><p>第$k$次得到的$d$数组是源点经过至多$k$个中间点，到其他点的最小值。</p></blockquote><p>算法复杂度：$O(mn)$​</p></li></ol><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">distance=[infinity _ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">paths=[<span class="literal">None</span> _ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化到start节点的距离为0</span></span><br><span class="line">min_distance[start]=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> [i,j] <span class="keyword">in</span> all_edges:<span class="comment">#对所有边中的每一条边都执行下述操作</span></span><br><span class="line">    <span class="keyword">if</span> distance[j]&gt;distance[i]+D[i][j]:</span><br><span class="line">      distance[j]=distance[i]+D[i][j]</span><br><span class="line">      path[j]=i</span><br></pre></td></tr></table></figure><h3 id="改进的Bellman-Ford最短路算法"><a href="#改进的Bellman-Ford最短路算法" class="headerlink" title="改进的Bellman-Ford最短路算法"></a>改进的Bellman-Ford最短路算法</h3><p>如果$d(i)$上一次没有改变，则这一次不需要执行$d(j)&gt;d(i)+c(i,j)$。（要改变上一次就改变了）</p><p>改进后的算法流程：</p><ol><li>初始化：将源点的距离设为0，其他结点的距离设为$\infty$​。path数组初始化为null。</li><li>将源点$s$加入队列$q$当中。</li><li>如果队列不为空，则：<ol><li>取出队列顶部的结点$i$</li><li>对所有以$i$为起点的边$e(i,j)$，如果$d(j)&gt;d(i)+e(i,j)$​​。<ul><li>$d(j)=d(i)+e(i,j)$</li><li>$path[j]=i$​​</li><li>如果队列$q$中不含有$j$，则$q.push_back(j)$</li></ul></li></ol></li></ol><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>不含圈的图称为无圈图。<strong>树是连通的无圈图</strong>。森林也是无圈图。</p><p>树叶：树叶是一度的顶点。</p><h2 id="树的六种等价定义"><a href="#树的六种等价定义" class="headerlink" title="树的六种等价定义"></a>树的六种等价定义</h2><ul><li><em>𝑇</em> 是树</li><li><em>𝑇</em> 是含有 <em>𝑛</em> − 1 条边的无圈图</li><li><em>𝑇</em> 中任意两点连通，且有 <em>𝑛</em> − 1 条边</li><li><em>𝑇</em> 连通，且任意边都是割边</li></ul><blockquote><p>割边：删掉该边图就不连通了</p></blockquote><ul><li>任意两点仅有一条路</li><li><em>𝑇</em> 无圈，加入任意一条边后，<em>𝑇</em> 有且仅有一个圈</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a><mark>定理</mark></h2><blockquote><p>[!Note]</p><p>具体的证明看课件：graph-5.pdf。</p></blockquote><ol><li><p>树与森林都是偶图</p><blockquote><p>因为它们不包含奇圈，也就是圈长度为0</p></blockquote></li><li><p>每棵非平凡树至少有两片树叶</p><blockquote><p>反证法：如果不是，则要么不存在最长路（两端点度为1），要么树中存在圈</p></blockquote></li><li><p>图 𝐺 是树当且仅当 𝐺 中任意两点都被唯一的路连接。</p></li><li><p>设$T$是$(n,m)$树，有$m=n-1$。多了就有圈，少了就不连通。推论：具有 $k$ 个分支的森林有 $𝑛 − 𝑘$ 条边。</p></li><li><p>每个$n$阶连通图的边数至少为$n-1$</p></li><li><p>任意树$T$两个不邻接结点加上一条边后，可得到唯一圈。</p></li><li><p>设$G$是树且$\Delta \geq k$，$G$至少有$k$个一度结点。$\Delta$指的是树中度最大的顶点的度。</p></li><li><p>若森林  $G$  有  $2 k$  个奇数度顶点, 则  $G$  中有  $k$  条边不重合的路  $P_{1}, \cdots, P_{k}$  满足  $E(G)=\bigcup_{i} E\left(P_{i}\right)$​​ </p></li><li><p>树的度序列的充分必要条件：设  $S=\left\{d_{1}, \cdots, d_{n}\right\}$  满足:  $d_{1} \geq \cdots \geq d_{n} \geq 1, \sum d_{i}=2(n-1)$ , 存在树  $T$  度序列为  $S$​ 。</p></li></ol><h2 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h2><ul><li>图的顶点的离心率：$e(v) = \max\{d(u, v)|u \in V\}$。（一个顶点与其他顶点之间的最大距离）</li><li>图的半径：$r = \min\{e(v)|v \in V\}$。（所有顶点的离心率的最小值）</li><li>图的中心点：离心率等于半径的点。</li><li>图的中心：中心点的集合。</li></ul><p><mark>定理</mark>：树的中心由一个点或两个相邻点组成。</p><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>若图 $𝐺$ 的一个生成子图<em>𝑇</em> 是树，称它为 $𝐺$ 的一棵生成树。</p><ul><li>生成树的边称为树枝，<em>𝐺</em> 中非生成树的边称为弦</li><li>在连通边赋权图 $𝐺$​​ 中总权值最小的生成树，称为最小生成树</li><li>生成树一般不唯一</li><li>$s$到所有节点的最短路构成一棵树</li></ul><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li><p>每个连通图 $𝐺$ 至少包含一棵生成树。推论：若 $𝐺$ 是 $(𝑛,𝑚)$ 连通图，则 $𝑚 ≥ 𝑛 − 1$。</p><blockquote><p>可以用破圈法求生成树</p></blockquote></li><li><p>记图$G$中生成树的个数为$ \tau(G) $, 有$ \tau(G)=\tau(G-e)+\tau(\text { G.e })$。</p><blockquote><p>图 $𝐺$ 中，删掉边 $𝑒$ 后，把 $𝑒$ 的两个端点重合，得到的图记为 $𝐺.e$</p></blockquote></li><li><p>设  $G$  是顶点集合为  $V(G)=\left\{v_{1}, \cdots, v_{n}\right\}$  的图, 设  $A=\left(a_{i j}\right)$  是  $G$  的邻接矩阵,  $C=\left(c_{i j}\right)$  是  $n$  阶方阵, 其中:</p><script type="math/tex; mode=display">c_{i j}=\left\{\begin{array}{ll}d\left(v_{i}\right) & i=j \\-a_{i j} & i \neq j\end{array}\right.</script><p>则  $G$  的生成树棵数为  $C$  的任意一个余子式的值。</p><blockquote><p>定理中的矩阵 $𝐶$ 又称为图的 Laplace 矩阵，定义为 $𝐶 = 𝐷(𝐺) − 𝐴(𝐺)$。其中：$𝐷(𝐺)$ 为度对角矩阵，即主对角元为对应顶点度数，其余元素为 0；$𝐴(𝐺)$ 是邻接矩阵</p></blockquote></li></ol><h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>算法流程：</p><ol><li>选择权值最小边 $𝑒_1$</li><li>若已经选定边 $𝑒_1, 𝑒_2, · · · , 𝑒_𝑘$ , 则从 $𝐸 − {𝑒_1, 𝑒_2, · · · , 𝑒_𝑘 }$ 中选择最小边 $𝑒_𝑘+1$, 使$𝑒_1, 𝑒_2, · · · , 𝑒_𝑘$ 无圈。</li><li>不能增加边时，停止</li></ol><h4 id="管梅谷破圈法"><a href="#管梅谷破圈法" class="headerlink" title="管梅谷破圈法"></a>管梅谷破圈法</h4><p>算法流程：</p><ol><li>从任意圈开始，去掉圈中权值最大的一条边</li><li>不断破圈，直到 $G$ 中没有圈为止</li></ol><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><ol><li>任选一个顶点$u$，选择与$u$关联的权值最小的边作为最小生成树的第一条边$e_1$</li><li>在与已经选取边只有一个公共端点的边中，选取权值最小的边。直到选取$n-1$​条边为止</li></ol><h2 id="根树"><a href="#根树" class="headerlink" title="根树"></a>根树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>每条边都有一个方向的树称为有向树。</p><ul><li>以 $𝑣$ 为终点和起点的边数称为 $𝑣$ 的入度和出度</li><li>入度与出度之和称为点 $𝑣$ 的度</li></ul><p>一棵有向树，如果恰有一个顶点的入度为 0，其余顶点入度为 1，这样的的树称为根树。</p><ul><li>入度为 0 的点称为树根</li><li>出度为 0 的点称为树叶</li><li>入度为 1，出度大于 1 的点称为内点</li><li>内点和树根统称为分支点</li><li>顶点 $𝑣$ 到树根的距离称为 $𝑣$ 的层数</li><li>最大层数称为树高</li><li>对于根树，由其中节点及其后代导出的子图，称为子根树</li></ul><h3 id="几种不同类型的根树"><a href="#几种不同类型的根树" class="headerlink" title="几种不同类型的根树"></a>几种不同类型的根树</h3><h4 id="m元树"><a href="#m元树" class="headerlink" title="m元树"></a>m元树</h4><p>对于根树，若每个分支点至多𝑚 个儿子，称为𝑚 元根树；若每个分支点恰有 𝑚 个儿子，称它为完全 𝑚 元树。</p><p><mark>定理</mark>：在完全 $𝑚$ 元树中，若树叶数为 $𝑡$ , 分支点数为 $𝑖$ , 则$(m-1)i=t-1$。</p><h4 id="有序树与完全树"><a href="#有序树与完全树" class="headerlink" title="有序树与完全树"></a>有序树与完全树</h4><p>对于根树$𝑇$​​，若规定了每层顶点的访问次序，这样的根树称为有序树：一般次序为从左至右。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>$𝑚$​ 元树中，应用最广泛的是二元树。</p><p>有序树转化为二元树的方法：</p><ol><li>从根开始，保留每个父亲同其最左边儿子的连线，撤销与别的儿子的连线</li><li>兄弟间用从左至右的有向边连接</li><li>直接位于给定结点下面的儿子，作为左儿子，对于同一水平线上与给定结点右邻的结点，作为右儿子</li></ol><p>二元树的遍历：找到一种方法，每个结点恰好访问一次。有三种常用遍历方法：先序遍历、中序遍历、后序遍历。</p><h5 id="最优二叉树"><a href="#最优二叉树" class="headerlink" title="最优二叉树"></a>最优二叉树</h5><p>设  $T$  是二元树, 若对所有  $t$  片树叶赋权  $w_{i}(1 \leq i \leq t)$ , 权值为  $w_{i}$  的树叶层数记为  $L\left(w_{i}\right)$ , 称  $W(T)=\sum_{i=1}^{t} w_{i} L\left(w_{i}\right)$  为该二元树的权。</p><p>$𝑊 (𝑇 )$ 最小的二元树称为最优二元树。</p><p>Huffman 算法：</p><ol><li>令  $S=\left\{w_{1}, \cdots, w_{t}\right\}$ </li><li>从  $S$  中取出两个权值最小者  $w_{i}, w_{j}$ </li><li>画结点  $v_{i}, v_{j}$ , 权值  $w_{i}, w_{j}$ , 画  $v_{i}$, $v_{j}$  的父亲  $v$  ，权值  $w_{i}+w_{j}$ </li><li><p>$S \leftarrow\left(S-\left\{w_{i}, w_{j}\right\}\right) \cup\left\{w_{i}+w_{j}\right\}$</p></li><li><p>如果  $S$  只含一个元素, 停止, 否则转第二步</p></li></ol><h2 id="最小Steiner树"><a href="#最小Steiner树" class="headerlink" title="最小Steiner树"></a>最小Steiner树</h2><p>给出一个图$G=(V,E)$，和一个终端顶点集合$N$。</p><p>Steiner树问题：找到一个$G$的子树$T$，覆盖所有的$N$，并且权值和最小。</p><ul><li>当$N=V$的时候，是最小生成树问题</li><li>当$|N|=2$​的时候，是最短路径问题</li></ul><p>与最小生成树问题不同，Steiner树问题允许在树中添加图中未标记为终端顶点的其他顶点（称为Steiner顶点），以帮助降低总权重。</p><p>Steiner树是一个NP完全问题，因为其可以和X3C问题（已知的NP完全问题）一一对应。</p><blockquote><p>X3C问题：有一个集合X，它包含n个元素，以及一个集合S，它包含一些3个元素的子集，这些子集都是X的子集。X3C问题的目标是找到一个子集S’，它是S的子集，并且S’中的每个子集都是X的一个恰好覆盖，即每个子集都恰好覆盖X中的一个元素，并且每个元素都被恰好一个子集覆盖</p></blockquote><p>所以需要用近似算法来解决Steiner树问题。</p><h3 id="Metric闭包"><a href="#Metric闭包" class="headerlink" title="Metric闭包"></a>Metric闭包</h3><p>以$u$和$v$之间的最短距离作为顶点$u$和$v$​之间的边的权值，就可以得到metric闭包。</p><p>在metric闭包中：</p><ul><li>边的权重满足三角不等式：$d(A, C) \leq d(A, B) + d(B, C)$​</li><li>最小Steiner树在图中的成本等于最小Steiner树在其metric闭包中的成本</li></ul><p>而在Metric闭包中，<strong>最小生成树的成本不超过两倍的最小Steiner树的成本</strong>，所以可以用最小生成树去近似最小Steiner树。<a href="https://blog.csdn.net/zhonghangliu/article/details/106664312">参考文章</a></p><h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><h2 id="割边与割点"><a href="#割边与割点" class="headerlink" title="割边与割点"></a>割边与割点</h2><p>割边（桥）：若$w(G-e)&gt;w(G)$，则称$e$为$G$​​的一条割边。</p><p>割点：若 $E(G)$ 可划分为两个非空子集 $E_1, E_2$，使 $G(E_1)$ 和 $G(E_2)$ 以点 $v$ 为公共顶点，称 $v$ 为 $G$ 的割点。</p><blockquote><p>$w(G)$表示图$G$的连通分支数</p></blockquote><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li>$𝑒$ 是图 $𝐺$ 的割边当且仅当 $e$ 不在 $G$​​ 的任何圈中<ul><li>推论：$𝑒$ 为连通图 $𝐺$ 的一条边，若 $𝑒$ 含于 $𝐺$ 的某圈中，则 $𝐺$ − $𝑒$ 连通</li></ul></li><li>无环非平凡图 $G$，$v$ 是 $G$ 的割点，当且仅当 $w(G - v) &gt; w(G)$​。</li><li><p>$v$ 是树 $T$ 的割点，当且仅当 $v$ 是分支点。</p></li><li><p>一个顶点 $v$ 是无环连通图 $G$ 的割点，当且仅当满足以下条件：$V(G - v)$ 可以划分为两个非空子集 $V_1, V_2$，对于所有 $x \in V_1, y \in V_2$，顶点 $v$ 在每一条连接 $x$ 与 $y$​​ 的路上。</p></li></ol><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><p>没有割点的连通图称为块图，简称块。</p><p>满足如下性质的 $𝐺$ 的子图 $𝐵$ 称为 $𝐺$ 的块：</p><ul><li>它本身是块</li><li>没有真包含 $𝐵$ 的 $𝐺$ 的块存在</li></ul><h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li>若简单图 $𝐺$ 满足 $|𝑉(𝐺)| \geq 3$，则 $𝐺$​ 是块的充要条件为其中任意两顶点位于同一圈上。</li><li>$v$ 是 $𝐺$ 的割点当且仅当 $v$ 至少属于 $𝐺$ 的两个不同块。</li></ol><h2 id="点割集和边割集"><a href="#点割集和边割集" class="headerlink" title="点割集和边割集"></a>点割集和边割集</h2><h3 id="点割集"><a href="#点割集" class="headerlink" title="点割集"></a>点割集</h3><p>给定连通图 $G$，设 $V’ \subseteq V$，若 $G - V’$ 不连通，称 $V’$ 为 $G$ 的一个<strong>点割集</strong>：</p><ul><li>含有 $k$ 个顶点的点割集称为<strong>k顶点割</strong>。</li><li>点数最少的顶点割称为<strong>最小顶点割</strong>。</li></ul><p>若 $G$ 有顶点割，最小顶点割的顶点数称为 $G$ 的<strong>点连通度</strong>，否则称 $𝑛 − 1$ 为其点连通度。$G$ 的点连通度记为 $\kappa(G)$。</p><ul><li>若不连通，$\kappa(G) = 0$​​。</li><li>若 $\kappa(G) \geq k$，称 $G$ 是<strong>k连通的</strong>：</li></ul><h3 id="边割集"><a href="#边割集" class="headerlink" title="边割集"></a>边割集</h3><p>最小边割集所含边数称为图的<strong>边连通度</strong>，记为 $\lambda(G)$。</p><ul><li>若 $G$ 不连通，则定义 $\lambda(G) = 0$。</li><li>若 $\lambda(G) \geq k$，称 $G$ 是<strong>k边连通的</strong>。</li></ul><h3 id="定理-4"><a href="#定理-4" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li><p>Whitney定理：对任意图 $G$，有 $\kappa(G) \leq \lambda(G) \leq \delta(G)$。</p><blockquote><p>其中$\kappa(G)$是点连通度，$\lambda(G)$是边连通度，图的最小度数是$\delta(G)$​。</p></blockquote></li><li><p>对任意 $(n, m)$连通图$G$, 有  $\kappa(G) \leq\lfloor 2 m / n\rfloor$</p></li><li>设$G$是$(n, m)$单图, 若 $\delta(G) \geq\lfloor n / 2\rfloor$ , 则 $G$ 连通</li><li>设 $G$ 是 $(n, m)$ 单图，若对 $\forall k \in \mathbb{Z}$，有 $\delta(G) \geq \frac{(n+k-2)}{2}$，则 $G$ 是 $k$ 连通的</li><li>设 $G$ 是 $n$ 阶单图，若 $\delta(G) \geq \lfloor n / 2 \rfloor$，则有 $\lambda(G) = \delta(G)$。</li></ol><h2 id="分离集"><a href="#分离集" class="headerlink" title="分离集"></a>分离集</h2><p>设 $S$ 为 $G$ 的一个顶点子集或边子集，若 $u, v$ 不在 $G-S$ 的同一分支上，称 $S$ 分离 $u, v$。</p><h3 id="定理-5"><a href="#定理-5" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li><p>Menger定理：</p><ul><li><p>$G$ 中分离 $x, y$ 的最少点数等于独立的 $(x, y)$​ 路的最大数目。</p><blockquote><p>也可以表述为：一个非平凡图 $G$ 是 $k \geq 2$ 连通的，当且仅当 $G$ 的任意两个顶点 $u, v$ 间至少存在 $k$ 条内点不交的 $(u, v)$ 路。</p></blockquote></li><li><p>$G$ 中分离 $x, y$ 的最少边数等于边不重的 $(x, y)$​ 路的最大数目。</p><blockquote><p>也可以表述为：一个非平凡的图 $G$ 是 $k \geq 2$ 边连通的，当且仅当 $G$ 的任意两个顶点间至少存在 $k$ 条边不重的 $(u, v)$​ 路。</p><p><strong>推论</strong>：对于一个阶至少为 3 的无环图  G , 下面三个命题等价：</p><ul><li>G  是 2 连通的</li><li>G  中任意两点位于同一个圈上</li><li>G  无孤立点, 且任意两条边在同一个圈上</li></ul></blockquote></li></ul></li></ol><h2 id="最大流和最小割"><a href="#最大流和最小割" class="headerlink" title="最大流和最小割"></a>最大流和最小割</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="Flow-network定义"><a href="#Flow-network定义" class="headerlink" title="Flow network定义"></a>Flow network定义</h4><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240513102157714.png" alt="image-20240513102157714"></p><p>流网络的定义：</p><ol><li><p>有向图</p></li><li><p>边有容量属性</p></li><li><p>有source节点（源节点）s和sink（汇节点）节点t</p></li></ol><h4 id="割（Cut）"><a href="#割（Cut）" class="headerlink" title="割（Cut）"></a>割（Cut）</h4><p>一个割将结点划分为两部分：$S$和$T$，使得源节点$s$属于$S$，汇节点$t$属于$T$。</p><p>分割的容量（capacity）指的是从$S$（不是$s$）出发的边的权重之和。最小割问题就是找一个cut，使得分割的容量最小。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240513102654246.png" alt="image-20240513102654246"></p><h4 id="流（Flow）"><a href="#流（Flow）" class="headerlink" title="流（Flow）"></a>流（Flow）</h4><p>每条边都有一个流，每条边的流需要满足：</p><ul><li>不超过边的容量</li><li>除了$s$和$t$​，其他点流入需要等于流出。</li></ul><p>最大流问题就是找到一个流法，使得汇入$t$​的流最大。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240513103452310.png" alt="image-20240513103452310"></p><blockquote><p>可以类比为，$s$是一个水库，水流通过管道（边）流向不同的区域（顶点），最终到达汇点𝑡，比如一个污水处理厂。在这个过程中，水流流量不能超过管道的容量，并且每个交叉点的水量必须保持平衡，不能有水积聚或流失。</p></blockquote><h3 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h3><h4 id="基础定理"><a href="#基础定理" class="headerlink" title="基础定理"></a><mark>基础定理</mark></h4><ol><li>设 $f$ 为一个流，$(S, T)$ 为任意的 $s-t$ 割。那么，穿过这个割的净流量等于到达 $t$​ 的流量。</li><li>到达$t$​的流量最多是割的容量。（穿过割的净流量不一定等于割的容量）</li><li>设 $f$ 为一个流，$(S, T)$ 为一个 $s-t$ 割，其容量等于流 $f$ 的值。那么 $f$ 是一个最大流，$(S, T)$ 是一个最小割。</li></ol><h4 id="最大流最小割定理-1"><a href="#最大流最小割定理-1" class="headerlink" title="最大流最小割定理"></a><mark>最大流最小割定理</mark></h4><script type="math/tex; mode=display">在任意网络中，最大流的值=最小割的容量</script><p>参考：<a href="https://www.bilibili.com/video/BV1Q7411R7ie/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">[算法竞赛入门] 网络流基础：理解最大流/最小割定理 (蒋炎岩)</a></p><h5 id="寻找最大流——Ford-Fulkerson算法"><a href="#寻找最大流——Ford-Fulkerson算法" class="headerlink" title="寻找最大流——Ford-Fulkerson算法"></a>寻找最大流——Ford-Fulkerson算法</h5><p>参考：<a href="https://www.bilibili.com/video/BV1Pv41157xh/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">13-2: Ford-Fulkerson Algorithm 寻找网络最大流</a></p><p>步骤：</p><ol><li><strong>初始化</strong>：首先，需要将网络中所有边的流量初始化为0（或者根据问题的具体要求设置为其他初始值）。同时，需要保留一个残余网络，用于记录每条边的剩余容量，即还能增加的流量。</li><li><strong>寻找增广路径</strong>：在残余网络中寻找一条从源点到汇点的路径，这条路径上的所有边都有剩余容量大于0。这样的路径称为增广路径。如果存在这样的路径，则执行下一步；如果不存在，算法结束，当前网络流即为最大流。</li><li><strong>计算瓶颈容量</strong>：在增广路径上，找到所有边中剩余容量最小的那一个，这个剩余容量即为瓶颈容量。这个值决定了我们可以沿增广路径增加多少流量。</li><li><strong>增广流量</strong>：沿着增广路径，将每条边的流量增加瓶颈容量，同时需要减少残余网络中对应边的剩余容量（因为流量增加了，所以剩余容量相应减少）。对于增广路径上的每条边，还需要在残余网络中增加一条反向边，其容量等于增广路径上该边的增流量，用于表示流量的可逆性。</li><li><strong>重复</strong>：返回第二步，继续寻找新的增广路径，直到无法找到增广路径为止。</li></ol><p><mark>定理</mark>：一个流 $f$​ 是最大流，当且仅当不存在增广路径。</p><p>寻找最小割：<a href="https://www.bilibili.com/video/BV1T64y1R7ZK/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">13-5: 最小割 Min-Cut</a></p><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><p>在欧拉图中，可以通过图中的一条路径<strong>经过每条边恰好一次</strong>并返回起点。这条路径被称为欧拉回路（也称为欧拉环游或欧拉闭迹）。</p><h2 id="定理-6"><a href="#定理-6" class="headerlink" title="定理"></a><mark>定理</mark></h2><ol><li>下列陈述对于非平凡连通图 $𝐺$​ 是等价的：<ul><li>𝐺 是欧拉图</li><li>𝐺 的顶点度数为偶数</li><li>𝐺 的边集合能划分为圈</li></ul></li><li>连通图是欧拉图当且仅当<strong>每个点的度数是偶数</strong>。<ul><li>推论：连通非欧拉图存在欧拉迹当且仅当只有两个顶点度数为奇数</li></ul></li></ol><h2 id="求欧拉环游的算法"><a href="#求欧拉环游的算法" class="headerlink" title="求欧拉环游的算法"></a>求欧拉环游的算法</h2><h3 id="Fleury算法"><a href="#Fleury算法" class="headerlink" title="Fleury算法"></a>Fleury算法</h3><p>Fleury算法用于在欧拉图中求出一条具体欧拉环游。复杂度为$O(m^2)$。</p><p>算法流程如下：</p><ol><li>任意选择一个顶点 $v_{0}$，置 $w_{0}=v_{0}$。</li><li>假设迹 $w_{i}=v_{0} e_{1} v_{1} \cdots e_{i} v_{i}$ 已经选定，按下述方法从 $E-\left\{e_{1}, e_{2}, \cdots, e_{i}\right\}$ 中选取边 $e_{i+1}$：<ul><li>$e_{i+1}$ 与 $v_{i}$ 相关联。</li><li>除非没有别的边可选择，否则 $e_{i+1}$ 不能是 $G_{i}=G-\left\{e_{1}, e_{2}, \cdots, e_{i}\right\}$ 的割边。</li></ul></li><li>当以上操作不能执行时，算法停止。</li></ol><p>证明：</p><ul><li><a href="https://math.stackexchange.com/questions/2362546/on-the-proof-of-fleurys-algorithm">参考1</a></li><li><a href="https://zhuanlan.zhihu.com/p/665031541">参考2</a></li></ul><h3 id="Hierholzer算法"><a href="#Hierholzer算法" class="headerlink" title="Hierholzer算法"></a>Hierholzer算法</h3><p>Hierholzer算法是另一个寻找欧拉环游的算法，它采用深度优先搜索，不断找圈，最后合并为Euler环游。其的复杂度为$O(m)$，比Fleury算法的更小。</p><p>算法伪代码如下，其中<code>cpath</code>记录当前圈，<code>epath</code>记录总体路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cpath:</span><br><span class="line">    u = cpath.top()  <span class="comment"># Assuming cpath is a stack</span></span><br><span class="line">    <span class="keyword">if</span> all_edges_visited(u):</span><br><span class="line">      cpath.pop()</span><br><span class="line">        epath.append(u)  <span class="comment"># Assuming epath is a list to store the final path</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        u, x = select_random_edge(u)</span><br><span class="line">        cpath.append(x)</span><br><span class="line">        delete_edge(u, x)</span><br></pre></td></tr></table></figure><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240520104121132.png" alt="image-20240520104121132"></p><h2 id="中国邮路问题"><a href="#中国邮路问题" class="headerlink" title="中国邮路问题"></a>中国邮路问题</h2><p>中国邮路问题指的是：邮递员从邮局出发，每条街道至少行走一次，再回邮局。如何行走，其环游路程最短？</p><ul><li>如果邮路图本身是欧拉图，可以直接用 Fleury 算法。</li><li>重要的是，如果是非欧拉图，如何重复行走街道才能使行走总路程最短？</li></ul><h3 id="定理-7"><a href="#定理-7" class="headerlink" title="定理"></a><mark>定理</mark></h3><p>若 $W$ 是包含图 $G$ 每条边至少一次的闭途径，$W$ 具有最小权值当且仅当：</p><ul><li>$G$ 的每条边在$W$ 中最多重复一次</li></ul><ul><li>对 $G$ 的每个圈，在$W$ 中重复的边的总权值不超过非重复边总权值</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>若图 $G$ 只有两个奇度顶点 $u, v$，则最优邮递员路径算法如下：</p><ul><li><p>在 $u, v$ 间求出一条最短路 $P^*$ </p></li><li><p>在 $P^*$ 上，给每条边添加一条平行边得 $G$ 的欧拉母图 $G$ ∗</p></li><li><p>在 $G^*$ 中运行 Fleury 算法</p></li></ul><h1 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h1><p>如果经过图 $𝐺$ <strong>每个顶点一次</strong>后能够回到出发点，称这样的图为Hamilton 图，简称 $𝐻$ 图。所经过的闭途径是 $𝐺$ 的一个生成圈，称为 $𝐺$ 的 Hamilton 圈。如果存在经过 $𝐺$ 的每个顶点一次的路，称该路为 Hamilton 路，简称 $𝐻$​ 路。</p><p>判定H图是一个NP难问题。</p><h2 id="定理-8"><a href="#定理-8" class="headerlink" title="定理"></a><mark>定理</mark></h2><ol><li><p>$H$圈的必要条件：若 $G$ 为 $H$ 图, 则对 $V(G)$ 的任一非空顶点子集 $S$, 有 $w(G-S) \leq|S|$。</p><blockquote><p>可用来证明不是$H$圈。$w$指的是连通分支。</p></blockquote></li><li><p>Dirac定理：对于 $n \geq 3$​ 的单图 $G$​，如果 $\delta(G) \geq n / 2$​，则 $G$​ 是 $H$​​ 图。</p><blockquote><p>这个定理不是紧的</p></blockquote></li><li><p>Ore定理：若 $d(u) + d(v) \geq n$ 对任意不相邻 $u, v$ 成立，则 $G$ 是 $\mathrm{H}$ 图。</p><blockquote><p>这个定理是紧的</p></blockquote></li></ol><h2 id="闭包和H图"><a href="#闭包和H图" class="headerlink" title="闭包和H图"></a>闭包和H图</h2><h3 id="闭图"><a href="#闭图" class="headerlink" title="闭图"></a>闭图</h3><p>在 $n$ 阶单图中，若对 $d(u)+d(v) \geq n$ 的任意顶点 $u, v$，均有 $u, v$ 相邻，则称 $G$ 是闭图。</p><p><mark>定理</mark>：若 $G_{1}$ 和 $G_{2}$ 是同一个点集 $V$ 的两个闭图，则 $G = G_{1} \cap G_{2}$​ 也是闭图。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>包含 $G$ 的极小闭图称为 $G$ 的闭包，如果 $G$ 本身是闭图，其闭包是它本身。</p><p>如果 $G$ 不是闭图，则可以通过在度和大于等于 $n$ 的不相邻顶点对间加边来构造闭图</p><p><mark>定理</mark>：</p><ul><li>图 $𝐺$ 的闭包是唯一的</li><li>Bondy定理：图 $G$ 是 $H$ 图当且仅当它的闭包是 $H$ 图</li></ul><h2 id="度序列和H图"><a href="#度序列和H图" class="headerlink" title="度序列和H图"></a>度序列和H图</h2><p>设简单图 $G$ 的度序列是 $\left(d_{1}, d_{2}, \cdots, d_{n}\right), d_{1} \leq \cdots \leq d_{n}, n \geq 3$ 。若对任意 $m &lt; \frac{n}{2}$, $d_{m} &gt; m$ 或 $d_{n-m} \geq n-m$, $G$ 是 $\mathrm{H}$ 图。</p><h1 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h1><p>不同的TSP问题：</p><ul><li>一般TSP问题：给定一个城市集合和两两城市间的距离，找到最短的路径访问所有城市并回到出发城市。</li><li>Metric TSP问题：城市间距离满足三角不等式</li><li>Euclidean TSP：城市间的距离是欧拉距离</li></ul><p><mark>定理</mark>：对于所有$\rho &gt;1$，寻找一个$\rho-$最优的TSP旅行路线是NP难题。</p><h2 id="近似最优算法"><a href="#近似最优算法" class="headerlink" title="近似最优算法"></a>近似最优算法</h2><h3 id="基于最小生成树的算法"><a href="#基于最小生成树的算法" class="headerlink" title="基于最小生成树的算法"></a>基于最小生成树的算法</h3><ol><li>首先计算图的最小生成树</li><li>对最小生成树先序遍历</li><li>先序遍历序列就是TSP问题的一个近似解</li></ol><p>路径长度小于等于2倍的最优长度。</p><h3 id="基于最近邻的算法"><a href="#基于最近邻的算法" class="headerlink" title="基于最近邻的算法"></a>基于最近邻的算法</h3><ol><li>从任意顶点开始</li><li>如果已有顶点还未包含所有顶点：<ul><li>找到离已有顶点最近的顶点$v_a$，记其离的最近的顶点为$v_b$。</li><li>找到离开$v_b$的边，其到达$v_c$。</li><li>将$v_a$加入已有顶点，并替换$v_b\rightarrow v_c$为$v_b \rightarrow v_a$</li></ul></li></ol><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240526175300192.png" alt="image-20240526175300192"></p><p>路径长度小于等于2倍的最优长度。</p><h3 id="Christofides算法"><a href="#Christofides算法" class="headerlink" title="Christofides算法"></a>Christofides算法</h3><ol><li>找到一个最小生成树 T</li><li>找到T中奇度顶点的最小匹配 M，将 M 添加到 T</li><li>找到一个欧拉回路</li><li>简化回路</li></ol><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240526214244878.png" alt="image-20240526214244878"></p><p>路径长度小于等于1.5倍的最优长度。</p><h1 id="偶图的匹配"><a href="#偶图的匹配" class="headerlink" title="偶图的匹配"></a>偶图的匹配</h1><h2 id="图的匹配"><a href="#图的匹配" class="headerlink" title="图的匹配"></a>图的匹配</h2><h3 id="匹配的定义"><a href="#匹配的定义" class="headerlink" title="匹配的定义"></a>匹配的定义</h3><p><strong>定义</strong>：设 $M$ 是图 $G$ 的边子集（不含环），若 $M$ 中任意两条边没有共同顶点，则称 $M$ 是 $G$ 的一个匹配或对集或边独立集。</p><p>若 $v \in G$ 为 $M$ 中某条边的端点，称它为 $M$ 的饱和点；否则，称为 $M$ 的非饱和点。</p><p>如果 $𝑀$ 是图 $𝐺$ 包含边数最多的匹配，称 $M$ 是 $𝐺$ 的最大匹配。若最大匹配饱和了 $𝐺$​ 的所有顶点，称<strong>完美匹配</strong>。一个图不一定存在完美匹配，若存在，不一定唯一。一个图的最大匹配也不一定唯一。</p><h3 id="交错路与可扩路"><a href="#交错路与可扩路" class="headerlink" title="交错路与可扩路"></a>交错路与可扩路</h3><p>𝑀 是图 𝐺 的匹配，𝐺 中一条由 𝑀 中的边和非 𝑀 中的边交错形成的路，称为 𝑀 交错路。若路的起点与终点是 𝑀 非饱和点，称为 𝑀 可扩路。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init: { &#39;flowchart&#39;: { &#39;curve&#39;: &#39;basis&#39; } } }%%flowchart TDsubgraph XABCDendsubgraph YEFGHendA-.-FB---E &amp; FB-.-GC---GC-.-HD---F &amp; H  </pre></div><p>这里$A\rightarrow F \rightarrow B \rightarrow G \rightarrow C \rightarrow H$​是一条交错路。</p><h3 id="定理-9"><a href="#定理-9" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li>Berge定理（最大匹配充要条件）：$𝐺$ 的匹配 $𝑀$ 是最大匹配的充要条件是 $𝐺$ 不包含 $𝑀$ 可扩路。</li><li>Hall定理（偶图匹配存在性）：设  $G=(X, Y)$  是偶图,  $G$  存在饱和  $X$  每个顶点的匹配的充要条件是：$\forall S \subseteq X,|N(S)| \geq|S|$​​​。（$N(S)表示S的邻居$）<ul><li>推论：$k$​正则偶图存在完美匹配</li><li>推论：每个$k\geq 2$​方体都有完美匹配</li></ul></li><li>$K_{2n}$中完美匹配的个数为$(2n-1)(2n-3)\cdot \cdot \cdot 1$​</li><li>树至多存在一个完美匹配</li><li>Tutte定理：图 $𝐺$ 有完美匹配的充要条件为：对$𝑉$ 的任意非空真子集 $𝑆$，$𝐺$ − $𝑆$ 的奇分支个数 $𝑜 (𝐺 − 𝑆) ≤ |𝑆 |$。</li></ol><h2 id="图的点覆盖"><a href="#图的点覆盖" class="headerlink" title="图的点覆盖"></a>图的点覆盖</h2><p>对图 $𝐺$ 的顶点子集 $𝐾$，如果 $𝐺$ 的每条边都至少有一个点在 $𝐾$ 中，称 $𝐾$为 $𝐺$ 的一个点覆盖。顶点数最少的 $𝐾$ 称为最小点覆盖，|$𝐾$| 称为 $𝐺$ 的覆盖数。</p><p><mark>定理</mark>：</p><ol><li>设 $𝑀$ 是 $𝐺$ 的匹配，$𝐾$ 是 $𝐺$ 的覆盖，若 $|𝑀|$ = $|𝐾|$，则 $𝑀$ 是最大匹配，$𝐺$​ 是最小覆盖。</li><li>Konig定理：偶图中最大匹配的边数等于最小覆盖的顶点数。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法用于寻找完美匹配。参考视频：<a href="https://www.bilibili.com/video/BV1jT411R7vQ/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">图论 匈牙利算法求最大匹配</a></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设 $G$ 是具有二部划分 $\left(V_{1}, V_{2}\right)$ 的二部图。</p><ol><li>任给初始匹配 $M$（边集）。</li><li>若 $M$ 饱和 $V_{1}$ 则结束，否则转 3；</li><li>在 $V_{1}$ 中找一非 $M$ 饱和点 $x$，置 $S=\{x\}$，$T=\varnothing$；</li><li>若 $N(S)=T$，则停止，否则任选一点 $y \in N(S)-T$；</li><li>若 $y$ 为 $M$ 饱和点转 6，否则作求一条从 $x$ 到 $y$ 的 $M$ 可增广路 $P$，$M=M \Delta P$，转 2；</li><li>由于 $y$ 是 $M$ 饱和点，故 $M$ 中有一边 $\{(u, y)\}$，置 $S=S \cup\{u\}$，$T=T \cup\{y\}$，转 4。</li></ol><p>其中，$N(S)$ 表示集合 $S$ 中所有点的邻点集合，$M \Delta P$ 表示环和（也就是将路径 $P$ 中的边与匹配 $M$ 进行交换）。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>匈牙利算法的时间复杂度为$O(|V|*|E|)$，其中$|V|$是顶点数而$|E|$是边数。</p><h2 id="Kuhn-Munkres-算法"><a href="#Kuhn-Munkres-算法" class="headerlink" title="Kuhn-Munkres 算法"></a>Kuhn-Munkres 算法</h2><p>Kuhn-Munkres 算法用于寻找最优匹配。假设 $G=(X, Y)$  是边赋权完全偶图,  $X=\left\{x_{1}, \cdots, x_{n}\right\} ,  Y=\left\{y_{1}, \cdots, y_{n}\right\}, w_{i j}=w\left(x_{i} y_{j}\right)$​ 。那么求这个图的最优匹配，就是求一个具有最大权值的完美匹配</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="可行顶点标号"><a href="#可行顶点标号" class="headerlink" title="可行顶点标号"></a>可行顶点标号</h4><p>若对任意的$x\in X,y\in Y$, 有$l(x)+l(y)\ge w(xy)$，称$l$是$G$​的可行顶点标号。</p><p>对于任意$G$，均存在可行顶点标号：</p><script type="math/tex; mode=display">l(x)=\max_{y\in Y}w(xy)\\l(y)=0</script><h4 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h4><p>设  $l$  是  $G$  的可行顶点标号, 令  $E_{l}=\{x y \in E(G) \mid l(x)+l(y)=w(x y)\}$ , 称  $G$  的生成子图  $G_{l}=G\left[E_{l}\right]$  为  $G$  对应于  $l$  的相等子图。</p><p><mark>定理</mark>：设  $l$  是赋权完全偶图  $G$  的可行顶点标号，若相等子图  $G_{l}$  有完美匹配  $M^{<em>}$ ,则  $M^{</em>}$  是  $G$  的最优匹配。</p><h3 id="Kuhn-Munkres-算法-1"><a href="#Kuhn-Munkres-算法-1" class="headerlink" title="Kuhn-Munkres 算法"></a>Kuhn-Munkres 算法</h3><p>参考文章：<a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108704280">https://blog.csdn.net/lemonxiaoxiao/article/details/108704280</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1fT411977g/?share_source=copy_web&amp;vd_source=00fb209a30d8e075044dc2abea8890c7">图论 KM算法求最优匹配</a></p><p>算法步骤：</p><ol><li>基于任意可行标号 $l$, 求出相等子图 $G_{l}$, 任选 $G_{l}$ 一个匹配 $M$。</li><li>若 $M$ 是完美匹配，算法终止; 否则, 令 $x$ 是一个 $M$ 非饱和顶点, 置 $S=\{x\}, T=\emptyset$。</li><li>若 $T \subset N_{G_{l}}(S)$, 转第 3 步; 否则有 $N_{G_{l}}(S)=T$, 修改标号 $l$ 如下:</li></ol><script type="math/tex; mode=display">\alpha_{l}=\min \{l(x)+l(y)-w(xy) \mid x \in S, y \in Y-T\}</script><script type="math/tex; mode=display">l(v) \leftarrow\begin{cases}l(v)-\alpha & v \in S \\l(v)+\alpha & v \in T\end{cases}</script><ol><li>在 $N_{G_{l}}(S)-T$ 中选择一个顶点 $y$, 若 $y$ 是 $M$ 饱和的, 记 $yz \in M$, 更新 $S \leftarrow S \cup\{z\}, T \leftarrow T \cup\{y\}$, 转第 2 步; 否则, 寻找 $G_{l}$ 中的 $M$ 可扩 $(u, y)$ 路, 用其更新 $M$​, 转第 1 步。</li></ol><blockquote><p>另一种版本（我觉得更清晰）：</p><ol><li>从任何可行顶标（例如平凡顶标）$ l $ 开始，确定 $ \left(K_{n, n}, w\right) $ 的等子图 $ G_{l} $，并且在 $ G_{l} $ 中选取匹配 $ M $。若 $ M $ 饱和 $ V_{1} $，则 $ M $ 是完美匹配，也即 $ M $ 是最优匹配，算法终止。否则转入步骤 (2)。</li><li>基于匹配 $ M $，在 $ \left(K_{n, n}, w\right) $ 的 $ l $ 等子图 $ G_{l} $ 中执行匈牙利算法，该算法终止于 $ S \subset V_{1} $，$ T \subset V_{2} $ 且 $ N_{G_{l}}(S)=T $。利用公式 $ \alpha_{l}=\min \left\{l(x)+l(y)-\omega(x, y) \mid x \in S, y \in V_{2}-T\right\} $ 计算值 $ \alpha_{l} $，然后利用公式<script type="math/tex; mode=display"> l^{\prime}(u)=\left\{ \begin{array}{ll} l(u)-\alpha_{l}, & u \in S \\ l(u)+\alpha_{l}, & u \in T \\ l(u), & \text{其他} \end{array} \right.</script>确定新的可行顶标 $ l^{\prime} $，并以 $ l^{\prime} $ 替代 $ l $，以 $ G_{l^{\prime}} $ 替代 $ G_{l} $ 转入步骤 (1)。</li></ol></blockquote><p>注意：</p><ul><li>标号的调整不影响已有匹配</li><li>每次改变标号都会扩大$𝑇$，从而扩大匹配</li><li>完全图存在完美匹配</li><li>算法复杂度 $𝑂(𝑛^3 )$</li></ul><h2 id="任务分配匈牙利算法"><a href="#任务分配匈牙利算法" class="headerlink" title="任务分配匈牙利算法"></a>任务分配匈牙利算法</h2><p>问题：$𝑁$ 个人分配 $𝑁$ 项任务，每人分配一项，将一项任务分给一个人需支付报酬，如何分配任务，支付的报酬总数最少。也就是求最小权值的完美匹配。</p><p>算法步骤：</p><ol><li>减去行最小值</li><li>减去列最小值</li><li>用最少的线条覆盖所有零（如果将0视为人$i$和任务$j$间的连线，找最小的点覆盖数就是找最大匹配）<ul><li>如果需要 $n$ 条线，则停止，在零之间存在一个最优分配。</li></ul></li><li>创建额外的零<ul><li>找到步骤 3 中未被线条覆盖的最小元素（称其为 $k$）</li><li>从未覆盖的元素中减去 $k$，给被两次覆盖的元素加上 $k$。</li><li>转到步骤 3</li></ul></li></ol><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240609103157007.png" alt="image-20240609103157007"></p><h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p>如果能把图 $𝐺$ 画在平面上，<strong>使得除顶点外，边与边之间没有交叉</strong>，称 $𝐺$可以嵌入平面，或称 $𝐺$ 是可平面图。$𝐺$ 的边不交叉的一种画法，称为 $𝐺$ 的一种平面嵌入</p><p>平面上的自身不相交的封闭曲线称为 Jordan 曲线。</p><p><mark>定理</mark>：Jordan 曲线把平面分成内外 2 部分，连接两部分的任意曲线必然与Jordan 曲线相交。</p><h2 id="面"><a href="#面" class="headerlink" title="面"></a>面</h2><p>平面图 $𝐺$ 把平面分成若干连通片，称为 $𝐺$ 的区域，或面，其集合记为 $Φ$</p><ul><li>面积有限的面称为内部面，否则称为外部面</li></ul><ul><li>顶点和边都与某个面关联的子图，称为该面的边界</li></ul><ul><li><p>面 $𝑓$ 的边界中含有的边数称为 $𝑓$ 的次数，记为 $𝑑𝑒𝑔(𝑓 )$</p><ul><li>割边计算 2 次</li></ul></li></ul><h3 id="定理-10"><a href="#定理-10" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li><p>设$G=(n, m)$是平面图, $\sum_{f \in \Phi} \operatorname{deg}(f)=2 m$。</p></li><li><p>平面图欧拉公式：设 $𝐺 = (𝑛,𝑚)$​ 是有 $𝜙$​ 个面的连通平面图，$𝑛 − 𝑚 + 𝜙 = 2$​。</p><ul><li>推论：平面图 $𝐺$ 有 $𝑘$ 个连通分支，$𝑛 − 𝑚 + 𝜙 = 𝑘 + 1$</li><li>若连通平面图  $G$  每个面  $f$  满足  $\operatorname{deg}(f) \geq l \geq 3$ , 则  $m \leq \frac{l}{l-2}(n-2)$。隐含着$m\leq 3n-6$​。</li><li>对任意简单平面图，有 $ \delta \leq 5$</li></ul><blockquote><p>$m$是边的数量，$n$是顶点的数量，$l$是每个面最小次数，$𝜙$是面数</p></blockquote></li></ol><h2 id="图的嵌入性"><a href="#图的嵌入性" class="headerlink" title="图的嵌入性"></a>图的嵌入性</h2><p><mark>定理</mark>：</p><ol><li>$G $ 可球面嵌入当且仅当 $ G $​ 可平面嵌入。</li><li>所有图均可嵌入 $ \mathrm{R}^{3} $ 中。</li></ol><h3 id="平面图的判定"><a href="#平面图的判定" class="headerlink" title="平面图的判定"></a>平面图的判定</h3><p> <mark>定理</mark>：</p><ol><li>对简单图  $G$ , 若  $m&gt;3 n-6$ , 则  $G$  不是平面图。</li><li>对简单图  $G$ , 若  $m&gt;\frac{l(n-2)}{(l-2)}$ , 则  $G$​  不是平面图。</li><li>$K_5$和$K_{3,3}$​不是平面图</li><li>至少有 9 个顶点的简单平面图的补图不是平面图，9 为顶点数的下界</li></ol><h4 id="通过同胚判定"><a href="#通过同胚判定" class="headerlink" title="通过同胚判定"></a>通过同胚判定</h4><p>如  $G_{1}$  与  $G_{2}$  通过反复 2 度顶点内扩充和收缩后变成同构, 称它们同胚</p><ul><li>在图的边上插入一个 2 度顶点, 使一条边分成两条边, 称将图在 2 度顶点内扩充</li><li>去掉一个图的 2 度顶点, 使关联它们的两条边合并成一条边，称将图 G 在 2 度顶点内收缩</li></ul><p>图的平面性在同胚意义下不变。</p><p><mark>Kuratowski定理</mark>：$G$ 是平面图，当且仅当它不含 $ K_{5} $ 和 $ K_{3,3} $ 同胚的子图 </p><ul><li>推论：$G $ 是非平面图，当且仅当它含有与 $ K_{5} $ 和 $ K_{3,3} $​ 同胚的子图 </li></ul><h4 id="通过简单基础图判定"><a href="#通过简单基础图判定" class="headerlink" title="通过简单基础图判定"></a>通过简单基础图判定</h4><p>去掉 𝐺 中的环，用单边代替平行边而得到的图称为 𝐺 的基础简单图。</p><ul><li>图 $𝐺$ 是平面图，当且仅当它的基础简单图是平面图</li><li>图 $𝐺$​ 是平面图，当且仅当它的每个块是平面图</li></ul><h4 id="Wangner-判定定理"><a href="#Wangner-判定定理" class="headerlink" title="Wangner 判定定理"></a>Wangner 判定定理</h4><p>设 $𝑢𝑣$ 是简单图 $𝐺$ 的一条边，去掉该边，重合其端点，再删去由此产生的环和平行边，这一过程称为 $𝐺$ 的初等收缩或边收缩。</p><p><mark>Wanger定理</mark>：简单图 $ G $ 是平面图，当且仅当它不含可收缩到 $ K_{5} $ 或 $ K_{3,3} $ 的子图 。</p><h2 id="凸多面体与平面图"><a href="#凸多面体与平面图" class="headerlink" title="凸多面体与平面图"></a>凸多面体与平面图</h2><p>一个多面体，如果在体上任取两点，其连线均在体上，称为凸多面体。把凸多面体压缩在平面上，得到的平面图，称为该凸多面体的一维骨架。</p><p><mark>定理</mark>：存在且只存在5种正多面体（plato 立体）：正四、六、八、十二、二十面体。</p><h2 id="平面图的对偶图"><a href="#平面图的对偶图" class="headerlink" title="平面图的对偶图"></a>平面图的对偶图</h2><p>$ G $ 的对偶图  $G^{*}$  构造如下</p><ul><li>在  $G$  的每个面  $f_{i}$  内取一个点  $v_{i}^{<em>}$  作为  $G^{</em>}$  的一个顶点</li><li>对  $G$  的一条边  $e$ , 若  $e$  是面  $f_{i}$  与  $f_{j}$  的公共边, 连接  $v_{i}^{<em>}$  与  $v_{j}^{</em>}$ , 若  $e$  是面  $f_{i}$ 中的割边, 以  $v_{i}$  为顶点作环。</li></ul><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240609171339923.png" alt="image-20240609171339923"></p><p>对偶图性质：</p><ul><li>$G^{*}$  的顶点数等于  $G$  的面数</li><li>$G^{*}$  的边数等于  $G$  的边数</li><li>$G^{*}$  的面数等于  $G$  的顶点数</li><li>$d\left(v^{*}\right)=\operatorname{deg}(f)$​ </li><li>同构的平面图可以有不同构的对偶图</li></ul><p><mark>定理</mark>：</p><ol><li>平面图 $ G $ 的对偶图 $ G^{*} $ 连通 </li><li>对平面图 $ G,\left(G^{<em>}\right)^{</em>} \simeq(同构) G $ 当且仅当 $ G $ 连通。 </li></ol><h1 id="图的着色"><a href="#图的着色" class="headerlink" title="图的着色"></a>图的着色</h1><h2 id="边着色"><a href="#边着色" class="headerlink" title="边着色"></a>边着色</h2><p>对图 $G$ 的边进行染色，若相邻边染不同颜色，则称对 $G$ 进行正常边着色。</p><ul><li>如果能用 $k$ 种颜色对 $G$ 进行正常边着色，称 $G$ 是 $k$ 边可着色的。$k$ 的最小值，称为 $G$ 的边色数，记为 $\chi^{\prime}(G)$。</li><li>若点 $v$ 关联的边的着色没有用到色 $i$，则称 $v$ 缺 $i$ 色。着相同颜色的边集称为该着色的一个色组。</li></ul><p>对图的边着色，<strong>本质上是对边集合的一种划分</strong>，因此对应实际问题中的划分问题或分类问题。</p><h3 id="定理-11"><a href="#定理-11" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li><p>偶图$K_{n,m}$边色数：$\chi^{\prime}\left(K_{m, n}\right)=\Delta$​</p></li><li><p>一般偶图边色数：对偶图 $G$，$\chi^{\prime}(G) = \Delta$。</p></li><li><p>简单图边色数（Vizing定理）：对于简单图 $G$，其边色数 $\chi’(G)$ 为 $\Delta$ 或 $\Delta + 1$​。</p><blockquote><p>判断 $ \chi^{\prime}(G)=\Delta $ 还是 $ \chi^{\prime}(G)=\Delta+1 $ 一般情况下是困难的 </p></blockquote><ul><li>引理：在简单图 $G$ 中，假设 $x$ 与 $y_1$ 是不相邻的两个顶点，$\pi$ 是 $G$ 的一个正常 $k$ 边着色。如果在着色 $\pi$ 下，顶点 $x$、$y_1$ 以及所有与 $x$ 相邻的点都至少缺少一种颜色，那么图 $G + xy_1$ 是 $k$​ 边可着色的。</li><li>推论：若简单图 $ G $ 中只有一个最大度点或恰有两个相邻的最大度点, 则 $ \chi^{\prime}(G)=\Delta$​</li><li>推论：对$n=2k+1$阶简单图G<ul><li>若 $m &gt; k\Delta$，则 $\chi^{\prime}(G) = \Delta + 1$。</li><li>若 $G$ 是正则图，则 $\chi^{\prime}(G) = \Delta + 1$。</li></ul></li></ul></li></ol><h2 id="点着色"><a href="#点着色" class="headerlink" title="点着色"></a>点着色</h2><p>对图 $G$ 的顶点进行染色，若相邻点染不同颜色，则称对 $G$ 进行正常点着色。</p><ul><li>如果能用 $k$ 种颜色对 $G$ 进行正常点着色，称 $G$ 是 $k$ 点可着色的。</li><li>$k$ 的最小值，称为 $G$ 的点色数，记为 $\chi(G)$。</li><li>着相同颜色的点集称为该着色的一个色组</li></ul><p>对图的点着色，本质上是对点集合的一种划分，因此对应实际问题中的划分问题或分类问题。</p><h3 id="定理-12"><a href="#定理-12" class="headerlink" title="定理"></a><mark>定理</mark></h3><ol><li>对于任意图 $G$，有 $\chi(G) \leq \Delta + 1$​​。</li><li>Brooks定理：连通简单图 $G$，如果它既不是奇圈，又不是完全图，那么满足不等式 $\chi(G) \leq \Delta$​。</li><li><p>Brooks定理改进：对于简单图 $G$，则有 $\chi(G) \leq \Delta_{2}(G) + 1$；若 $G$ 中最大度点互不邻接，则 $\chi(G) \leq \Delta(G)$。</p><ul><li>记$N(u)$ 是顶点 $u$ 的邻居顶点集合。若记 $V_{2}(G)=\{v \mid \exists u \in N(v): d(u) \geq d(v)\}$，则次大度 $\Delta_{2}(G)=\max \left\{d(v) \mid v \in V_{2}(G)\right\}$​​。</li></ul></li><li><p>五色定理：每个平面图都是5可着色的。</p></li><li>k着色，即给定一个图，问是否可以k着色，是NP难问题。</li></ol><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>对一般图的点染色是一个NP难问题。</p><p>$Δ(𝐺) + 1$ 的点着色算法：将顶点任意排序为  $v_{1}, \cdots, v_{n}$ , 将颜色任意排序依次染  $v_{i}$ , 每次用可能的最小颜色染  $v_{i}$ 。</p><blockquote><p>不能保证得到最佳染色方案。</p></blockquote><p><em>Welsh—Powell</em> 改进：按顶点度数由大到小的次序着色，即先处理瓶颈结点。</p><h1 id="随机图"><a href="#随机图" class="headerlink" title="随机图"></a>随机图</h1><p>给定 $N$ 与 $p$，对任意一对顶点，<strong>以概率 $p$ 连边</strong>，产生随机图记为 $G_{np}$。</p><p>边数：$\bar{M} = p \cdot\binom{N}{2} = \frac{p N(N-1)}{2}$</p><p>平均度数：$\bar{k}=2 \bar{M} / N=(N-1) p$​</p><p>单个顶点度为$k$的概率：当 $k \ll N$ 时，$P(k)$ 近似于 Poisson 分布。</p><p><mark>定理</mark>：记 $N_G$ 为 $G_{Np}$ 最大连通分支的顶点个数</p><ul><li>当 $\bar{k} = Np &lt; 1$ 时，$N_G = O(\ln N)$；</li><li>当 $\bar{k} = 1$ 时，$N_G = O\left(N^{2/3}\right)$；</li><li>当 $1 &lt; \bar{k} &lt; \ln N$ 时，巨连通分支存在；</li><li>当 $\bar{k} &gt; \ln N$ 时，$N_G = N$，即 $G$ 是连通图。</li></ul><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><p>有向图是由顶点集 $V$ 和有向边集 $E$ 组成的。</p><ul><li>有向路径是一个顶点列表 $\{v_i\}$，满足 $v_i v_{i+1} ∈ E$。如果存在从 $s$ 到 $t$ 的有向路径，则称 $t$ 是从 $s$ 可达的。</li><li><p>有向无环图（DAG）是一个没有有向环的有向图。</p></li><li><p>只有出边的顶点称为源点。</p></li><li><p>只有入边的顶点称为汇点。</p></li><li><p>如果对于所有的 $u, v ∈ V$，$u$ 都是从 $v$ 可达的，则称有向图是强连通的。</p></li><li><p>强连通分量是一个最大的强连通子图。</p></li></ul><h2 id="核有向无环"><a href="#核有向无环" class="headerlink" title="核有向无环"></a>核有向无环</h2><p>假设给定一个有向图$𝐷$，定义另一个有向图$𝐾(𝐷)$。</p><ul><li>在 $K(D)$ 中，每个顶点映射到 $D$ 的一个强连通分量。</li><li>如果 $D$ 中存在从对应于 $u$ 的分量到 $v$ 的边，则 $uv ∈ E(K(D))$。</li><li>$K(D)$ 被称为 $D$ 的核有向无环图（kernel DAG）。</li></ul><h2 id="寻找强连通分量"><a href="#寻找强连通分量" class="headerlink" title="寻找强连通分量"></a>寻找强连通分量</h2><p>Kosaraju算法：</p><ul><li>在图 $G$ 上运行深度优先搜索（DFS），并记录每个顶点的完成时间（每探索一个点时间+1）。</li><li>将图 $G$ 中所有边的方向反转。</li><li>从完成时间最大的节点开始在反转后的图上运行DFS，每当遇到死胡同时，就添加一个新的SCC。</li></ul><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240623104551279.png" alt="image-20240623104551279"></p><h2 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h2><p>传递闭包是一个有向图，它具有与 $D$ 相同的顶点集，但只在 $t$ 从 $s$ 可达时，从 $s$ 到 $t$ 有一条边。</p><h3 id="计算传递闭包"><a href="#计算传递闭包" class="headerlink" title="计算传递闭包"></a>计算传递闭包</h3><p>方法一：计算邻接矩阵的布尔乘法$A^n$</p><ul><li>使用逻辑与（AND）作为乘法（$\times$），逻辑或（OR）作为加法（+）。 -</li><li>复杂度：$O(n^4)$ </li></ul><p>改进方法：计算直到 $A^i$ 收敛。</p><p>进一步改进：计算 $A, A^2, A^4, \cdots$：复杂度：$O(n^3 \log n)$</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>给定一个有向无环图 $G$，找到一个总排序，使得对于所有的 $uv \in E(G)$，在排序中 $u$ 都在 $v$ 之前。</p><p>算法：</p><ol><li>识别一个源点 $s$<ul><li>如果没有源点：停止（存在循环）</li></ul></li><li>删除 $s$ 及其相关边，将 $s$ 加入队列<ul><li>如果图不为空：回到步骤 1</li></ul></li></ol><p>复杂度：$O(n + m)$。</p><h3 id="应用：调度"><a href="#应用：调度" class="headerlink" title="应用：调度"></a>应用：调度</h3><ul><li>任务 $v$ 需要时间 $\text{time}[v]$ 来执行</li><li>存在优先级约束</li><li>问题：每个任务最早何时能完成？</li></ul><p>算法：</p><ol><li>计算顶点的拓扑顺序</li><li>初始化 $\text{fin}[v] = 0$ 对于所有 $v$</li><li>按拓扑顺序考虑 $v$：对于每条边 $v \rightarrow w$，设置 $\text{fin}[w] = \max(\text{fin}[w], \text{fin}[v] + \text{time}[w])$</li></ol><h1 id="点覆盖"><a href="#点覆盖" class="headerlink" title="点覆盖"></a>点覆盖</h1><p>给定无向图 $G$，找到一个最小顶点集 $V_0 \subseteq V$，使得如果 $(u, v) \in E(G)$，那么 $u \in V_0$ 或 $v \in V_0$。即通过选择顶点来覆盖边。是NP难问题。</p><p>APPROX-VERTEX-COVER 是一个多项式时间的 2-近似算法。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/图/image-20240623112452218.png" alt="image-20240623112452218"></p><p>存在一个最优顶点覆盖，它不包括任何叶子 - 用其父节点替换覆盖中的任何叶子*</p><h3 id="树上的点覆盖"><a href="#树上的点覆盖" class="headerlink" title="树上的点覆盖"></a>树上的点覆盖</h3><p>存在一个最优顶点覆盖，它不包括任何叶子节点：用其父节点替换覆盖中的任何叶子节点。</p><p>用以下算法可以得到最优解：</p><ol><li><strong>初始化集合 C 为空</strong>：这是算法的起始步骤，创建一个空集合 C，用于存储算法的结果。</li><li><strong>循环执行</strong>：这一部分是算法的核心，包含以下步骤：<ul><li><strong>条件判断</strong>：检查图 G 中是否至少存在一个叶子节点。如果不存在，则跳出循环。</li><li><strong>添加父节点</strong>：在每次迭代中，将图 G 中所有叶子节点的父节点添加到集合 C 中。</li><li><strong>删除节点</strong>：从图 G 中删除所有的叶子节点及其父节点。</li></ul></li><li><strong>返回集合 C</strong>：当循环结束后，算法返回集合 C 作为最终结果。</li></ol><h4 id="更优算法"><a href="#更优算法" class="headerlink" title="更优算法"></a>更优算法</h4><p><mark>定理</mark>：考虑一个图 $G$ 和它的边 $uv$。令 $G_u$ 为通过删除顶点 $u$ 及其关联边得到的图。图 $G$ 有一个大小为 $k$ 的顶点覆盖，当且仅当 $G_u$ 或 $G_v$ 有一个大小为 $k-1$ 的顶点覆盖。</p><p>算法：</p><ol><li>如果 $E=\emptyset$，则返回 $\emptyset$；</li><li>如果 $k=0$ 且 $E\neq\emptyset$，则返回 $\perp$；</li><li>从 $E$ 中选择任意一条边 $(u,v)\in E$；</li><li>$S1=VERTEX-COVER-SEARCH(Gu,k-1)$；</li><li>$S2=VERTEX-COVER-SEARCH(Gv,k-1)$；</li><li>如果 $S1\neq\perp$，则返回 $S1\cup\{u\}$；</li><li>如果 $S2\neq\perp$，则返回 $S2\cup\{v\}$；</li><li>返回 $\perp$。</li></ol><h4 id="带权树的点覆盖"><a href="#带权树的点覆盖" class="headerlink" title="带权树的点覆盖"></a>带权树的点覆盖</h4><p><strong>给定：</strong> 一个无向的、顶点加权的图 $G$。</p><p><strong>目标：</strong> 找到一个权重最小的顶点子集 $V_0 \subseteq V$，使得如果边 $(u, v) \in E(G)$，那么 $u \in V_0$ 或 $v \in V_0$。</p><p>算法：</p><ol><li><p>求以下问题的解</p><script type="math/tex; mode=display">\text{最小化 } \sum_{v} w(v) \cdot x(v)</script><p>约束：</p><script type="math/tex; mode=display">\begin{aligned}&x(u)+x(v)  \geq 1 & & \text { for each }(u, v) \in E \\&x(v)  \in[0,1] & & \text { for each } v \in V\end{aligned}</script></li><li><p>在图中执行以下算法：</p><ol><li>C = ∅</li><li>根据刚才计算出来的一个最优解 $\bar{x}$</li><li>对于每个顶点 $v$ 属于 $V$，如果 $\bar{x}(v) \geq \frac{1}{2}$，$C = C \cup \{v\}$</li><li>返回 $C$</li></ol></li></ol><p>RAND-VC是一个期望中2-近似的多项式时间算法</p>]]></content>
      
      
      <categories>
          
          <category> 我重生了，重生在考试前一天 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信号与系统</title>
      <link href="/post/1580825926.html"/>
      <url>/post/1580825926.html</url>
      
        <content type="html"><![CDATA[<h1 id="复数基础"><a href="#复数基础" class="headerlink" title="复数基础"></a>复数基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="复数表示形式"><a href="#复数表示形式" class="headerlink" title="复数表示形式"></a>复数表示形式</h3><p>复数的标准形式为$a+bi$</p><h4 id="指数表示"><a href="#指数表示" class="headerlink" title="指数表示"></a>指数表示</h4><p>复数可以用指数形式表示，形式为：</p><script type="math/tex; mode=display">z = re^{i\theta}</script><h4 id="三角形式"><a href="#三角形式" class="headerlink" title="三角形式"></a>三角形式</h4><p>复数的三角形式是：</p><script type="math/tex; mode=display">z = r(\cos \theta + i\sin \theta)</script><h3 id="辅角和模"><a href="#辅角和模" class="headerlink" title="辅角和模"></a>辅角和模</h3><p>$r$ 是复数的模（实数），$\theta$ 是复数的辐角（主值通常在 $[-\pi, \pi]$ 或 $[0, 2\pi]$ 范围内）</p><p>复数的模定义为：</p><script type="math/tex; mode=display">r = |z| = \sqrt{a^2 + b^2}</script><h3 id="相位"><a href="#相位" class="headerlink" title="相位"></a>相位</h3><p>若$z=a+bi$，相位的定义为$arctan(\frac b a)$。</p><h3 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h3><p>复数的共轭定义为：</p><script type="math/tex; mode=display">z^* = a - bi</script><p>其中，$z = a + bi$ 是复数的标准形式。<br>共轭运算具有以下性质：</p><ul><li><p>$z \cdot z^* = |z|^2$</p></li><li><p>$(z_1 \cdot z_2)^<em> = z_1^</em> \cdot z_2^*$</p></li><li><p>$(z^<em>)^</em> = z$</p></li><li><p>$z+z^*=2Re\{z\}$  (Real)</p></li><li><p>$z-z^*=2Im\{z\}i$​​  (Imaginary)</p><blockquote><p>这里$Im\{z\}$是不包含$i$的</p></blockquote></li></ul><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2><script type="math/tex; mode=display">e^{ix} = \cos(x) + i\sin(x)</script><h2 id="计算技巧"><a href="#计算技巧" class="headerlink" title="计算技巧"></a>计算技巧</h2><p>若$z=\frac{z_1}{z_2}$，则$|z|=\frac{|z_1|}{|z_2|}$​，$arg(z)=arg(z_1)-arg(z_2)$。$arg$的意思是辅角。</p><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><h2 id="什么是信号？"><a href="#什么是信号？" class="headerlink" title="什么是信号？"></a>什么是信号？</h2><p><strong>信号是信息的载体</strong>，它携带着有关某些现象、过程或数据的情报。信号可以是自然界中的物理现象，也可以是电子设备产生的电信号。<strong>信号可以是随时间变化的，也可以是随空间变化的。</strong>在信号处理中，通常关注的是随时间变化的信号。</p><p>信号的分类：连续时间信号，离散时间信号，确知信号，随机信号。</p><h2 id="什么是系统？"><a href="#什么是系统？" class="headerlink" title="什么是系统？"></a>什么是系统？</h2><p><strong>系统是接收输入信号，根据某种规则或操作进行处理，并产生输出信号的实体</strong>。在信号处理中，系统可以是物理设备，如放大器、滤波器，也可以是数学模型或算法，如傅里叶变换、数字信号处理器（DSP）中的程序。</p><p>系统的分类：线性系统、非线性系统、时不变系统、时变系统</p><h2 id="信号与系统中的信号能量与功率公式描述"><a href="#信号与系统中的信号能量与功率公式描述" class="headerlink" title="信号与系统中的信号能量与功率公式描述"></a>信号与系统中的信号能量与功率公式描述</h2><p>在信号与系统中，信号的能量和功率是描述信号特性的两个重要参数。它们分别反映了信号的整体强度和平均强度。</p><h3 id="无限区间上的信号能量"><a href="#无限区间上的信号能量" class="headerlink" title="无限区间上的信号能量"></a>无限区间上的信号能量</h3><p>信号能量是指在整个信号持续时间内信号所做的功。对于连续信号，能量可以通过信号在整个时间轴上的积分来计算；对于离散信号，则通过求和来计算。</p><ul><li><p><strong>连续信号</strong>的能量公式：</p><script type="math/tex; mode=display">E = \int_{-\infty}^{\infty} |x(t)|^2 dt</script><p>其中 $x(t)$ 是连续时间信号，而 $E$ 是信号的总能量。</p></li><li><p><strong>离散信号</strong>的能量公式：</p><script type="math/tex; mode=display">E = \sum_{n=-\infty}^{\infty} |x[n]|^2</script><p>其中 $x[n]$ 是离散时间信号，$E$ 是信号的总能量。</p></li></ul><p>能量信号的能量是有限的，且其平均功率为零。</p><h3 id="无限区间上的信号功率"><a href="#无限区间上的信号功率" class="headerlink" title="无限区间上的信号功率"></a>无限区间上的信号功率</h3><p>信号功率是指信号在单位时间内做功的平均值。与能量不同，功率是一个时间平均的概念，适用于能量无限的信号，即功率信号。</p><ul><li><p><strong>连续信号</strong>的功率公式：</p><script type="math/tex; mode=display">P = \lim_{T \to \infty} \frac{1}{2T} \int_{-T}^{T} |x(t)|^2 dt</script><p>其中 $P$ 是信号的平均功率。</p></li><li><p><strong>离散信号</strong>的功率公式：</p><script type="math/tex; mode=display">P = \lim_{N \to \infty} \frac{1}{2N+1} \sum_{n=-N}^{N} |x[n]|^2</script><p>其中 $P$ 是信号的平均功率。</p></li></ul><h3 id="信号处理中的信号分类"><a href="#信号处理中的信号分类" class="headerlink" title="信号处理中的信号分类"></a>信号处理中的信号分类</h3><p>在信号处理领域，根据信号能量和功率的特性，信号可以分为以下三类：</p><ol><li>能量信号是指其能量是有限的，而功率无限的信号</li><li>功率信号是指其功率是有限的，而能量无限的信号。</li><li>能量和功率都是无限的信号。</li></ol><h2 id="信号与系统中的自变量变换"><a href="#信号与系统中的自变量变换" class="headerlink" title="信号与系统中的自变量变换"></a>信号与系统中的自变量变换</h2><h3 id="时移"><a href="#时移" class="headerlink" title="时移"></a>时移</h3><p>位置变换，也称为时间平移，是指将信号在时间轴上左移或右移。如果信号 $ x(t) $ 经过位置变换 $ \tau $ 后，新的信号为 $ x(t - \tau) $。</p><ul><li>当 $ \tau &gt; 0 $ 时，信号向右平移。</li><li>当 $ \tau &lt; 0 $ 时，信号向左平移。<h3 id="时间反转"><a href="#时间反转" class="headerlink" title="时间反转"></a>时间反转</h3>设原始信号为 $ x(t) $，经过镜像变换后得到的新信号为 $ y(t) $。镜像变换的数学表达式可以表示为：<script type="math/tex; mode=display">y(t) = x(-t)</script>即，新信号 $ y(t) $ 是原始信号 $ x(t) $​ 在时间轴上的镜像。</li></ul><h3 id="尺度变换"><a href="#尺度变换" class="headerlink" title="尺度变换"></a>尺度变换</h3><p>尺度变换，也称为时间缩放，是指改变信号的时间尺度。如果信号 $ x(t) $ 经过尺度变换 $ \alpha $ 后，新的信号为 $ x(\alpha t) $。</p><ul><li>当 $ \alpha &gt; 1 $ 时，信号被“压缩”，时间轴上的事件变得“快”。</li><li>当 $ 0 &lt; \alpha &lt; 1 $ 时，信号被“拉伸”，时间轴上的事件变得“慢”。</li></ul><h3 id="奇信号和偶信号"><a href="#奇信号和偶信号" class="headerlink" title="奇信号和偶信号"></a>奇信号和偶信号</h3><p>奇信号：一个奇信号满足条件：$ x(-t) = -x(t) $。奇信号在时间轴上关于原点对称。</p><p>偶信号：一个偶信号满足条件：$ x(-t) = x(t) $。偶信号在时间轴上关于y轴对称</p><h4 id="信号的分解"><a href="#信号的分解" class="headerlink" title="信号的分解"></a>信号的分解</h4><p>任何一个信号都可以唯一地分解为一个奇信号和一个偶信号的和。设原始信号为 $ x(t) $，它可以分解为：</p><ul><li>偶部分：$ x_{\text{even}}(t) = \frac{x(t) + x(-t)}{2} $</li><li>奇部分：$ x_{\text{odd}}(t) = \frac{x(t) - x(-t)}{2} $<br>这样，原始信号 $ x(t) $ 可以表示为偶部分和奇部分的和：</li></ul><script type="math/tex; mode=display">x(t) = x_{\text{even}}(t) + x_{\text{odd}}(t)</script><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>本课程主要研究复指信号与正弦信号</p><h2 id="连续时间复指数信号与正弦信号"><a href="#连续时间复指数信号与正弦信号" class="headerlink" title="连续时间复指数信号与正弦信号"></a>连续时间复指数信号与正弦信号</h2><h3 id="复指信号"><a href="#复指信号" class="headerlink" title="复指信号"></a>复指信号</h3><script type="math/tex; mode=display">x(t)=C \mathrm{e}^{a t}</script><h4 id="实指数信号"><a href="#实指数信号" class="headerlink" title="实指数信号"></a>实指数信号</h4><p>当$C$和$a$都是实数的时候，$x(t)$​​称为实指数信号。</p><h4 id="周期复指数信号"><a href="#周期复指数信号" class="headerlink" title="周期复指数信号"></a>周期复指数信号</h4><p>$a$​为纯虚数的时候该复指数信号为周期复指数信号。</p><script type="math/tex; mode=display">x(t)=\mathrm{e}^{\mathrm{j} \omega_{0} t}</script><p>基波周期 $T_{0}=\frac{2 \pi}{\left|\omega_{0}\right|}$​</p><h4 id="一般复指数信号"><a href="#一般复指数信号" class="headerlink" title="一般复指数信号"></a>一般复指数信号</h4><script type="math/tex; mode=display">\begin{array}{l}C=|C| \mathrm{e}^{\mathrm{j} \theta}\\a=r+\mathrm{j} \omega_{0}\end{array}</script><h3 id="正弦信号"><a href="#正弦信号" class="headerlink" title="正弦信号"></a>正弦信号</h3><script type="math/tex; mode=display">x(t)=A \cos \left(\omega_{0} t+\phi\right)</script><h3 id="转换关系"><a href="#转换关系" class="headerlink" title="转换关系"></a>转换关系</h3><p>复指信号可以通过欧拉公式转换为正弦信号。欧拉公式为：</p><script type="math/tex; mode=display">    e^{j\theta} = \cos\theta + j\sin\theta</script><p>因此，<strong>复指信号可以写为：</strong></p><script type="math/tex; mode=display">    x(t) = A (\cos(2\pi ft + \phi) + j\sin(2\pi ft + \phi))</script><p><strong>要将 $ \cos(\omega t) $ 和 $ \sin(\omega t) $ 转换为 $ e^{j\omega t} $ 的形式，我们可以使用欧拉公式（Euler’s formula）：</strong></p><script type="math/tex; mode=display">\cos(\omega t) = \frac{1}{2}(e^{j\omega t} + e^{-j\omega t})</script><script type="math/tex; mode=display">\sin(\omega t) = \frac{1}{2j}(e^{j\omega t} - e^{-j\omega t})</script><h3 id="谐波关系"><a href="#谐波关系" class="headerlink" title="谐波关系"></a>谐波关系</h3><script type="math/tex; mode=display">\left\{\varphi_{k}(t)\right\}=\left\{\mathrm{e}^{\mathrm{j} k \omega_{0} t}\right\}, \quad k=0, \pm 1, \pm 2 \cdots \cdots</script><p>该集合中的每个信号都是周期的，它们的频率分别为  $k \omega_{0}$  ，都是  $\omega_{0}$​  的整数倍，因而称它们是成谐波关系的。各次谐波的周期分别为  $T_{k}=2 \pi /\left|k \omega_{0}\right|$ , 它们的公共周期是  $T_{0}=2 \pi /\left|\omega_{0}\right|_{\text {。 }}$ </p><h2 id="离散时间复指数信号与正弦信号"><a href="#离散时间复指数信号与正弦信号" class="headerlink" title="离散时间复指数信号与正弦信号"></a>离散时间复指数信号与正弦信号</h2><p>离散时间正弦信号的一般形式为：</p><script type="math/tex; mode=display">x[n]=A \cos \left(\omega_{0} n+\phi\right)</script><p>离散时间复指数信号：</p><script type="math/tex; mode=display">x[n] = C \alpha^{n}=|C||\alpha|^{n} \cos \left(\omega_{0} n+\theta\right)+\mathrm{j}|C \| \alpha|^{n} \sin \left(\omega_{0} n+\theta\right)</script><p>离散时间复指数序列 $ x[n] = e^{j\omega_0 n} $ 是周期性的，当且仅当 $ \omega_0 $ 是 $ 2\pi $ 的有理数倍，即 $ \omega_0 = \frac{2\pi k}{N} $​</p><h3 id="谐波关系-1"><a href="#谐波关系-1" class="headerlink" title="谐波关系"></a>谐波关系</h3><script type="math/tex; mode=display">\phi_{k}[n]=\mathrm{e}^{\mathrm{j} k(2 \pi / N) n}, \quad k=0, \pm 1, \cdots</script><p>谐波信号公共周期为$N$，基波频率为$2\pi/N$</p><p>与连续时间下的谐波信号不同的是，在这组信号中，仅有N个互不相同的周期复指数信号。</p><script type="math/tex; mode=display">\begin{aligned}\phi_{k+N}[n] & =\mathrm{e}^{\mathrm{j}(k+N)(2 \pi / N) n} \\& =\mathrm{e}^{\mathrm{j} k(2 \pi / N) n} \mathrm{e}^{\mathrm{j} 2 \pi n}=\phi_{k}[n]\end{aligned}</script><h2 id="信号比较-e-j-omega-0-t-与-e-j-omega-0-n"><a href="#信号比较-e-j-omega-0-t-与-e-j-omega-0-n" class="headerlink" title="信号比较: $e^{j\omega_0 t}$ 与 $e^{j\omega_0 n}$"></a>信号比较: $e^{j\omega_0 t}$ 与 $e^{j\omega_0 n}$</h2><div class="table-container"><table><thead><tr><th>特征</th><th>$e^{j\omega_0 t}$</th><th>$e^{j\omega_0 n}$</th></tr></thead><tbody><tr><td>频率差异</td><td>$\omega_0$ 不同，信号不同</td><td>==频差 $2\pi$ 的整数倍时，信号相同==</td></tr><tr><td>周期性</td><td>对任何 $\omega_0$ 信号都是周期的</td><td>==仅当 $\frac{2\pi}{\omega_0}=\frac{N}{m}$ 时，信号是周期的==</td></tr><tr><td>基波频率</td><td>基波频率 $\omega_0$</td><td>基波频率 $\omega_0 / m$</td></tr><tr><td>基波周期</td><td>$T_0=\frac{2\pi}{\omega_0}$</td><td>基波周期 $N=m \cdot \frac{2\pi}{\omega_0}$</td></tr></tbody></table></div><h2 id="离散时间单位脉冲与单位阶跃序列"><a href="#离散时间单位脉冲与单位阶跃序列" class="headerlink" title="离散时间单位脉冲与单位阶跃序列"></a>离散时间单位脉冲与单位阶跃序列</h2><p>单位脉冲序列，通常表示为 $ \delta[n] $。它是一个离散信号，仅在 $ n = 0 $ 时为1，其余时刻均为0。数学上可以表示为：</p><script type="math/tex; mode=display">\delta[n] =\begin{cases}1, & \text{if } n = 0 \\0, & \text{otherwise}\end{cases}</script><p>单位阶跃序列，通常表示为 $ u[n] $，是一个离散信号，当 $ n \geq 0 $ 时为1，当 $ n &lt; 0 $ 时为0。数学上可以表示为：</p><script type="math/tex; mode=display">u[n] =\begin{cases}1, & \text{if } n \geq 0 \\0, & \text{if } n < 0\end{cases}</script><p>两个函数之间的关系：</p><script type="math/tex; mode=display">\begin{array}{l}\delta[n]=u[n]-u[n-1]\\u[n]=\sum_{m=-\infty}^{n} \delta[m]\end{array}</script><p>离散时间单位脉冲是离散时间单位阶跃的一次差分，离散时间阶跃是单位样本的求和函数。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>单位脉冲序列可以用于一个信号在n=0时的值的采样。</p><script type="math/tex; mode=display">x[n] \delta[n]=x[0] \delta[n]</script><p>更一般的：</p><script type="math/tex; mode=display">x[n] \delta\left[n-n_{0}\right]=x\left[n_{0}\right] \delta\left[n-n_{0}\right]</script><h2 id="连续时间单位阶跃与单位冲激函数"><a href="#连续时间单位阶跃与单位冲激函数" class="headerlink" title="连续时间单位阶跃与单位冲激函数"></a>连续时间单位阶跃与单位冲激函数</h2><p>单位阶跃函数，通常表示为 $ u(t) $，是一个在 $ t = 0 $ 时从0瞬间跳变到1的函数。</p><script type="math/tex; mode=display">u(t) =\begin{cases}0, & \text{if } t < 0 \\1, & \text{if } t \geq 0\end{cases}</script><p>单位冲激函数，通常表示为 $ \delta(t) $，是一个理想化的函数，它在 $ t = 0 $ 时无限大，而在其他时间点为零，且其总面积为1。单位冲激函数是通过对单位阶跃函数求导得到的。</p><blockquote><p>单位冲激函数应该看成一种理想化的东西。任何真实的物理系统都会有惯性存在,因此不可能对输入做出瞬时的响应。因此,如果一个足够窄的脉冲加到这样的系统上, 该系统的响应就不会受脉冲持续期或脉冲的形状细节而有明显的影响,于是,所关注的脉冲的主要特性就是该脉冲的一种总的综合效果,也就是它的面积。</p></blockquote><script type="math/tex; mode=display">\delta(t)=\frac{\mathrm{d} u(t)}{\mathrm{d} t}</script><p>单位阶跃函数是单位冲激函数的积分</p><script type="math/tex; mode=display">u(t)=\int_{-\infty}^{t} \delta(\tau) \mathrm{d} \tau</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><script type="math/tex; mode=display">x(t) \delta(t) = x(0) \delta(t)</script><p>这意味着在t=0时刻，$x(t)$与$\delta(t)$的乘积等于$x(0)$与$\delta(t)$的乘积。</p><p>类似地，当连续时间信号$x(t)$与时间平移的冲激函数$\delta(t-t_0)$相乘时，结果为：</p><script type="math/tex; mode=display">x(t) \delta(t-t_0) = x(t_0) \delta(t-t_0)</script><p>当对$x(t)$与$\delta(t)$的乘积在整个时间轴上积分时，我们得到：</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty} \delta(t) x(t) \mathrm{d} t = x(0) \int_{-\infty}^{\infty} \delta(t) \mathrm{d} t = x(0)</script><p>这说明冲激函数在整个时间轴上的积分等于1，因此积分的结果就是信号在t=0时的值。换句话说，我们可以在t=0时提取信号的样本值。</p><p>同样，对$x(t)$与$\delta(t-t_0)$​的乘积在整个时间轴上积分时，结果是：</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty} \delta(t-t_0) x(t) \mathrm{d} t = x(t_0)</script><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="不同的联结方式"><a href="#不同的联结方式" class="headerlink" title="不同的联结方式"></a>不同的联结方式</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240304170341897.png" alt="image-20240304170341897"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240304170359782.png" alt="image-20240304170359782"></p><h2 id="系统的六个性质"><a href="#系统的六个性质" class="headerlink" title="系统的六个性质"></a>系统的六个性质</h2><p>系统具有以下六个主要性质：</p><ol><li><strong>因果性（Causality）</strong>：<ul><li><strong>因果性是指系统的输出仅依赖于当前时刻及过去的输入信号，而与未来的输入信号无关</strong>。一个因果系统不可能在输入信号到达之前产生输出。<ul><li>所有的无记忆系统都是因果的,因为输出仅仅对当前的输入值做出响应。</li></ul></li></ul></li><li><strong><mark>线性</mark>（Linearity）</strong>：<ul><li><strong>系统的线性包括叠加性和齐次性</strong>。<script type="math/tex; mode=display">\begin{aligned}a x_{1}(t)+b x_{2}(t) & \rightarrow a y_{1}(t)+b y_{2}(t) \\a x_{1}[n]+b x_{2}[n] & \rightarrow a y_{1}[n]+b y_{2}[n]\end{aligned}</script></li></ul></li></ol><ol><li><strong><mark>时不变性</mark>（Time-Invariance）</strong>：<ul><li><strong>时不变性是指系统的特性不随时间改变</strong>。如果一个输入信号经过系统后产生了一定的输出，那么将这个输入信号沿时间轴平移，输出信号也会做相同的平移。</li><li>以下是以连续时间系统为例，检验系统时不变性的步骤：<ol><li>令输入为 $x_1(t)$ ，根据系统描述确定对应输出 $y_1(t)$；</li><li>将输入变为 $x_2(t)$，再根据系统描述确定输出 $y_2(t)$；</li><li>令 $x_2(t) = x_1(t - t_0)$，根据自变量变换，检验 $y_2(t)$ 是否等于 $y_1(t - t_0)$。</li></ol></li></ul></li><li><strong>稳定性（Stability）</strong>：<ul><li><strong>系统的稳定性是指当输入信号有界时，输出信号也必须是有界的</strong>。一个稳定的系统不会因为输入信号的变化而产生无限大的输出。</li></ul></li><li><strong>记忆性（Memory）</strong>：<ul><li><strong>系统的记忆性指的是系统的输出不仅取决于当前时刻的输入，还可能取决于过去的输入值</strong>。无记忆系统（即时系统）的输出<strong><mark>仅与当前输入有关</mark></strong>，而记忆系统（动态系统）的输出则与过去和现在的输入都有关。</li></ul></li><li><strong>可逆性（Reversibility）或不可逆性（Irreversibility）</strong>：<ul><li><strong>可逆性是指如果一个系统在给定的输入下产生特定的输出，那么从输出可以唯一地确定输入。</strong>不可逆性则意味着不同的输入可能导致相同的输出，因此不能从输出反推出唯一的输入。</li></ul></li></ol><h1 id="卷积和卷积积分"><a href="#卷积和卷积积分" class="headerlink" title="卷积和卷积积分"></a>卷积和卷积积分</h1><h2 id="卷积和"><a href="#卷积和" class="headerlink" title="卷积和"></a>卷积和</h2><p>任意一个序列表示成一串移位的单位脉冲序列$\delta[n-k]$​的线性组合</p><script type="math/tex; mode=display">x[n]=\sum_{k=-\infty}^{+\infty} x[k] \delta[n-k]</script><p>在线性时不变系统中，$x[n]$的响应$y[n]$就可以表示为两个离散信号 $ x[n] $ 和 $ h[n] $ 的卷积和：</p><script type="math/tex; mode=display">y[n] = \sum_{k=-\infty}^{\infty} x[k] \cdot h[n-k]</script><p>卷积步骤：</p><ol><li><strong>翻转</strong>：将 $ h[n] $ 翻转，得到 $ h[-k] $。</li><li><strong>移位</strong>：将翻转后的 $ h[-k] $ 向右移位 $ n $个单位，得到 $ h[n-k] $。</li><li><strong>相乘</strong>：将 $ x[k] $ 与 $ h[n-k] $ 相乘。</li><li><strong>求和</strong>：对所有可能的 $ k $​ 值进行求和。</li></ol><p>性质：</p><script type="math/tex; mode=display">x[n]=x[n] * \delta[n]\\x\left[n-n_{0}\right]=x[n] * \delta\left[n-n_{0}\right]</script><h2 id="卷积积分"><a href="#卷积积分" class="headerlink" title="卷积积分"></a>卷积积分</h2><p>连续时间冲激函数也有筛选性质</p><script type="math/tex; mode=display">x(t)=\int_{-\infty}^{+\infty} x(\tau) \delta(t-\tau) \mathrm{d} \tau</script><p>在线性时不变系统中，$x[n]$的响应$y[n]$就可以由连续时间信号 $ x(t) $ 和 $ h(t) $ 的卷积积分表示：</p><script type="math/tex; mode=display">y(t) = \int_{-\infty}^{\infty} x(\tau) \cdot h(t-\tau) \, d\tau</script><p>卷积步骤：</p><ol><li><strong>翻转</strong>：将 $ h(t) $ 翻转，得到 $ h(-\tau) $。</li><li><strong>移位</strong>：将翻转后的 $ h(-\tau) $ 沿时间轴向右移动 $t$，得到 $ h(t-\tau) $。</li><li><strong>相乘</strong>：将 $ x(\tau) $ 与 $ h(t-\tau) $ 相乘。</li><li><strong>积分</strong>：对 $ \tau $ 从 $ -\infty $ 到 $ \infty $​ 进行积分。</li></ol><p>性质：</p><script type="math/tex; mode=display">x(t)=x(t) * \delta(t)\\x\left(t-t_{0}\right)=x(t) * \delta\left(t-t_{0}\right)</script><h2 id="线性时不变系统的性质"><a href="#线性时不变系统的性质" class="headerlink" title="线性时不变系统的性质"></a>线性时不变系统的性质</h2><p><mark>一个线性时不变系统的特性可以完全由它的冲激响应来决定</mark>。要特别强调的是,一般来说这个结论仅对线性时不变系统成立。下面还有几个卷积运算的最基本和最重要的性质。</p><h2 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h2><script type="math/tex; mode=display">\begin{array}{l}x[n] * h[n]=h[n] * x[n]=\sum_{k=-\infty}^{+\infty} h[k] x[n-k]\\x(t) * h(t)=h(t) * x(t)=\int_{-\infty}^{+\infty} h(\tau) x(t-\tau) \mathrm{d} \tau\end{array}</script><p>一个输入为 $x[n]$ 且单位冲激响应为 $h[n]$ 的线性时不变系统（LTI系统）的输出，与输入为 $h[n]$ 且单位冲激响应为 $x[n]$ 的输出，是完全一样的。</p><h2 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h2><script type="math/tex; mode=display">\begin{array}{l}x[n] *\left(h_{1}[n]+h_{2}[n]\right)=x[n] * h_{1}[n]+x[n] * h_{2}[n]\\x(t) *\left[h_{1}(t)+h_{2}(t)\right]=x(t) * h_{1}(t)+x(t) * h_{2}(t)\end{array}</script><p>由于卷积运算的分配律,线性时不变系统的并联可以用一个单一的线性时不变系统来代替,而该系统的单位冲激响应就是并联时各个单位冲激响应的和。同时，线性时不变系统对两个输人和的响应一定等于系统对单个输入响应的和</p><h2 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h2><script type="math/tex; mode=display">\begin{array}{l}x[n] *\left(h_{1}[n] * h_{2}[n]\right)=\left(x[n] * h_{1}[n]\right) * h_{2}[n]\\x(t) *\left[h_{1}(t) * h_{2}(t)\right]=\left[x(t) * h_{1}(t)\right] * h_{2}(t)\end{array}</script><p>只要关注的是整个系统的冲激响应, 它们的级联次序就是无关紧要的。</p><p>值得特别强调的是,线性时不变系统级联的特性,其总系统响应与系统级联次序无关这一点对这样一类系统是很特别的。相比之下,<strong>一般来说非线性系统的级联,要想不改变总的响应,其级联次序就不能改变</strong>。</p><h2 id="有记忆和无记忆线性时不变系统"><a href="#有记忆和无记忆线性时不变系统" class="headerlink" title="有记忆和无记忆线性时不变系统"></a>有记忆和无记忆线性时不变系统</h2><p>对一个离散时间线性时不变系统来说,系统无记忆性的条件是:</p><script type="math/tex; mode=display">h[n]=K \delta[n]</script><p>对于连续时间线性时不变系统来说，条件是：</p><script type="math/tex; mode=display">h(t)=K \delta(t)</script><h2 id="线性时不变系统的可逆性"><a href="#线性时不变系统的可逆性" class="headerlink" title="线性时不变系统的可逆性"></a>线性时不变系统的可逆性</h2><p>离散线性时不变系统，具有可逆性需要满足</p><script type="math/tex; mode=display">h(t) * h_{1}(t)=\delta(t)</script><p>连续线性时不变系统，具有可逆性需要满足</p><script type="math/tex; mode=display">h[n] * h_{1}[n]=\delta[n]</script><h2 id="线性时不变系统的因果性"><a href="#线性时不变系统的因果性" class="headerlink" title="线性时不变系统的因果性"></a>线性时不变系统的因果性</h2><p>离散线性时不变系统，具有因果性需要满足</p><script type="math/tex; mode=display">h[n]=0, \quad n<0</script><p>连续线性时不变系统，具有因果性需要满足</p><script type="math/tex; mode=display">h(t)=0, \quad t<0</script><h2 id="线性时不变系统的稳定性"><a href="#线性时不变系统的稳定性" class="headerlink" title="线性时不变系统的稳定性"></a>线性时不变系统的稳定性</h2><p>离散：</p><script type="math/tex; mode=display">\sum_{k=-\infty}^{+\infty}|h[k]|<\infty</script><p>连续：</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}|h(\tau)| \mathrm{d} \tau<\infty</script><h1 id="用微分和差分方程描述的因果线性时不变系统"><a href="#用微分和差分方程描述的因果线性时不变系统" class="headerlink" title="用微分和差分方程描述的因果线性时不变系统"></a>用微分和差分方程描述的因果线性时不变系统</h1><h2 id="线性常系数微分方程"><a href="#线性常系数微分方程" class="headerlink" title="线性常系数微分方程"></a>线性常系数微分方程</h2><p>考虑一个一阶微分方程</p><script type="math/tex; mode=display">\frac{\mathrm{d} y(t)}{\mathrm{d} t}+2 y(t)=x(t)</script><p>关于诸如这样的微分方程,很重要的一点是:<strong>它们所给出的是该系统的一种隐含的特性</strong>，一般来说,为了求解一个微分方程,必须给定一个或多个附加条件。</p><p>$y(t)$​一般都是由一个特解和一个齐次解(即输入置于零时该微分方程的解)所组成。该齐次解往往称为系统的自然响应，特解称为受迫响应。</p><p><strong>如果附加条件是初始松弛条件，该式所描述的系统就是线性时不变的,而且是因果的</strong></p><blockquote><p>初始松弛条件：$\text { 若 } t&lt;t_{0} \text { 时 } x(t)=0 \text {, 那么 } t&lt;t_{0} \text { 时 } y(t)=0$​。所以就可以得到$y(t_0)=0$</p></blockquote><p>一个N阶线性常系数微分方程由如下方程给出：</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} \frac{\mathrm{d}^{k} y(t)}{\mathrm{d} t^{k}}=\sum_{k=0}^{M} b_{k} \frac{\mathrm{d}^{k} x(t)}{\mathrm{d} t^{k}}</script><p>$y(t)$的解也分成自然响应和受迫响应两部分，其中自然响应为下面齐次方程的解</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} \frac{\mathrm{d}^{k} y(t)}{\mathrm{d} t^{k}}=0</script><h2 id="线性常系数差分方程"><a href="#线性常系数差分方程" class="headerlink" title="线性常系数差分方程"></a>线性常系数差分方程</h2><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} y[n-k]=\sum_{k=0}^{M} b_{k} x[n-k]</script><p>在初始松弛条件下, 由该式描述的系统就是线性时不变的,并且是因果的。$y(t)$也是由一个特解和一个齐次解组成。</p><p><strong>但对于离散时间的情况还有另一种方式求解</strong></p><p>上式可以被写成递归方程的形式：</p><script type="math/tex; mode=display">y[n]=\frac{1}{a_{0}}\left\{\sum_{k=0}^{M} b_{k} x[n-k]-\sum_{k=1}^{N} a_{k} y[n-k]\right\}</script><ul><li>$N=0$的时候$y[n]$是以前的输入值和当前输入值的显函数。其称为非递归方程。</li><li>如果式的$N≥1$,该差分方程就是递归的,相应于这个方程的线性时不变系统再与初始松弛条件结合在一起,一定有无限长的单位脉冲响应。这类系统通常就称为无限脉冲响应系统。</li></ul><h2 id="方框图"><a href="#方框图" class="headerlink" title="方框图"></a>方框图</h2><p>由线性常系数差分和微分方程描述的系统的一个重要的特点是:能以很简单而且很自然的方式用若干基本运算的方框图互联来表示。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240321145938793.png" alt="image-20240321145938793"></p><h1 id="奇异函数"><a href="#奇异函数" class="headerlink" title="奇异函数"></a>奇异函数</h1><p>虽然,通常一个函数或者信号总是用它在自变量每一点的值来定义的,<strong>但是单位冲激主要考虑的不是在每个$t$​值时它怎么样,而是在卷积的意义下它有何作为</strong>。</p><p>冲激函数的定义有两种：</p><ol><li>$x(t)=x(t) * \delta(t)$​</li><li>$ g(0)=\int_{-\infty}^{+\infty} g(\tau) \delta(\tau) \mathrm{d} \tau$</li></ol><h2 id="单位冲激偶和其他奇异函数"><a href="#单位冲激偶和其他奇异函数" class="headerlink" title="单位冲激偶和其他奇异函数"></a>单位冲激偶和其他奇异函数</h2><h3 id="单位冲激偶"><a href="#单位冲激偶" class="headerlink" title="单位冲激偶"></a>单位冲激偶</h3><p>单位冲激是一类称为奇异函数的信号中的一种,其中每一种信号都是借助于它在卷积运算中的特性来定义的。</p><p>单位冲激偶是这个系统的单位冲激响应,记为$u_1(t)$。其是单位冲激函数的导数</p><script type="math/tex; mode=display">y(t)=\frac{\mathrm{d} x(t)}{\mathrm{d} t}</script><p>$k$次导数就可以表示为</p><script type="math/tex; mode=display">u_{k}(t)=\underbrace{u_{1}(t) * \cdots * u_{1}(t)}_{k \text { 次 }}</script><p>性质：</p><ul><li>$\int_{-\infty}^{+\infty} u_{1}(\tau) \mathrm{d} \tau=0$</li><li>$-g^{\prime}(0)=\int_{-\infty}^{+\infty} g(\tau) u_{1}(\tau) \mathrm{d} \tau$</li></ul><h3 id="单位斜坡函数"><a href="#单位斜坡函数" class="headerlink" title="单位斜坡函数"></a>单位斜坡函数</h3><p>单位斜坡函数表示如下：</p><script type="math/tex; mode=display">u_{-2}(t)=t u(t)</script><p>和$x(t)$做卷积就相当于对$x(t)$积分两次。</p><p>高阶积分的定义如下：</p><script type="math/tex; mode=display">u_{-k}(t)=\underbrace{u(t) * \cdots * u(t)}_{k \text { 次 }}=\int_{-\infty}^{t} u_{-(k-1)}(\tau) \mathrm{d} \tau</script><p>可以得到：</p><script type="math/tex; mode=display">u_{-k}(t)=\frac{t^{k-1}}{(k-1) !} u(t)</script><p>不像$\delta(t)$的各阶导数那样,单位冲激的连续多次积分仍是在每个$t$值都有定义的函数</p><h3 id="delta-t-和-u-t-的另一种表示"><a href="#delta-t-和-u-t-的另一种表示" class="headerlink" title="$\delta(t)$和$u(t)$的另一种表示"></a>$\delta(t)$和$u(t)$的另一种表示</h3><script type="math/tex; mode=display">\begin{array}{l}\delta(t)=u_{0}(t) \\u(t)=u_{-1}(t)\end{array}</script><h1 id="周期信号的傅里叶级数表示"><a href="#周期信号的傅里叶级数表示" class="headerlink" title="周期信号的傅里叶级数表示"></a>周期信号的傅里叶级数表示</h1><p>周期信号的傅里叶级数表示是用复指数作基本信号的线性组合表示信号。</p><blockquote><p>这些基本信号应该有两个性质：</p><ol><li>由这些基本信号能够构成相当广泛的一类有用信号</li><li>线性时不变系统对每一个基本信号的响应应该十分简单,以使系统对任意输入信号的响应有一个很方便的表示式</li></ol></blockquote><p>一个线性时不变系统对复指数信号的响应也是一个复指数信号。</p><script type="math/tex; mode=display">\begin{array}{l}\mathrm{e}^{s t} \longrightarrow H(s) \mathrm{e}^{s t} \\z^{n} \longrightarrow H(z) z^{n}\end{array}</script><p>$H(s)/H(z)$称为特征值，$e^{st}/z^n$​称为特征函数</p><p>其中：</p><script type="math/tex; mode=display">H(s)=\int_{-\infty}^{+\infty} h(\tau) \mathrm{e}^{-s \tau} \mathrm{d} \tau</script><script type="math/tex; mode=display">H(z)=\sum_{k=-\infty}^{+\infty} h[k] z^{-k}</script><p>如果一个线性时不变系统的输入能够表示成复指数的线性组合,那么系统的输出也能够表示成相同复指数信号的线性组合。</p><p>对连续时间：</p><script type="math/tex; mode=display">x(t)=\sum_{k} a_{k} \mathrm{e}^{s_{k} t}</script><p>那么输出就是</p><script type="math/tex; mode=display">y(t)=\sum_{k} a_{k} H\left(s_{k}\right) \mathrm{e}^{s_{k} t}</script><p>对离散时间：</p><script type="math/tex; mode=display">\begin{array}{l}x[n]=\sum_{k} a_{k} z_{k}^{n}\\y[n]=\sum_{k} a_{k} H\left(z_{k}\right) z_{k}^{n}\end{array}</script><h2 id="连续时间周期信号的傅里叶级数表示"><a href="#连续时间周期信号的傅里叶级数表示" class="headerlink" title="连续时间周期信号的傅里叶级数表示"></a>连续时间周期信号的傅里叶级数表示</h2><p>一个周期信号表示成下式（也称为综合公式）的形式,就称为傅里叶级数表示。</p><script type="math/tex; mode=display">x(t)=\sum_{k=-\infty}^{+\infty} a_{k} \mathrm{e}^{\mathrm{j} k \omega_{0} t}=\sum_{k=-\infty}^{+\infty} a_{k} \mathrm{e}^{\mathrm{j} k(2 \pi / T) t}</script><p>其中的系数通过下式（也称为分析公式）确定：</p><script type="math/tex; mode=display">a_{k}=\frac{1}{T} \int_{T} x(t) \mathrm{e}^{-\mathrm{j} k \omega_{0} t} \mathrm{~d} t</script><blockquote><p>$\vec a_n$（成分）代表是$\vec x(t)$在$\vec e^{jnw_0t}$上的投影。</p></blockquote><p>特别当$k=0$时，$a_0$就是$x(t)$​在一个周期内的平均值</p><script type="math/tex; mode=display">a_{0}=\frac{1}{T} \int_{T} x(t) \mathrm{d} t</script><h3 id="傅里叶级数的收敛"><a href="#傅里叶级数的收敛" class="headerlink" title="傅里叶级数的收敛"></a>傅里叶级数的收敛</h3><p>有两类周期信号可以由傅里叶级数表示：(充分条件)</p><ol><li><p>在一个周期内能量有限的信号。</p><script type="math/tex; mode=display">\int_{T}|x(t)|^{2} \mathrm{~d} t<\infty</script></li><li><p>满足狄利赫利条件的信号。这组条件除了在某些对$x(t)$不连续的孤立的$t$值外,保证$x(t)$等于它的傅里叶级数表示;而在那些$x(t)$不连续的点上, 的无穷级数收敛于不连续点两边值的平均值。</p><ol><li><p>在任何周期内，$x(t)$绝对可积</p><script type="math/tex; mode=display">\int_{T}|x(t)| \mathrm{d} t<\infty</script></li><li><p>在任意有限区间内，$x(t)$​具有有限个起伏变化（最大值和最小值数目有限）</p></li><li><p>在$x(t)$​的任何有限区间内，只有有限个不连续点，而且在这些不连续点上，函数是有限值。</p></li></ol></li></ol><p>收敛于傅里叶级数的意思是，原来信号和它的傅里叶级数表示之间没有任何能量上的差别。因此,两者从所有实际目的来看可以认为是一样的。因为只是在孤立点上有差异，所以在卷积的意义下，两者的特性是一样的<strong>从线性时不变系统分析的角度来看,两个信号完全是一致的</strong>。</p><h4 id="吉伯斯现象"><a href="#吉伯斯现象" class="headerlink" title="吉伯斯现象"></a>吉伯斯现象</h4><p>不连续信号$x(t)$​，在接近不连续点处将呈现高频起伏和超量。</p><h2 id="连续时间傅里叶级数性质"><a href="#连续时间傅里叶级数性质" class="headerlink" title="连续时间傅里叶级数性质"></a>连续时间傅里叶级数性质</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240323123202816.png" alt="image-20240323123202816"></p><blockquote><ol><li>若$x(t)$为偶函数，其傅里叶级数系数也为偶；如果$x(t)$是奇函数，则其傅里叶系数也为奇</li></ol></blockquote><h2 id="离散时间周期信号的傅里叶级数表示"><a href="#离散时间周期信号的傅里叶级数表示" class="headerlink" title="离散时间周期信号的傅里叶级数表示"></a>离散时间周期信号的傅里叶级数表示</h2><p><strong>一个离散时间周期信号的傅里叶级数是有限项级数</strong>,而在连续时间周期信号情况下是一个无穷级数。其结果就是在离散时间情况下不存在数学上的收敛问题。</p><p>分析公式和频谱系数分别如下：</p><script type="math/tex; mode=display">\begin{aligned}x[n] & =\sum_{k=\langle N\rangle} a_{k} \mathrm{e}^{j k \omega_{0} n}=\sum_{k=\langle N\rangle} a_{k} \mathrm{e}^{j k(2 \pi / N) n} \\a_{k} & =\frac{1}{N} \sum_{n=\langle N\rangle} x[n] \mathrm{e}^{-\mathrm{j} k \omega_{0} n}=\frac{1}{N} \sum_{n=\langle N\rangle} x[n] \mathrm{e}^{-\mathrm{j} k(2 \pi / N) n}\end{aligned}</script><p>其中傅里叶级数系数与连续时间的不同之处在于$a_k$的值以$N$为周期</p><script type="math/tex; mode=display">a_{k}=a_{k+N}</script><p>有时把$a_k$也看成定义在全部$k$值上的一个序列,而在傅里叶级数表示式中仅仅利用其中某$N$​个连续序列值。</p><p>与连续时间情况相比,这里不存在任何收敛问题,也没有吉伯斯现象。任何离散时间周期序列$x[n]$完全是由有限个参数(即$N$个)来表征的,这就是在一个周期内的$N$​个序列值。</p><h2 id="离散傅里叶级数性质"><a href="#离散傅里叶级数性质" class="headerlink" title="离散傅里叶级数性质"></a>离散傅里叶级数性质</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240324110345003.png" alt="image-20240324110345003"></p><p>与连续时间情况相比有重要差别的几个性质：</p><h3 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h3><script type="math/tex; mode=display">x[n] y[n] \stackrel{\mathcal{F S}}{\longleftrightarrow} d_{k}=\sum_{l=\langle N\rangle} a_{l} b_{k-l}</script><p>除了求和变量现在要限制在N个连续的样本区间以外,上式就类似于卷积的定义。这种类型的运算称为两个周期的傅里叶系数序列之间的周期卷积,而求和变量从$-\infty$到$\infty$的这种卷积和的形式有时就称为非周期卷积,以区别于周期卷积。</p><h3 id="一次差分"><a href="#一次差分" class="headerlink" title="一次差分"></a>一次差分</h3><script type="math/tex; mode=display">x[n]-x[n-1] \stackrel{\mathcal{F S}}{\longleftrightarrow}\left(1-\mathrm{e}^{-\mathrm{j} k(2 \pi / N)}\right) a_{k}</script><p>在求一次差分的傅里叶级数系数比求原序列的傅里叶系数更容易时,常常使用这个性质。</p><h3 id="离散时间周期的帕斯瓦尔定理"><a href="#离散时间周期的帕斯瓦尔定理" class="headerlink" title="离散时间周期的帕斯瓦尔定理"></a>离散时间周期的帕斯瓦尔定理</h3><script type="math/tex; mode=display">\frac{1}{N} \sum_{n=\langle N\rangle}|x[n]|^{2}=\sum_{k=\langle N\rangle}\left|a_{k}\right|^{2}</script><p>帕斯瓦尔定理再一次表明: 一个周期信号的平均功率等于它的所有谐波分量的平均功率之和。上式右边的求和可以在任何k的N个相继值上进行。</p><h2 id="傅里叶级数与线性时不变系统"><a href="#傅里叶级数与线性时不变系统" class="headerlink" title="傅里叶级数与线性时不变系统"></a>傅里叶级数与线性时不变系统</h2><p>复指数信号的线性组合的响应具有特别简单的形式。</p><p>具体而言, 在连续时间情况下, 若  $x(t)=\mathrm{e}^{s t}$  是一个连续时间线性时不变系统的输入， 那么其输出就为  $y(t)=H(s) \mathrm{e}^{s t}$ 。$H(s)=\int_{-\infty}^{+\infty} h(\tau) \mathrm{e}^{-s \tau} \mathrm{d} \tau$</p><p>在离散时间情况下， 若  $x[n]=z^{n}$  是一个离散时间线性时不变系统的输入，那么其输出就为  $y[n]=   H(z) z^{n}$, $H(z)=\sum_{k=-\infty}^{+\infty} h[k] z^{-k}$。</p><p>当$s$或$z$是一般复数时,$H(s)$和$H(z)$就称为该系统的系统函数。但当$Re\{s\}=0(s=jw)$的时候，$H(jw)$就称为该系统的频率响应；当$|z|=1(z=e^{jw})$的时候，$H(e^{jw})$​被称为该系统的频率响应。</p><p>==注意：任何离散时间频率响应$H(e^{jw})$都是周期的，周期为$2\pi$==</p><p>连续时间的情况下，在$x(t)$​为周期信号的时候，其傅里叶表示为：</p><script type="math/tex; mode=display">x(t)=\sum_{k=-\infty}^{+\infty} a_{k} \mathrm{e}^{j k \omega_{0} t}</script><p>输出为：</p><script type="math/tex; mode=display">y(t)=\sum_{k=-\infty}^{+\infty} a_{k} H\left(\mathrm{j} k \omega_{0}\right) \mathrm{e}^{j k \omega_{0} t}</script><p>离散时间情况下，在$x[n]$为一个周期信号，其傅里叶表示为</p><script type="math/tex; mode=display">x[n]=\sum_{k=\langle N\rangle} a_{k} \mathrm{e}^{\mathrm{j} k(2 \pi / N) n}</script><p>输出为：</p><script type="math/tex; mode=display">y[n]=\sum_{k=\langle N\rangle} a_{k} H\left(\mathrm{e}^{\mathrm{j} 2 \pi k / N}\right) \mathrm{e}^{\mathrm{j} k(2 \pi / N) n}</script><p>应该注意,对于上面两个输出这样的表示式,若使其有意义,<strong>频率响应 $H(jw)$和 $H(e^{jw})$​就必须是有明确定义,而且是有限的。</strong></p><h2 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h2><p>改变一个信号中各频率分量的相对大小,或者全部消除某些频率分量之类的要求,常常是颇受关注的,这样一种过程称为滤波(filter)。</p><ul><li><p>用于改变频谱形状的线性时不变系统往往称为<strong>频率成形滤波器</strong>。</p></li><li><p>专门设计成基本上无失真地通过某些频率,而显著地衰减掉或消除掉另一些频率的系统称为<strong>频率选择性滤波器</strong>。</p><ul><li><p>一个低通滤波器就是通过低频(即在$w =0$附近的频率),而衰减或阻止较高频率的滤波器。</p></li><li><p>一个高通滤波器就是通过高频而衰减或阻止较低频率的滤波器</p></li><li><p>带通滤波器就是通过某一频带范围,而衰减掉既高于又低于所要通过的这段频带的滤波器。</p><blockquote><p>截止频率是在通带和阻带内频率的边界。理想频率选择性滤波器无失真地通过一组频率上的复指数信号,并全部阻止掉所有其他频率的信号。</p></blockquote></li></ul></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>$y(t)=\mathrm{d} x(t) / \mathrm{d} t$​：增强边缘的连续的频率成型滤波器</p></li><li><p>$R C \frac{\mathrm{d} v_{c}(t)}{\mathrm{d} t}+v_{c}(t)=v_{\mathrm{s}}(t)$​：当将$v_c(t)$作为输出的时候是低通滤波器；当将电阻两端的电压$v_r(t)$​作为输出的时候是高通滤波器。</p><blockquote><p>代入$v_s(t)=e^{jwt}$,$v_c(t)=H(jw)e^{jwt}$就可以得到$H(jw)$​的表达式</p></blockquote></li><li><p>$y[n]-ay[n-1]=x[n]$：递归离散时间滤波器。当$0&lt;a&lt;1$的时候，是一个低通滤波器；当$-1&lt;a&lt;0$时是高通滤波器。</p><blockquote><p>代入$x[n]=e^{jwn}$和$y[n]=H(e^{jw})e^{jwn}$就可以得到$H(e^{jw})$的表达式</p></blockquote></li><li><p>$y[n]=\frac{1}{N+M+1} \sum_{k=-N}^{M} x[n-k]$：非递归离散时间低通滤波器。</p></li><li>$y[n]=\frac{x[n]-x[n-1]}{2}$​：非递归离散时间高通滤波器。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>傅里叶级数最重要的性质之一是复指数特征函数性质的一个直接结果,这就是:若一个周期信号加到一个线性时不变系统上,那么输出也一定是周期的,且与输入信号的周期相同;并且, 输出的每一个傅里叶系数就是对应的输入傅里叶系数乘以复指数,该复指数的值是相应于傅里叶系数的那个频率的函数。</p><h1 id="连续时间傅里叶变换"><a href="#连续时间傅里叶变换" class="headerlink" title="连续时间傅里叶变换"></a>连续时间傅里叶变换</h1><p>当广泛的一类信号,其中包括全部有限能量的信号,也能够经由复指数信号的线性组合来表示。对周期信号而言,这些复指数基本信号构造单元全是成诸波关系的;而对非周期信号,它们则是在频率上无限小地靠近的。</p><p>因此,作为线性组合表示所取的形式是一个积分,而不是求和。在这种表示中所得到的系数谱称为傅里叶变换;而利用这些系数将信号表示为复指数信号线性组合的综合积分式本身则称为傅里叶逆变换。</p><p>在一个周期信号的傅里叶级数表示中,当周期增加时,基波频率就减小,成谐波关系的各分量在频率上愈趋靠近。当周期变成无穷大时,这些频率分量就形成了一个连续域,从而傅里叶级数的求和也就变成了一个积分。</p><p><strong>在建立非周期信号的傅里叶变换时,可以把非周期信号当成一个周期信号在周期任意大时的极限来看待</strong>,并且研究这个周期信号傅里叶级数表示式的极限特性。</p><h2 id="非周期信号傅里叶变换表示"><a href="#非周期信号傅里叶变换表示" class="headerlink" title="非周期信号傅里叶变换表示"></a>非周期信号傅里叶变换表示</h2><script type="math/tex; mode=display">x(t)=\frac{1}{2 \pi} \int_{-\infty}^{+\infty} X(\mathrm{j} \omega) \mathrm{e}^{\mathrm{j} \omega t} \mathrm{~d} \omega</script><script type="math/tex; mode=display">X(\mathrm{j} \omega)=\int_{-\infty}^{+\infty} x(t) \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d} t</script><p>这两个公式被称为傅里叶变换对，$X(j\omega)$称为$x(t)$的傅里叶变换或傅里叶积分，一式被称为傅里叶逆变换。一个非周期信号$x(t)$的变换$X(j\omega)$通常称为$x(t)$的频谱。</p><p>一个周期信号$\tilde{x}(t)$的傅里叶系数$a_k$能够利用$\tilde{x}(t)$的一个周期内信号的傅里叶变换的等间隔样本来表示。$\tilde{x}(t)$的傅里叶系数正比于一个周期内的$\tilde{x}(t)$信号傅里叶变换的样本。</p><script type="math/tex; mode=display">a_{k}=\left.\frac{1}{T} X(\mathrm{j} \omega)\right|_{\omega=k \omega_{0}}</script><blockquote><p>这里的$X(j\omega)$是非周期函数$x(t)$的傅里叶变换</p></blockquote><h3 id="傅里叶变换的收敛"><a href="#傅里叶变换的收敛" class="headerlink" title="傅里叶变换的收敛"></a>傅里叶变换的收敛</h3><p>从导出过程看，$x(t)$​的傅里叶变换是否存在的条件应该和傅里叶级数收敛所要求的那一组条件一样。</p><ol><li>$x(t)$能量有限：$\int_{-\infty}^{+\infty}|x(t)|^{2} \mathrm{~d} t&lt;\infty$</li><li>狄利赫利条件。这组条件充分保证了$\tilde x(t)$在不连续点外，在任何其他$t$上都等于$x(t)$，而在不连续点处其等于$x(t)$在不连续点两边值的平均值。<ul><li>$x(t)$绝对可积：$\int_{-\infty}^{+\infty}|x(t)| \mathrm{d} t&lt;\infty$</li><li>在任何有限区间内,$x(t)$​只有有限个最大值和最小值</li><li>在任何有限区间内,$x(t)$有有限个不连续点,并且在每个不连续点都必须是有限值</li></ul></li></ol><p>傅里叶变换的收敛也会呈现出吉伯斯现象。</p><h3 id="傅里叶现象的对偶性"><a href="#傅里叶现象的对偶性" class="headerlink" title="傅里叶现象的对偶性"></a>傅里叶现象的对偶性</h3><p>矩形脉冲信号$x(t)=\left\{\begin{array}{ll}<br>1, &amp; |t|<T_{1} \\0, & |t|>T_{1}<br>\end{array}\right.$的傅里叶变换为：</p><script type="math/tex; mode=display">X(\mathrm{j} \omega)=\int_{-T_{1}}^{T_{1}} \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d} t=2 \frac{\sin \omega T_{1}}{\omega}</script><p>而傅里叶变换为$X(\mathrm{j} \omega)=\left\{\begin{array}{ll}<br>1, &amp; |\omega|<W \\0, & |\omega|>W<br>\end{array}\right.$重组的$x(t)$为：</p><script type="math/tex; mode=display">x(t)=\frac{1}{2 \pi} \int_{-W}^{W} \mathrm{e}^{\mathrm{j} \omega t} \mathrm{~d} \omega=\frac{\sin W t}{\pi t}</script><p>可以用sinc函数$\operatorname{sinc}(\theta)=\frac{\sin \pi \theta}{\pi \theta}$可以简化两个表达式：</p><script type="math/tex; mode=display">\begin{aligned}\frac{2 \sin \omega T_{1}}{\omega} & =2 T_{1} \operatorname{sinc}\left(\frac{\omega T_{1}}{\pi}\right) \\\frac{\sin W t}{\pi t} & =\frac{W}{\pi} \operatorname{sinc}\left(\frac{W t}{\pi}\right)\end{aligned}</script><h4 id="sa函数和sinc函数"><a href="#sa函数和sinc函数" class="headerlink" title="sa函数和sinc函数"></a>sa函数和sinc函数</h4><script type="math/tex; mode=display">sa(x)=\frac {sinx}{x}</script><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/v2-95002ac0136e621ab2d9107294af3528_720w.jpg" alt="【笔记】信号与系统：Sa函数的积分 - 知乎"></p><script type="math/tex; mode=display">sinc(x)=\frac{sin(\pi x)}{\pi x}</script><p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.0c11589c5b18197000743693ba8c8035?rik=sWrQSR7shE3FMA&amp;riu=http%3a%2f%2felectron6.phys.utk.edu%2foptics421%2fmodules%2fm5%2fimages%2fsinc.gif&amp;ehk=l6%2bP1pqDLIQn62Nhgn13Gy4d0UotpLpdpDPk94Q2ZFg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="Diffraction"></p><h2 id="周期信号的傅里叶变换"><a href="#周期信号的傅里叶变换" class="headerlink" title="周期信号的傅里叶变换"></a>周期信号的傅里叶变换</h2><p>其实对于周期信号也能够建立傅里叶变换表示。这样就可以在统一框架内考虑周期和非周期信号。</p><p>周期信号$x(t)=\sum_{k=-\infty}^{+\infty} a_{k} \mathrm{e}^{\mathrm{j} k \omega_{0} t}$的傅里叶变换为：</p><script type="math/tex; mode=display">X(\mathrm{j} \omega)=\sum_{k=-\infty}^{+\infty} 2 \pi a_{k} \delta\left(\omega-k \omega_{0}\right)</script><blockquote><p>这里的$X(j\omega)$是周期函数的傅里叶变换</p></blockquote><p>也就有$e^{jk\omega_0t}\leftrightarrow 2\pi \delta \left( \omega-k\omega _{0}\right) $​。</p><h2 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h2><p>$x(t)$和$X(j\omega)$的傅里叶变换可以用这一对符号表示。</p><script type="math/tex; mode=display">x(t) \stackrel{\mathcal{F}}{\longleftrightarrow} X(\mathrm{j} \omega)</script><p>性质：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240407131615921.png" alt="image-20240407131615921"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240407131644819.png" alt="image-20240407131644819"></p><blockquote><p>时域卷积和<a href="#傅里叶级数与线性时不变系统">傅里叶级数与线性时不变系统</a>的对应：</p><script type="math/tex; mode=display">\begin{aligned}y(t) &=\dfrac{1}{2\pi }\int ^{+\infty }_{-\infty }X\left( j\omega \right) H\left( j\omega \right) e^{j\omega t}d\omega \\&=\dfrac{1}{2\pi }\int ^{+\infty }_{-\infty }2\pi \sum ^{+\infty }_{k=-\infty }a_{k}\delta \left( \omega -k\omega _{0}\right) H\left( j\omega \right) e^{j\omega t}d\omega \\&=\sum ^{+\infty }_{k=-\infty }a_{k}\int _{-\infty }^{+\infty }\delta \left( \omega -k\omega _{0}\right) H\left( j\omega \right) e^{j\omega t}d\omega \\&=\sum ^{+\infty }_{k=-\infty }a_{k}H\left( jk\omega _{0}\right) e^{jk\omega _{0}\cdot t}\end{aligned}</script><p>对偶性补充：</p><script type="math/tex; mode=display">若x(t) \stackrel{\mathcal{F}}{\longleftrightarrow} X(\mathrm{j} \omega)\\则X(jt)\stackrel{\mathcal{F}}{\longleftrightarrow} 2\pi x(-\omega)</script></blockquote><p>基本傅里叶变换对：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240407131709647.png" alt="image-20240407131709647"></p><h2 id="由线性常系数微分方程表征的系统"><a href="#由线性常系数微分方程表征的系统" class="headerlink" title="由线性常系数微分方程表征的系统"></a>由线性常系数微分方程表征的系统</h2><p>一类特别重要而有用的连续时间线性时不变系统是其输入输出满足如下形式的线性常系数微分方程的系统：</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} \frac{\mathrm{d}^{k} y(t)}{\mathrm{d} t^{k}}=\sum_{k=0}^{M} b_{k} \frac{\mathrm{d}^{k} x(t)}{\mathrm{d} t^{k}}</script><p>频率响应可以表征一个线性时不变系统。求这个系统的频率响应有两个方式：</p><ol><li><p>一是依赖复指数信号是线性时不变系统的特征函数这一事实。若$x(t)=e^{jwt}$，则$y(t)=H(j\omega)e^{jwt}$。代入微分方程即可求解。</p></li><li><p>根据卷积性质，可以得到：</p><script type="math/tex; mode=display">H(\mathrm{j} \omega)=\frac{Y(\mathrm{j} \omega)}{X(\mathrm{j} \omega)}=\frac{\sum_{k=0}^{M} b_{k}(\mathrm{j} \omega)^{k}}{\sum_{k=0}^{N} a_{k}(\mathrm{j} \omega)^{k}}</script><p>傅里叶变换方法将一个微分方程表征的线性时不变系统问题演变为直接的代数问题。</p><blockquote><p>[!Note]</p><p>注意这里的$Y(jw)$对应的反而是$x(t)$的微分项的系数</p></blockquote></li></ol><h1 id="离散时间傅里叶变换"><a href="#离散时间傅里叶变换" class="headerlink" title="离散时间傅里叶变换"></a>离散时间傅里叶变换</h1><p>在连续时间和离散时间信号分析中存在着很多相类似的地方，然而,也有一些重大的差别。</p><h2 id="离散时间非周期信号傅里叶变换"><a href="#离散时间非周期信号傅里叶变换" class="headerlink" title="离散时间非周期信号傅里叶变换"></a>离散时间非周期信号傅里叶变换</h2><p>$x[n]$是一个非周期函数。那么就有下面这对公式：</p><script type="math/tex; mode=display">\begin{aligned}x[n] & =\frac{1}{2 \pi} \int_{2 \pi} X\left(\mathrm{e}^{\mathrm{j} \omega}\right) \mathrm{e}^{\mathrm{j} \omega n} \mathrm{~d} \omega \\X\left(\mathrm{e}^{\mathrm{j} \omega}\right) & =\sum_{n=-\infty}^{+\infty} x[n] \mathrm{e}^{-\mathrm{j} \omega n}\end{aligned}</script><p>$X(e^{jw})$是离散时间傅里叶变换，其的周期为$2\pi$。上面的式子是综合公式（其只涉及在一个频率区间内积分），而下面的式子是分析公式。</p><p>并且还有：</p><script type="math/tex; mode=display">a_{k}=\frac{1}{N} X\left(\mathrm{e}^{\mathrm{j} k \omega_{0}}\right)=\frac 1 N X(e^{jw})|_{\omega=k\omega_0}</script><p>也就是一个周期信号$\tilde x[n]$的傅里叶系数$a_k$可以用一个有限长序列$x[n]$的傅里叶变换的等间隔样本来表示。</p><h3 id="离散时间傅里叶变换的收敛问题"><a href="#离散时间傅里叶变换的收敛问题" class="headerlink" title="离散时间傅里叶变换的收敛问题"></a>离散时间傅里叶变换的收敛问题</h3><p><strong>分析公式因为涉及无穷项求和，所以有收敛的条件</strong>：</p><ol><li>绝对可和：$\sum_{n=-\infty}^{+\infty}|x[n]|&lt;\infty$</li><li>或能量有限：$\sum_{n=-\infty}^{+\infty}|x[n]|^{2}&lt;\infty$</li></ol><p>综合公式因为是在有限的积分区间内进行，所以一般不存在收敛问题。并且也<strong>没有吉伯斯现象</strong>。</p><h2 id="离散时间周期信号傅里叶变换"><a href="#离散时间周期信号傅里叶变换" class="headerlink" title="离散时间周期信号傅里叶变换"></a>离散时间周期信号傅里叶变换</h2><script type="math/tex; mode=display">\begin{align}x[n] &= \sum_{k=\langle N\rangle} a_{k} \mathrm{e}^{\mathrm{j} k(2 \pi / N) n} \\X\left(\mathrm{e}^{\mathrm{j} \omega}\right) &= \sum_{k=-\infty}^{+\infty} 2 \pi a_{k} \delta\left(\omega-\frac{2 \pi k}{N}\right) = \sum_{k=-\infty}^{+\infty} 2 \pi a_{k} \delta\left(\omega-k\omega_0\right)\end{align}</script><h2 id="傅里叶变换的性质-1"><a href="#傅里叶变换的性质-1" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h2><p>离散时间傅里叶变换的性质：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240411163041632.png" alt="image-20240411163041632"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240411163148977.png" alt="image-20240411163148977"></p><blockquote><ol><li><p>时域相乘等于在频域上做周期卷积：</p><script type="math/tex; mode=display">x_{1}[n] x_{2}[n]\stackrel{\mathcal{F}}{\longleftrightarrow}\frac{1}{2 \pi} X_{1}\left(\mathrm{e}^{\mathrm{j} \omega}\right) \otimes X_{2}\left(\mathrm{e}^{\mathrm{j} \omega}\right)</script></li><li><p>对偶性补充：（离散时间傅里叶级数的对偶）</p><script type="math/tex; mode=display">\begin{array}{l}x[n] \stackrel{\mathcal{F}}{\longleftrightarrow} a_{k} \\a_{n} \stackrel{\mathcal{F}}{\longleftrightarrow} \frac{1}{N} x[-k] \\\end{array}</script></li></ol></blockquote><p>离散时间傅里叶变换变换对：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240411163242744.png" alt="image-20240411163242744"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240411163259260.png" alt="image-20240411163259260"></p><h2 id="对偶性"><a href="#对偶性" class="headerlink" title="对偶性"></a>对偶性</h2><p>对离散时间傅里叶变换而言,分析公式和综合公式之间却不存在相应的对偶性。但存在以下两种对偶性：</p><ul><li><p>离散时间公式的对偶性</p><p>若$f[k]$是$g[n]$的傅里叶级数系数：</p><script type="math/tex; mode=display">f[k]=\frac{1}{N} \sum_{n=\langle N\rangle} g[n] \mathrm{e}^{-\mathrm{j} k(2 \pi / N) n}</script><p>那么，$(1 / N) g[-k]$就相当于 $f[n]$​的傅里叶级数的系数序列：</p><script type="math/tex; mode=display">f[n]=\sum_{k=\langle N\rangle} \frac{1}{N} g[-k] \mathrm{e}^{\mathrm{j} k(2 \pi / N) n}</script></li><li><p>离散时间傅里叶变换和连续时间傅里叶级数之间的对偶性</p><script type="math/tex; mode=display">\begin{aligned}x[n] & =\frac{1}{2 \pi} \int_{2 \pi} X\left(\mathrm{e}^{\mathrm{j} \omega}\right) \mathrm{e}^{\mathrm{j} \omega n} \mathrm{~d} \omega \\X\left(\mathrm{e}^{\mathrm{j} \omega}\right) & =\sum_{n=-\infty}^{+\infty} x[n] \mathrm{e}^{-\mathrm{j} \omega n} \\x(t) & =\sum_{k=-\infty}^{+\infty} a_{k} \mathrm{e}^{\mathrm{j} k \omega_{0} t} \\a_{k} & =\frac{1}{T} \int_{T} x(t) \mathrm{e}^{-\mathrm{j} k \omega_{0} t} \mathrm{~d} t\end{aligned}</script><p>由式子2和式子3，可以看出一个离散时间信号$x[n]$的傅里叶变换$X(e^{j\omega})$，是以$x[-n]$为傅里叶级数的连续时间信号。</p><p>由式子1和4，可以看出傅里叶变换为$X(e^{j\omega})$的离散时间信号$x[n]$，是连续时间信号$-X(e^{-jw})$​的傅里叶级数系数。</p><blockquote><p>因为$X(e^{j\omega})$的周期为$2\pi$，所以$\omega_0=1$。</p></blockquote></li></ul><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240421172220243.png" alt="image-20240421172220243"></p><h2 id="由线性常系数差分方程表征的系统"><a href="#由线性常系数差分方程表征的系统" class="headerlink" title="由线性常系数差分方程表征的系统"></a>由线性常系数差分方程表征的系统</h2><p>对一个线性时不变系统而言,其输出$y[n]$和输入$x[n]$之间的线性常系数差分方程一般具有如下形式:</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} y[n-k]=\sum_{k=0}^{M} b_{k} x[n-k]</script><p>频率响应$H(e^{j\omega})$解法也有两种：</p><ol><li><p>利用复指数是线性时不变系统特征函数这一事实来求。也就是将$y[n]$和$x[n]$代入上式中。</p></li><li><p>或者通过下式求解。（<strong>注意分母和分子</strong>）</p><script type="math/tex; mode=display">H\left(\mathrm{e}^{\mathrm{j} \omega}\right)=\frac{Y\left(\mathrm{e}^{\mathrm{j} \omega}\right)}{X\left(\mathrm{e}^{\mathrm{j} \omega}\right)}=\frac{\sum_{k=0}^{M} b_{k} \mathrm{e}^{-\mathrm{j} k \omega}}{\sum_{k=0}^{N} a_{k} \mathrm{e}^{-\mathrm{j} k \omega}}</script></li></ol><h1 id="信号与系统的时域和频域特性"><a href="#信号与系统的时域和频域特性" class="headerlink" title="信号与系统的时域和频域特性"></a>信号与系统的时域和频域特性</h1><p>对于一个系统,既从频域又从时域方面提出或限定了一定的特性要求,而往往这些又是互相矛盾的要求。所以,在系统设计和分析中,将时域特性与频域特性联系起来并给以权衡考虑是很必要的。</p><h2 id="傅里叶变换的模和相位表示"><a href="#傅里叶变换的模和相位表示" class="headerlink" title="傅里叶变换的模和相位表示"></a>傅里叶变换的模和相位表示</h2><p>一般来说,傅里叶变换是复数值的,并且可以用它的模和相位来表示。</p><ul><li>连续时间傅里叶变换$X(\mathrm{j} \omega)$的模-相表示是$X(\mathrm{j} \omega)=|X(\mathrm{j} \omega)| \mathrm{e}^{\mathrm{j} \nless X(\mathrm{j} \omega)}$​。</li><li>离散时间傅里叶变换$X(e^{\mathrm{j} \omega})$的模-相表示是$X\left(\mathrm{e}^{\mathrm{j} \omega}\right)=\left|X\left(\mathrm{e}^{\mathrm{j} \omega}\right)\right| \mathrm{e}^{\mathrm{j} \nless X\left(\mathrm{e}^{\mathrm{j} \omega}\right)}$</li></ul><p>以连续时间傅里叶变换为例,模$\left|X(jw)\right|$所描述的是一个信号的基本频率含量,也即给出的是组成$x(t)$的各复指数信号<strong>相对振幅</strong>的信息。相位角$\nless X(\mathrm{j} \omega)$不影响各个频率分量的大小,但提供的是有关这些复指数信号的<strong>相对相位信息</strong>。==由$\nless X(\mathrm{j} \omega)$所代表的相位关系对信号$x(t)$的本质属性有显著的影响.==</p><h3 id="线性时不变系统频率响应的模和相位表示"><a href="#线性时不变系统频率响应的模和相位表示" class="headerlink" title="线性时不变系统频率响应的模和相位表示"></a>线性时不变系统频率响应的模和相位表示</h3><p>连续时间中一个线性时不变系统的输入和输出的傅里叶变换关联如下：</p><script type="math/tex; mode=display">Y(\mathrm{j} \omega)=H(\mathrm{j} \omega) X(\mathrm{j} \omega)</script><p>$Y(jw)$的模-相表示就如下：</p><script type="math/tex; mode=display">|Y(\mathrm{j} \omega)|=|H(\mathrm{j} \omega)||X(\mathrm{j} \omega)|\\\nless Y(\mathrm{j} \omega)=\nless H(\mathrm{j} \omega)+\nless X(\mathrm{j} \omega)</script><p>如果,系统对输入的改变是以一种有意义的方式进行的,那么这种在模和相位上的变化可能都是我们所希望的;否则,就是不希望有的。在后一种情况下, 上两个式子的影响一般称为<strong>幅度和相位失真</strong>。</p><blockquote><p>[!NOTE] </p><ol><li>具有整数斜率的线性相位就相应于$x[n]$一个整数样本的移位。</li><li>如果输入信号傅里叶变换的模通过一个系统时都没有改变，这样的系统一般称为全通系统。</li></ol></blockquote><h3 id="理想频率选择性滤波器的时域特性"><a href="#理想频率选择性滤波器的时域特性" class="headerlink" title="理想频率选择性滤波器的时域特性"></a>理想频率选择性滤波器的时域特性</h3><h4 id="连续时间"><a href="#连续时间" class="headerlink" title="连续时间"></a>连续时间</h4><p>一个连续时间理想低通滤波器具有如下形式的频率响应：</p><script type="math/tex; mode=display">H(j \omega)=\left\{\begin{array}{ll}1, & |\omega| \leqslant \omega_{c} \\0, & |\omega|>\omega_{c}\end{array}\right.</script><p>其的单位冲击响应为：</p><script type="math/tex; mode=display">h(t)=\frac{\sin \omega_{c} t}{\pi t}</script><h4 id="离散时间"><a href="#离散时间" class="headerlink" title="离散时间"></a>离散时间</h4><p>一个离散时间理想低通滤波器具有如下形式的频率响应：</p><script type="math/tex; mode=display">H\left(\mathrm{e}^{\mathrm{j} \omega}\right)=\left\{\begin{array}{ll}1, & |\omega| \leqslant \omega_{c} \\0, & \omega_{c}<|\omega| \leqslant \pi\end{array}\right.</script><p>单位脉冲响应为：</p><script type="math/tex; mode=display">h[n]=\frac{\sin \omega_{c} n}{\pi n}</script><p>尽管从频域滤波的角度看，理想滤波器的频率特性是最好的，但它们的时域特性并不是最佳的。</p><ol><li>理想滤波器是非因果系统，因而是物理不可实现的</li><li>$h(t)$存在振荡。</li></ol><h1 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h1><p>在一定条件下,一个连续时间信号完全可以用该信号在等时间间隔点上的值或样本来表示,并且可以用这些样本值把该信号全部恢复出来。</p><p>采样的概念使人们想到一种极富吸引力并广泛使用的方法,就是利用离散时间系统技术来实现连续时间系统并处理连续时间信号:可以利用采样先把一个连续时间信号变换为一个离散时间信号,再用一个离散时间系统将该离散时间信号进行处理,之后再把它变换回到连续时间中。</p><h2 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h2><p>如果一个信号是<strong>带限</strong>的(即它的傅里叶变换在某一有限频带范围以外均为零),并且它的<strong>样本取得足够密</strong>(相对于信号中的最高频率而言),那么这些<strong>样本值就能唯一地用来表征这一信号</strong>,并且能从这些样本中把信号完全恢复出来。这一结果就是采样定理。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240422165023666.png" alt="image-20240422165023666"></p><blockquote><p>[!NOTE]</p><p>在采样定理中, 采样频率必须大于$2 \omega_{M}$，该频率 $2 \omega_{M}$一般称为奈奎斯特率。</p></blockquote><h3 id="冲激串采样"><a href="#冲激串采样" class="headerlink" title="冲激串采样"></a>冲激串采样</h3><p>要表示一个连续时间信号在均匀间隔上的采样，可以通过周期冲激串去乘待采样的连续时间信号$x(t)$。这也叫<strong>冲激串采样</strong>：</p><script type="math/tex; mode=display">p(t)=\sum_{n=-\infty}^{+\infty} \delta(t-n T)</script><h3 id="零阶保持采样"><a href="#零阶保持采样" class="headerlink" title="零阶保持采样"></a>零阶保持采样</h3><p>产生和传输窄而幅度大的脉冲(这就很近似于冲激)都是相当困难的,因此以所谓零阶保持的方式来产生采样信号往往更方便些。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240422165813107.png" alt="image-20240422165813107"></p><p>$x_0(t)$就是$x(t)$采样后的信号。这里$H_{0}(\mathrm{j} \omega)=\mathrm{e}^{-\mathrm{j} \omega T / 2}\left[\frac{2 \sin (\omega T / 2)}{\omega}\right]$，$p(t)$就是一个周期冲激串。</p><p>而将采样后的$x_0(t)$恢复，需要将其再通过一个线性时不变系统$r$，并且：</p><script type="math/tex; mode=display">H_{r}(\mathrm{j} \omega)=\frac{\mathrm{e}^{\mathrm{j} \omega T / 2} H(\mathrm{j} \omega)}{\frac{2 \sin (\omega T / 2)}{\omega}}</script><p>并且,实质上它就代表了一种可能的(虽然肯定很粗糙)样本值之间的内插。（$H(j\omega)$是一个理想低通滤波器的频率响应。）</p><h2 id="内插"><a href="#内插" class="headerlink" title="内插"></a>内插</h2><p><strong>内插(也就是用一连续信号对一组样本值的拟合)是一个由样本值来重建某一函数的常用过程</strong>,这一重建结果既可以是近似的,也可以是完全准确的。</p><p>利用理想低通滤波器的单位冲激响应的内插通常称为<strong>带限内插</strong>。因为这种内插,只要$x(t)$​是带限的,而采样频率又满足采样定理中的条件,就实现了信号的真正重建。</p><h2 id="欠采样的效果-混叠现象"><a href="#欠采样的效果-混叠现象" class="headerlink" title="欠采样的效果:混叠现象"></a>欠采样的效果:混叠现象</h2><p>在前面的讨论中，<strong>我们假定了采样频率足够高</strong>，因此满足采样定理中的条件。当 $ \omega_{s} &gt; 2\omega_{M}$ 时，采样信号的频谱是由 $x(t)$ 的频谱重复组成的，这正是采样定理的基础。</p><p>然而，当 $\omega_{s} &lt; 2\omega_{M}$ 时，$x(t)$的频谱 $X(j\omega)$ 不再在 $X_{p}(j\omega)$中重复，因此利用低通滤波也无法将 $x(t)$ 从采样信号中恢复出来。</p><p>显然被重建的信号 $x_{r}(t)$ 将不会等于 $x(t)$。然而原始信号 $x(t)$ 和利用带限内插得到的 $x_{r}(t)$ <strong>在那些采样瞬时总是相等的</strong>。</p><h1 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h1><p>将某一个载有信息的信号嵌入另一个信号中的过程称为<strong>调制</strong>；而将这个载有信息的信号提取出来的过程称为<strong>解调</strong>。</p><p>调制技术不仅能够将信息嵌入可以有效传输的信号中,而且还能够把频谐重叠的多个信号通过称为<strong>复用</strong>的概念在同一信道上同时传输。</p><h2 id="复指数与正弦幅度调制"><a href="#复指数与正弦幅度调制" class="headerlink" title="复指数与正弦幅度调制"></a>复指数与正弦幅度调制</h2><p>很多通信系统都建立在正弦幅度调制的基础上，在这里一个复指数信号或正弦信号$c(t)$的振幅被载有信息的信号$x(t)$​相乘(或调制)。其有两种常用形式，一是载波信号为<strong>复指数</strong>，另一种是载波信号为<strong>正弦</strong>的。</p><h3 id="复指数载波的幅度调制"><a href="#复指数载波的幅度调制" class="headerlink" title="复指数载波的幅度调制"></a>复指数载波的幅度调制</h3><p>载波信号$c(t)$为复指数：</p><script type="math/tex; mode=display">c(t)=\mathrm{e}^{\mathrm{j}\left(\omega_{c} t+\theta_{c}\right)}</script><p>这里$\omega_c$被称为载波频率，为方便起见，下面的$\theta_c=0$。那么已调信号$y(t)$就是：</p><script type="math/tex; mode=display">y(t)=x(t) \mathrm{e}^{\mathrm{j} \omega_{c} t}</script><p>这相当于在频域上做频移：</p><script type="math/tex; mode=display">Y(\mathrm{j} \omega)=X\left(\mathrm{j} \omega-\mathrm{j} \omega_{c}\right)</script><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508092232583.png" alt="image-20240508092232583"></p><h3 id="正弦载波的幅度调制"><a href="#正弦载波的幅度调制" class="headerlink" title="正弦载波的幅度调制"></a>正弦载波的幅度调制</h3><p>载波信号$c(t)$为正弦：</p><script type="math/tex; mode=display">c(t)=\cos \left(\omega_{c} t+\theta_{c}\right)</script><p>再次让$\theta_c=0$。那么已调信号$y(t)$的频谱就是：</p><script type="math/tex; mode=display">Y(\mathrm{j} \omega)=\frac{1}{2}\left[X\left(\mathrm{j} \omega-\mathrm{j} \omega_{c}\right)+X\left(\mathrm{j} \omega+\mathrm{j} \omega_{c}\right)\right]</script><p>在图上看，就是：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508092714037.png" alt="image-20240508092714037"></p><p>图中可以注意到，以 $+\omega_{c}$ 和 $-\omega_{c}$ 为中心都有一个原始信号频谱形状的重复。结果只要 $\omega_{M} &lt; \omega_{c}$（可保证左右都不越过$x=0$的线），就能从$y(t)$中恢复出$x(t)$；否则这两个重复的频谱将会有重叠，也就无法恢复。</p><h2 id="正弦幅度调制的解调"><a href="#正弦幅度调制的解调" class="headerlink" title="正弦幅度调制的解调"></a>正弦幅度调制的解调</h2><p>解调有两种常用的方法，分别是<strong>同步解调</strong>和<strong>非同步解调</strong>。同步解调指的是发射机和接收机在相位上是同步的，而非同步解调指的是它们在相位上不同步。</p><h3 id="同步解调"><a href="#同步解调" class="headerlink" title="同步解调"></a>同步解调</h3><p>假设已调信号如下（$\omega_{M} &lt; \omega_{c}$）：</p><script type="math/tex; mode=display">y(t)=x(t) \cos \omega_{c} t</script><p>则解调需要对$y(t)$乘一个$\cos\omega_c$，然后再通过一个低通滤波器。</p><script type="math/tex; mode=display">w(t)=y(t) \cos \omega_{c} t=x(t) \cos ^{2} \omega_{c} t=\frac{1}{2} x(t)+\frac{1}{2} x(t) \cos 2 \omega_{c} t</script><p>对$\omega (t)$应用低通滤波器，从而消除掉第二项，保留第一项。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508094534153.png" alt="image-20240508094534153"></p><h3 id="非同步解调"><a href="#非同步解调" class="headerlink" title="非同步解调"></a>非同步解调</h3><p>在上述同步解调中，解调器载波在相位上与调制器载波是同相的。但如果$\theta_{c} \neq \phi_{c}$​，那么考虑下面两个式子。</p><script type="math/tex; mode=display">\begin{aligned}y(t) & =\mathrm{e}^{\mathrm{j}\left(\omega_{c} t+\theta_{c}\right)} x(t) \\w(t) & =\mathrm{e}^{-\mathrm{j}\left(\omega_{c} t+\phi_{c}\right)} y(t)\end{aligned}</script><p>则$\omega(t)$将有一个复振幅因子$\cos \left(\theta_{c}-\phi_{c}\right)$:</p><script type="math/tex; mode=display">w(t)=\mathrm{e}^{\mathrm{j}\left(\boldsymbol{\theta}_{c}-\phi_{c}\right)} x(t)=x(t) \cos \left(\omega_{c} t+\theta_{c}\right) \cos \left(\omega_{c} t+\phi_{c}\right)=\frac{1}{2} \cos \left(\theta_{c}-\phi_{c}\right) x(t)+\frac{1}{2} x(t) \cos \left(2 \omega_{c} t+\theta_{c}+\phi_{c}\right)</script><p>虽然可以不同相，但是要求两个振荡器之间的相位关系必须在全部时间内保持不变。</p><p>还有另一种非同步解调叫包络检波器。通过跟踪已调信号$y(t)$的包络线来恢复信号$x(t)$。</p><h2 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h2><p>如果有频谱互相重叠的单个声音信号，可以利用正弦幅度调制把它们的频谱在频率上进行搬移，使这些已调信号的频谱不再重叠。这样，就<strong>能够在同一个宽带信道上同时传输这些信号</strong>。这就是<strong>频分多路复用</strong>。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508104125985.png" alt="image-20240508104125985"></p><h2 id="单边带正弦幅度调制"><a href="#单边带正弦幅度调制" class="headerlink" title="单边带正弦幅度调制"></a>单边带正弦幅度调制</h2><p>在上面的频分多路复用系统中，每一个信号的频谱都在正和负的频率上重复,因此已调信号占据的带宽是原始信号的2倍。这一点在频带的利用上是不经济的。<strong>利用正弦载波，在已调信号中有冗余度，利用一种称为单边带调制的技术,可以把这个冗余度除掉。</strong>（上、下两个边带都保留的称为双边带调制）</p><p>单边带信号可以通过以下几种方法获得：</p><ol><li><strong>应用带通或高通滤波器</strong>：<ul><li>使用锐截止的带通或高通滤波器，滤除掉中不需要的边带。</li></ul></li></ol><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508123739116.png" alt="image-20240508123739116"></p><ol><li><strong>采用移相技术</strong>：<ul><li>通过移相技术来滤除一个边带，同时保留另一个边带。</li></ul></li></ol><h2 id="用脉冲串进行载波的幅度调制"><a href="#用脉冲串进行载波的幅度调制" class="headerlink" title="用脉冲串进行载波的幅度调制"></a>用脉冲串进行载波的幅度调制</h2><h3 id="脉冲串载波调制"><a href="#脉冲串载波调制" class="headerlink" title="脉冲串载波调制"></a>脉冲串载波调制</h3><p>前几节讨论的幅度调制利用的是正弦载波。<strong>另一类重要的幅度调制技术利用的载波信号是一个脉冲串。</strong></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508122929077-5142695.png" alt="image-20240508122929077"></p><p>因为 $ c(t) $ 是周期的，周期为 $ T $，所以 $ C(\mathrm{j} \omega) $ 就是由在频域中相隔 $ 2 \pi / T $ 的冲激所组成的，即</p><script type="math/tex; mode=display"> C(\mathrm{j} \omega)=2 \pi \sum_{k=-\infty}^{-\infty} a_{k} \delta\left(\omega-k \omega_{\mathrm{c}}\right)</script><p>其中：</p><script type="math/tex; mode=display">a_{k}=\frac{\sin \left(k \omega_{c} \Delta / 2\right)}{\pi k}</script><p>最后得到$Y(j\omega)$：</p><script type="math/tex; mode=display">Y(\mathrm{j} \omega)=\sum_{k=-\infty}^{+\infty} a_{k} X\left(\mathrm{j}\left(\omega-k \omega_{c}\right)\right)</script><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240508123627921.png" alt="image-20240508123627921"></p><p>可以用低通滤波器将原信号$x(t)$恢复。</p><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>频分多路复用是为每一路信号指定不同的频率间隔,而<strong>时分多路复用则是为每一路信号指定不同的时间间隔</strong>。</p><p>对每一路信号从复合信号中解复用,是通过时间控制门的办法来选择与每一路信号有关的特定时隙来完成的。</p><h1 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h1><p>连续时间傅里叶变换提供了将信号表示成形如 $e^{s t},s=j\omega$ 的复指数信号的线性组合。然而,特征函数性质及其他很多结果对任意$s$值都是适用的,而并不是将它仅限于纯虚数的情况。这样的看法就导致了连续时间傅里叶变换的推广，称为拉普拉斯变换。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>（双边）拉普拉斯变换的定义如下：</p><script type="math/tex; mode=display">X(s) \triangleq \int_{-\infty}^{+\infty} x(t) \mathrm{e}^{-s t} \mathrm{~d} t</script><blockquote><p>通常，使上式收敛的$s$值的范围被称为拉普拉斯变换的收敛域（Region of Convergence），简称ROC。</p></blockquote><p>其中复变量$s=\sigma+j\omega$。可以将拉普拉斯变换表示为算子$\mathcal{L}\{x(t)\}$的形式，而将$x(t)$和$X(s)$之间的关系记为：</p><script type="math/tex; mode=display">x(t) \stackrel{L}{\longleftrightarrow} X(s)</script><p>当$s=j\omega$的时候就是傅里叶变换。并且还可以将拉普拉斯变换看为$x(t)$乘一个实指数信号以后的傅里叶变换：</p><script type="math/tex; mode=display">X(\sigma+\mathrm{j} \omega)=\int_{-\infty}^{+\infty}\left[x(t) \mathrm{e}^{-\sigma t}\right] \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{~d} t</script><h3 id="有理拉普拉斯变换"><a href="#有理拉普拉斯变换" class="headerlink" title="有理拉普拉斯变换"></a>有理拉普拉斯变换</h3><p>对于有理拉普拉斯变换来说：</p><ul><li>因为在分子多项式的那些根上 $X(s)=0$，故称其为 $X(s)$ 的零点</li><li>分母多项式的那些根上 $X(s)$ 变成无界的，故称分母多项式的根为 $X(s)$ 的极点。</li></ul><p>在有限平面内，$X(s)$ 的零点和极点，除了一个常数因子外可以完全表征 $X(s)$ 的代数表示式。通过$s$平面内的极点和零点的 $X(s)$ 的表示就称为 $X(s)$ 的零-极点图。</p><p><strong>然而，$X(s)$ 的代数表示式本身并不能确认该拉普拉斯变换的收敛域。</strong>除了一个常数因子外，一个有理拉普拉斯变换的完全表征是由该变换的零-极点图与它的收敛域一起组成的。</p><h2 id="收敛域"><a href="#收敛域" class="headerlink" title="收敛域"></a>收敛域</h2><p>两个很不相同的信号能够有完全相同的$X(s)$代数表示式，因此它们的拉普拉斯变换只有靠收敛域才能区分。</p><p>收敛域有一系列的性质：</p><ol><li><p>$X(s)$ 的收敛域在 $s$ 平面内由平行于 $j\omega$ 轴的带状区域所组成。</p></li><li><p>对有理拉普拉斯变换来说,收敛域内不包括任何极点。</p></li><li><p>如果 $x(t)$ 是有限持续期的，并且是绝对可积的，那么收敛域就是整个 $s$ 平面。</p></li><li><p>如果 $x(t)$ 是右边信号，并且 $\mathcal{Re}\{s\}=\sigma_{0}$ 这条线位于收敛域内，那么 $\mathcal{R}\{s\}&gt;\sigma_{0}$ 的全部 $s$​ 值都一定在收敛域内。</p><blockquote><p>若在某有限时间 $T_{1}$ 之前，$x(t)=0$，则称该信号为右边信号。</p></blockquote></li><li><p>如果 $x(t)$ 是左边信号，并且 $\mathcal{Re}\{s\}=\sigma_{0}$ 这条线位于收敛域内，那么 $\mathcal{Re}\{s\}&lt;\sigma_{0}$ 的全部 $s$​ 值也一定在收敛域内。</p><blockquote><p>若在某有限时间 $T_{2}$ 之后，$x(t)=0$，则称该信号为左边信号。</p></blockquote></li><li><p>如果 $x(t)$ 是双边信号，并且 $\mathcal{Re}\{s\}=\sigma_{0}$ 这条线位于收敛域内，那么收敛域就一定是 ${s}$ 平面的两条带状区域组成，直线 ${\mathcal{Re}}\{s\} =\sigma_{0}$​ 位于带中。</p><blockquote><p>可将 $x(t)$ 分为右边信号 $x_R(t)$ 和左边信号 $x_L(t)$ 之和，$x(t)$ 的拉普拉斯变换的收敛域就是使得 $x_R(t)$ 和 $x_L(t)$ 的拉普拉斯变换都收敛的区域。</p><p>如果这两个半平面在没有重叠，那么即使 $x_R(t)$ 和 $x_S(t)$ 的拉普拉斯变换存在，$x(t)$ 的拉普拉斯变换也不存在。</p></blockquote></li><li><p>如果 $x(t)$​ 的拉普拉斯变换 $X(s)$​ 是有理的，那么它的收敛域是由极点所界定，或者延伸到无穷远。此外，在收敛域内不包含 $X(s)$​ 的任何极点。</p></li><li><p>如果 $x(t)$ 的拉普拉斯变换 $X(s)$ 是有理的，那么如果 $x(t)$ 是右边信号，其收敛域位于 $s$ 平面上最右边极点的右边；如果 $x(t)$ 是左边信号，其收敛域位于 $s$​ 平面上最左边极点的左边。</p></li></ol><h2 id="拉普拉斯逆变换"><a href="#拉普拉斯逆变换" class="headerlink" title="拉普拉斯逆变换"></a>拉普拉斯逆变换</h2><p>拉普拉斯逆变换为：</p><script type="math/tex; mode=display">x(t)=\frac{1}{2 \pi \mathrm{j}} \int_{\sigma-\mathrm{j} \infty}^{\sigma+\mathrm{j} \infty} X(s) \mathrm{e}^{s t} \mathrm{~d} s</script><p>上式，积分路径是在平面内对应于满足 $\text{Re}(s) = \sigma$ 的所有点的这条直线，该直线平行于 $j\omega$ 轴。</p><p>然而,对于有理变换,求其拉普拉斯逆变换不必直接计算上式，而可以像求傅里叶逆变换所做的那样，采用部分分式展开的办法，求出每一项的逆变换后再相加：</p><script type="math/tex; mode=display">X(s)=\sum_{i=1}^{m} \frac{A_{i}}{s+a_{i}}</script><h2 id="零-极点图"><a href="#零-极点图" class="headerlink" title="零-极点图"></a>零-极点图</h2><p>一个有理拉普拉斯变换可以因式分解成：</p><script type="math/tex; mode=display">X(s)=M \frac{\prod_{i=1}^{R}\left(s-\beta_{i}\right)}{\prod_{j=1}^{P}\left(s-\alpha_{j}\right)}</script><p>为了求取 $X(s)$ 在 $s = s_1$ 的值，乘积中的每一项都可用一个从零点或极点到 $s_1$ 点的向量来表示。那么：</p><ul><li>$X(s_1)$ 的模就是各零点向量（从各个零点到 $s_1$ 的向量）长度乘积的 $M$ 倍被各极点向量（从各个极点到 $s_1$ 的向量）长度的积相除。（极点用$\times$表示）</li><li>复数 $X(s_1)$ 的相角则是这些零点向量相角的和减去这些极点向量相角的和。如果在上式中比例因子 $M$ 是负的，则对应有一个附加相角 $\pi$。（零点用$\circ$表示）</li></ul><h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240514145930976.png" alt="image-20240514145930976"></p><blockquote><p>细节：</p><ol><li>线性性质：<ul><li>$R_1$和$R_2$的交可以为空，那么$X(s)$就没有收敛域，$x(t)$不存在拉普拉斯变换。</li><li>$X(s)$的收敛域有可能比这个交更大。</li></ul></li><li>时域尺度变换：<ul><li>对于 $0 &lt; a &lt; 1$，$X(s)$ 的收敛域要变为原来的 $a$ 倍。</li><li>对于 $a &gt; 1$，收敛域要扩展为原来的 $a$ 倍。</li><li>若 $a$ 为负，收敛域就要进行倒置再加一个尺度变换。</li></ul></li><li>共轭：<ul><li>若 $x(t)$ 为实函数，并且若 $X(s)$ 有一个极点或零点在 $s = s_0$，即如果 $X(s)$ 在 $s = s_0$ 无界或为零，那么 $X(s)$ 也一定有一个复数共轭的 $s = s^*_0$ 的极点或零点</li></ul></li></ol></blockquote><h2 id="拉普拉斯变换对"><a href="#拉普拉斯变换对" class="headerlink" title="拉普拉斯变换对"></a>拉普拉斯变换对</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240517131034195.png" alt="image-20240517131034195"></p><h2 id="拉普拉斯变换与线性时不变系统"><a href="#拉普拉斯变换与线性时不变系统" class="headerlink" title="拉普拉斯变换与线性时不变系统"></a>拉普拉斯变换与线性时不变系统</h2><p>对于线性时不变系统，拉普拉斯变换的作用直接来自于卷积性质。根据这一性质就可以得到，一个线性时不变系统输入和输出的拉普拉斯变换是通过乘以系统单位冲激响应的拉普拉斯变换联系起来的：</p><script type="math/tex; mode=display">Y(s)=H(s)X(s)</script><p>当 $s=\mathrm{j} \omega$ 时, $H(s)$ 就是这个线性时不变系统的频率响应。在拉普拉斯变换中，称 $H(s)$ 为<strong>系统函数</strong>或<strong>转移函数</strong>。</p><h3 id="因果性"><a href="#因果性" class="headerlink" title="因果性"></a>因果性</h3><p>对于一个因果线性时不变系统，其单位冲激响应在$t&lt;0$时为零，因此是一个右边信号，<strong>其系统函数的收敛域是某个右半平面</strong>。</p><p><strong>位于最右边极点的右边的收敛域并不保证系统是因果的</strong>，它只保证单位冲激响应是右边的。然而，对于一个具有<strong>有理</strong>系统函数的系统来说，系统的因果性就等效于收敛域位于最右边极点的右边的右半平面。</p><p>如果系统的单位冲激响应在$t&gt;0, h(t) =0$，就说该系统是反因果的。同样：</p><ul><li>$h(t)$是左边信号，系统函数 $H(s)$的收敛域就必须是某个左半平面。</li><li>如果 $H(s)$是<strong>有理</strong>的，那么收敛域位于最左边极点的左边就等效于系统是反因果的。</li></ul><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>一个线性时不变系统的稳定性等效于它的单位冲激响应是绝对可积的，这时单位冲激响应的傅里叶变换收敛。则，当且仅当系统函数$H(s)$的收敛域包括$jw$轴，即$Re\{s\}=0$时，一个线性时不变系统就是稳定的。</p><p>稳定性可以很简单地用极点的位置来表征：</p><ul><li>这个系统若是因果的，且有有理系统函数 $H(s)$，收敛域就在最右边极点的右边</li><li>这个系统若<strong>同时</strong>是稳定的，$H(s)$ 的最右边的极点就必须位于 $\mathrm{j} \omega$ 轴的左边。</li></ul><h3 id="由线性常系数微分方程表征的线性时不变系统"><a href="#由线性常系数微分方程表征的线性时不变系统" class="headerlink" title="由线性常系数微分方程表征的线性时不变系统"></a>由线性常系数微分方程表征的线性时不变系统</h3><p>拉普拉斯变换的性质也能用来直接求得一个由线性常系统微分方程所表征系统的系统函数。考虑如下形式的线性常系数微分方程：</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} \frac{\mathrm{d}^{k} y(t)}{\mathrm{d} t^{k}}=\sum_{k=0}^{M} b_{k} \frac{\mathrm{d}^{k} x(t)}{\mathrm{d} t^{k}}</script><p>那么：</p><script type="math/tex; mode=display">H(s)=\frac{\left\{\sum_{k=0}^{M} b_{k} s^{k}\right\}}{\left\{\sum_{k=0}^{N} a_{k} s^{k}\right\}}</script><h3 id="巴特沃斯滤波器"><a href="#巴特沃斯滤波器" class="headerlink" title="巴特沃斯滤波器"></a>巴特沃斯滤波器</h3><p>一个$N$ 阶低通巴特沃思滤波器频率响应的模平方是：</p><script type="math/tex; mode=display">|B(\mathrm{j} \omega)|^{2}=\frac{1}{1+\left(\mathrm{j} \omega / \mathrm{j} \omega_{c}\right)^{2 N}}</script><p> 它具有如下性质：</p><script type="math/tex; mode=display">B(s) B(-s)=\frac{1}{1+\left(s / \mathrm{j} \omega_{c}\right)^{2 N}}</script><p>$B(s)$的极点为：</p><script type="math/tex; mode=display">s_{p}=\omega_{c} \exp \left(\mathrm{j}\left[\frac{\pi(2 k+1)}{2 N}+\pi / 2\right]\right)</script><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240523152403227.png" alt="image-20240523152403227"></p><p>极点的性质为：</p><ol><li>在 $s$ 平面内，半径为 $\omega_{c}$ 的圆上，有 $2N$ 个极点在角度上呈等分割配置。</li><li>极点永远不会位于 $\mathrm{j}\omega$ 轴上，当 $N$ 为奇数时，在 $\sigma$ 轴上有极点；$N$ 为偶数时则没有。</li><li>相邻极点之间的角度差是 $\frac{\pi}{N}$ 弧度。</li></ol><h3 id="方框图表示"><a href="#方框图表示" class="headerlink" title="方框图表示"></a>方框图表示</h3><p>两个系统并联，总系统的系统函数$H(s)=H_1(s)+H_2(s)$。</p><p>两个系统级联，总系统的系统函数$H(s)=H_1(s)H_2(s)$。</p><h2 id="单边拉普拉斯变换"><a href="#单边拉普拉斯变换" class="headerlink" title="单边拉普拉斯变换"></a>单边拉普拉斯变换</h2><p>单边拉普拉斯变换在分析具有非零初始条件的(即系统最初不是松弛的)，由线性常系数微分方程所描述的因果系统时有很大的价值。</p><p>一个连续时间信号 $x(t)$的单边拉普拉斯变换 $\chi(s)$ 定义为:</p><script type="math/tex; mode=display">\chi(s) \triangleq \int_{0^{-}}^{\infty} x(t) \mathrm{e}^{-s t} \mathrm{~d} t</script><p>简化的符号表示为：$x(t) \stackrel{\mathcal U \mathcal{L}}{\longleftrightarrow} X(s)=\mathcal U \mathcal{L}\{x(t)\}$</p><p><strong>单边拉普拉斯变换 $\chi(s)$​ 的收敛域总是位于某个右半平面。</strong></p><p>单边拉普拉斯变换的逆变换为（和双边的拉普拉斯变换逆变换一样，只是不考虑$t&lt;0$的情况）：</p><script type="math/tex; mode=display">x(t)=u(t)\cdot \frac{1}{2 \pi \mathrm{j}} \int_{\sigma-\mathrm{j} \infty}^{\sigma+\mathrm{j} \infty} X(s) \mathrm{e}^{s t} \mathrm{~d} s</script><h3 id="单边拉普拉斯变换性质"><a href="#单边拉普拉斯变换性质" class="headerlink" title="单边拉普拉斯变换性质"></a>单边拉普拉斯变换性质</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240601221432305.png" alt="image-20240601221432305"></p><blockquote><p>注意：</p><script type="math/tex; mode=display">x_{1}(t) * x_{2}(t) \stackrel{\mathcal U \mathcal{L}}{\longleftrightarrow} \chi_{1}(s) \chi_{2}(s)</script><p>在$x_1(t)$和$x_2(t)$两者都在$t&lt;0$时为0的情况下才成立</p></blockquote><h3 id="求解微分方程"><a href="#求解微分方程" class="headerlink" title="求解微分方程"></a>求解微分方程</h3><p>单边拉普拉斯变换的一个主要应用是求解具有非零初始条件的线性常系数微分方程。</p><p>比如这样的一个因果线性时不变系统：</p><script type="math/tex; mode=display">\frac{\mathrm{d}^{2} y(t)}{\mathrm{d} t^{2}}+3 \frac{\mathrm{d} y(t)}{\mathrm{d} t}+2 y(t)=x(t)</script><p>初始条件为：$y\left(0^{-}\right)=\beta, \quad y^{\prime}\left(0^{-}\right)=\gamma$</p><p>那么对两边应用单边拉普拉斯变换可以得到</p><script type="math/tex; mode=display">s^{2} \mathcal Y(s)-\beta s-\gamma+3 s \mathcal Y(s)-3 \beta+2 \mathcal Y(s)=\frac{\alpha}{s}</script><p>也就是</p><script type="math/tex; mode=display">\mathcal Y(s)=\frac{\beta(s+3)}{(s+1)(s+2)}+\frac{\gamma}{(s+1)(s+2)}+\frac{\alpha}{s(s+1)(s+2)}</script><ul><li>右边前两项代表的是输入（$\alpha=0$）的时候系统响应的单边拉普拉斯变换。这个响应被称为<strong>零输入响应</strong>。</li><li>右边最后一项代表在初始松弛条件下的响应（$\beta=\gamma=0$）时系统响应的单边拉普拉斯变换。这个响应被称为<strong>零状态响应</strong>。</li></ul><p>然后假设$\alpha=2, \beta=3 ,\gamma=-5$。那么$\mathcal Y(s)=\frac{1}{s}-\frac{1}{s+1}+\frac{3}{s+2}$​。</p><p>对$\mathcal Y(s)$进行反变换，就可以得到$y(t)=\left[1-\mathrm{e}^{-t}+3 \mathrm{e}^{-2 t}\right] u(t), \quad t&gt;0$</p><h1 id="z-变换"><a href="#z-变换" class="headerlink" title="$z$变换"></a>$z$变换</h1><p>$z$​变换在离散时间情况下与拉普斯变换相对应。</p><h2 id="z-变换-1"><a href="#z-变换-1" class="headerlink" title="$z$变换"></a>$z$变换</h2><p>一个离散时间信号$x[n]$的$z$​变换定义为：</p><script type="math/tex; mode=display">X(z) \triangleq \sum_{n=-\infty}^{+\infty} x[n] z^{-n}</script><p>其中$z$是一个复变量。有时为了方便, 也将 $ x[n] $ 的 $ z $ 变换写为 $ Z\{x[n]\} $, 而 $ x[n] $ 和它的 $ z $ 变换之间的关系记为$x[n] \stackrel{z}{\longleftrightarrow} X(z)$。</p><p>或者$z$变换也可以等效为：</p><script type="math/tex; mode=display">X\left(r \mathrm{e}^{j \omega}\right)=\sum_{n=-\infty}^{+\infty}\left\{x[n] r^{-n}\right\} \mathrm{e}^{-j \omega n}</script><p>可见， $X\left(r \mathrm{e}^{\mathrm{j} \omega}\right)$  就是序列  $x[n]$  乘以实指数  $r^{-n}$  后的傅里叶变换, 即：</p><script type="math/tex; mode=display">X\left(r \mathrm{e}^{\mathrm{j} \omega}\right)=\mathcal{F}\left\{x[n] r^{-n}\right\}</script><p>对于某一序列的$z$变换，存在着某一个$z$值的范围,对该范围内的$z$，$X(z)$​收敛。和拉普拉斯变换一样，这样一些值的范围称为收敛域（ROC）。如果收敛域包括单位圆，则傅里叶变换也收敛。<strong>和拉普拉斯变换一样，$z$​​变换的表述既要求它的代数表示式,又要求相应的收敛域。</strong></p><p>只要$x[n]$是实指数或复指数的线性组合，$X(z)$就一定是有理的。</p><h2 id="z-变换的收敛域"><a href="#z-变换的收敛域" class="headerlink" title="$z$变换的收敛域"></a>$z$变换的收敛域</h2><p>收敛域有以下一系列性质：</p><ol><li>$X(z) $ 的收敛域是在 $ z $​ 平面内以原点为中心的圆环。 </li><li>收敛域内不包含任何极点。</li><li>如果 $ x[n] $ 是有限长序列, 那么收收敛就是整个 $ z $ 平面, 可能除去 $ z=0 $ 和/或 $ z=\infty $ 。<ul><li>在 $N_{1}$ 为负值且 $N_{2}$ 为正值时，收敛域不包括 $z=0$ 和 $z=\infty$ 。</li><li>如果 $N_{1}$ 为零或为正值，那么式中仅有 $z$ 的负幂次项，这时收敛域就可以包括 $z=\infty$ </li><li>而如果 $N_{2}$ 为零或为负值，式中就仅有 $z$ 的正幂次项，收敛域就可以包括 $z=0$​ 。</li></ul></li><li>如果 $x[n]$ 是一个右边序列，并且 $|z|=r_{0}$ 的圆位于收敛域内，那么 $|z|&gt;r_{0}$ 的全部有限 $z$ 值都一定在这个收敛域内。<ul><li>一般来说，右边序列的收敛域不包括无限远点。</li><li>然而，对于因果序列，即 $n&lt;0$ 时序列值为零的序列，$N$ 一定为非负，因此收敛域一定包括 $z=\infty$​。</li></ul></li><li>如果 $x[n]$ 是一个左边序列，而且 $|z|=r_{0}$ 的圆位于收敛域内，那么满足 $0&lt;|z|&lt;r_{0}$ 的全部 $z$ 值都一定在这个收敛域内。<ul><li>一般左边序列的 $z$ 变换，其收敛域不包括 $z=0$，然而如果 $N_2 \leq 0$（即 $n&gt;0$ 时 $x[n]=0$），那么收敛域一定包括 $z=0$​。</li></ul></li><li>如果 $x[n]$ 是双边序列，而且 $|z|=r_0$ 的圆位于收敛域内，那么该收敛域在 $z$ 域中一定是包含 $|z|=r_0$ 这一圆环的环状区域。<ul><li>双边序列的收敛域可以把 $x[n]$ 表示成一个右边信号和一个左边信号之和来确定。整个序列的收敛域就是这两部分收敛域的相交。</li></ul></li><li>如果 $x[n]$ 的 $z$ 变换 $X(z)$​ 是有理的，那么它的收敛域就被极点所界定，或者延伸至无限远。</li><li>如果 $x[n]$ 的 $z$ 变换 $X(z)$ 是有理的，并且 $x[n]$ 是右边序列，那么收敛域就位于 $z$ 平面内最外层极点的外边，也就是半径等于 $X(z)$ 极点中最大模值的圆的外边。而且，若 $x[n]$ 是因果序列，即 $x[n]$ 为 $n&lt;0$ 时等于零的右边序列，那么收敛域也包括 $z=\infty$​。<ul><li>对于具有有理变换的右边序列，它的全部极点比收敛域中的任何一点都更加靠拢原点。</li></ul></li><li>如果 $x[n]$ 的 $z$ 变换 $X(z)$ 是有理的，并且 $x[n]$ 是左边序列，那么收敛域就位于 $z$ 平面内最里层的非零极点的里边，也就是半径等于 $X(z)$ 中除去 $z=0$ 的极点中最小模值的圆的里边，并且向内延伸到可能包括 $z=0$。特别是，若 $x[n]$ 是反因果序列，即 $x[n]$ 为 $n&gt;0$ 时等于零的左边序列，那么收敛域也包括 $z=0$。<ul><li>对于左边序列，除了可能在 $z=0$ 的极点外，$X(z)$ 的极点都比收敛域中任何一点更加远离原点。</li></ul></li></ol><h2 id="z-逆变换"><a href="#z-逆变换" class="headerlink" title="$z$逆变换"></a>$z$逆变换</h2><p>$z$逆变换写为：</p><script type="math/tex; mode=display">x[n]=\frac{1}{2 \pi} \int_{2 \pi} X\left(r \mathrm{e}^{\mathrm{j} \omega}\right)\left(r \mathrm{e}^{\mathrm{j} \omega}\right)^{n} \mathrm{~d} \omega</script><p>也可以写为：</p><script type="math/tex; mode=display">x[n]=\frac{1}{2 \pi \mathrm{j}} \oint X(z) z^{n-1} \mathrm{~d} z</script><p>式中 $ \oint $ 记为在半径为 $ r $, 以原点为中心的封闭圆上沿逆时针方向环绕一周的积分。</p><p>还有另外几个方法可以求得逆变换：</p><ol><li>对于一个有理$z$变换，可以首先将它进行部分分式展开，然后逐项求其逆变换</li><li>对$X(z)$进行幂级数展开（实际上$z$变换就是涉及$z$的正幂和负幂的一个幂级数），这个幂级数的系数就是序列值$x[n]$。</li></ol><h2 id="零-极点图-1"><a href="#零-极点图-1" class="headerlink" title="零-极点图"></a>零-极点图</h2><p>在离散时间情况下，利用$z$平面内零极点向量也能对傅里叶变换进行几何求值。然而，因为在这种情况下，有理函数是在$|z|=1$的单位圆上进行求值，所以<strong>应该考虑从极点和零点到这一单位圆上的向量,而不是到虚轴上的向量</strong>。（因为$z=e^{jw}$的时候是在单位圆上运动）</p><p>同样：</p><ul><li>$X(z_1)$ 的模就是各零点向量（从各个零点到 $z_1$ 的向量）长度乘积的 $M$ 倍被各极点向量（从各个极点到 $z_1$ 的向量）长度的积相除。（极点用$\times$表示）</li><li>复数 $X(z_1)$ 的相角则是这些零点向量相角的和减去这些极点向量相角的和。如果在上式中比例因子 $M$ 是负的，则对应有一个附加相角 $\pi$。（零点用$\circ$表示）</li></ul><h2 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240616215800082.png" alt="image-20240616215800082"></p><h2 id="z-变换对"><a href="#z-变换对" class="headerlink" title="$z$变换对"></a>$z$变换对</h2><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240616215900689.png" alt="image-20240616215900689"></p><h2 id="利用-z-​变换分析与表征线性时不变系统"><a href="#利用-z-​变换分析与表征线性时不变系统" class="headerlink" title="利用$z$​变换分析与表征线性时不变系统"></a>利用$z$​变换分析与表征线性时不变系统</h2><p>$H(z)$称为系统的系统函数或转移函数。一个系统的很多性质都能够直接与系统函数的零极点和收敛域的性质相联系。</p><h3 id="因果性-1"><a href="#因果性-1" class="headerlink" title="因果性"></a>因果性</h3><p>一个离散时间线性时不变系统，当且仅当它的系统函数的收敛域在某个圆的外边，<strong>且包括无限远点时</strong>，该系统就是因果的。</p><p>一个具有<strong>有理</strong>系统函数 $H(z)$ 的线性时不变系统是因果的，当且仅当满足以下条件：</p><ol><li><strong>收敛域条件</strong>：收敛域位于最外层极点外边某个圆的外边。</li><li><strong>多项式阶次条件</strong>：若 $H(z)$ 表示成$z$的多项式之比，其分子的阶次不能高于分母的阶次。</li></ol><h3 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h3><p>一个线性时不变系统是稳定的，当且仅当它的系统函数 $H(z)$ 的收敛域包括单位圆 $|z| = 1$。</p><p>一个具有有理系统函数的因果线性时不变系统是稳定的，当且仅当系统函数 $H(z)$ 的全部极点都位于单位圆内，即全部极点的模均小于1。 </p><h3 id="由线性常系数差分方程表征的线性时不变系统"><a href="#由线性常系数差分方程表征的线性时不变系统" class="headerlink" title="由线性常系数差分方程表征的线性时不变系统"></a>由线性常系数差分方程表征的线性时不变系统</h3><p>现考虑一个线性时不变系统，其输入、输出满足如下线性常系数差分方程：</p><script type="math/tex; mode=display">\sum_{k=0}^{N} a_{k} y[n-k]=\sum_{k=0}^{M} b_{k} x[n-k]</script><p>则系统函数为：</p><script type="math/tex; mode=display">H(z)=\frac{Y(z)}{X(z)}=\frac{\sum_{k=0}^{M} b_{k} z^{-k}}{\sum_{k=0}^{N} a_{k} z^{-k}}</script><p>并且系统函数是有理的。</p><h2 id="单边-z-变换"><a href="#单边-z-变换" class="headerlink" title="单边$z$变换"></a>单边$z$变换</h2><p>到目前为止，本章所考虑的$z$变换一般都称为双边$z$变换。与拉普拉斯变换一样,也有另一种形式称为单边$z$变换。</p><p>单边$z$变化定义为：</p><script type="math/tex; mode=display">X(z)=\sum_{n=0}^{\infty} x[n] z^{-n}</script><p>简化符号记为：</p><script type="math/tex; mode=display">x[n] \stackrel{\mathcal U Z}{\longleftrightarrow} X(z)=\mathcal U Z\{x[n]\}</script><p>单边$z$变换与双边变换的差别在于，求和仅在$n$的非负值上进行,而不考虑$n&lt;0$时$x[n]$是否为零。因此，$x[n]$的单边$z$​变换就能看成$x[n]u[n]$​的双边变换。</p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>同理，单边$z$​逆变换的计算也基本上与双边变换相同，但是要考虑到<strong>对单边变换而言，其收敛域总是位于某个圆的外边</strong>。</p><p>通过$z$变换的幂级数展开式的系数来求逆变换的方法，也能够用于单边变换的情况。不过，在单边情况下必须满足的一种限制是，<strong>变换的幂级数展开式中不能包括$z$的正幂次项</strong>。</p><p>一个$z$的有理函数若能成为一个单边变换，<strong>其分子的阶次必须不能高于分母的阶次</strong>。</p><h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h3><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/信号与系统/image-20240620083036219.png" alt="image-20240620083036219"></p><h3 id="利用单边-z-​变换求解差分方程"><a href="#利用单边-z-​变换求解差分方程" class="headerlink" title="利用单边$z$​变换求解差分方程"></a>利用单边$z$​变换求解差分方程</h3><p>考虑由下列差分方程描述的因果线性时不变系统：</p><script type="math/tex; mode=display">y[n]+3 y[n-1]=x[n]</script><p>假设输入为$x[n]=\alpha u[n]$，初始条件为$y[-1]=\beta$。对两边进行单边$z$变换：</p><script type="math/tex; mode=display">\mathcal Y(z)+3 \beta+3 z^{-1} \mathcal Y(z)=\frac{\alpha}{1-z^{-1}}</script><p>解得：</p><script type="math/tex; mode=display">\mathcal Y(z)=-\frac{3 \beta}{1+3 z^{-1}}+\frac{\alpha}{\left(1+3 z^{-1}\right)\left(1-z^{-1}\right)}</script><p>右边的第一项是零输入响应，即$\alpha=0$时的响应；第二项是零状态响应，即$\beta=0$时候的响应。</p><p>最后, 对于任意 $\alpha$ 和 $\beta$ 值, 都能将上式的 $\mathcal Y(z)$ 展开成部分分式, 然后求（单边$z$）逆变换而得到 $y[n]$ 。</p><h1 id="部分分式分解"><a href="#部分分式分解" class="headerlink" title="部分分式分解"></a>部分分式分解</h1><p>考虑一个有理函数：</p><script type="math/tex; mode=display">H(v)=\frac{\beta_{m} v^{m}+\beta_{m-1} v^{m-1}+\cdots+\beta_{1} v+\beta_{0}}{\alpha_{n} v^{n}+\alpha_{n-1} v^{n-1}+\cdots+\alpha_{1} v+\alpha_{0}}</script><p>对于连续时间傅里叶分析来说，$v$ 就相当于 $\mathrm{j} \omega$；而对于拉普拉斯变换来说，$v$ 就对应于复变量 $s$。在离散时间傅里叶分析中，通常将 $v$ 取为 $\mathrm{e}^{-\mathrm{j} \omega}$；而对于Z变换，则可用 $z^{-1}$ 或者 $z$ 取代 $v$。</p><h2 id="连续时间信号与系统"><a href="#连续时间信号与系统" class="headerlink" title="连续时间信号与系统"></a>连续时间信号与系统</h2><p>将$H(v)$转换为第一种标准形式：</p><script type="math/tex; mode=display">G(v)=\frac{b_{n-1} v^{n-1}+b_{n-2} v^{n-2}+\cdots+b_{1} v+b_{0}}{v^{n}+a_{n-1} v^{n-1}+\cdots+a_{1} v+a_{0}}</script><p>步骤为：</p><ol><li><p>将 $ H(v) $ 的分子分母同除以 $ a_{n}$​。得到</p><script type="math/tex; mode=display">H(v)=\frac{\gamma_{m} v^{m}+\gamma_{m-1} v^{m-1}+\cdots+\gamma_{1} v+\gamma_{0}}{v^{n}+a_{n-1} v^{n-1}+\cdots+a_{1} v+a_{0}}\\\begin{aligned}\gamma_{m} & =\frac{\beta_{m}}{\alpha_{n}}, & \gamma_{m-1}=\frac{\beta_{m-1}}{\alpha_{n}}, & \ldots \\a_{n-1} & =\frac{\alpha_{n-1}}{\alpha_{n}}, & a_{n-2}=\frac{\alpha_{n-2}}{\alpha_{n}}, & \ldots\end{aligned}</script></li><li><p>若 $ m&lt;n $, 则 $ H(v) $ 称为严格真的有理函数。在这种情况下, 令 $ b_{0}=\gamma_{0}, b_{1}=\gamma_{1}, \cdots,b_{m}=\gamma_{m}$；然而，如果 $H(v)$ 不是真有理函数（即 $m \geq n$），可以通过基本的计算，将 $H(v)$ 写成一个 $v$ 的多项式与一个严格真有理函数之和：</p><script type="math/tex; mode=display">\begin{aligned}H(v)= & c_{m-n} v^{m-n}+c_{m-n-1} v^{m-n-1}+\cdots+c_{1} v+c_{0} \\& +\frac{b_{n-1} v^{n-1}+b_{n-2} v^{n-2}+\cdots+b_{1} v+b_{0}}{v^{n}+a_{n-1} v^{n-1}+\cdots+a_{1} v+a_{0}}\end{aligned}</script><p>然后将这个式子和上一个式子同乘分母后对比系数得到一组方程，解出$c_0,\cdots,c_{m-n}$以及$b_{0},\cdots,b_{n-1}$。</p></li></ol><p>那么若标准形式的$G(v)$的分母有不同的根  $\rho_{1}, \cdots, \rho_{r}$  分别具有 $\sigma_{1}, \cdots, \sigma_{r}$  次幂时, 那么:</p><script type="math/tex; mode=display">G(v)=\frac{b_{n-1} v^{n-1}+\cdots+b_{1} v+b_{0}}{\left(v-\rho_{1}\right)^{\sigma_{1}}\left(v-\rho_{2}\right)^{\sigma_{2}} \cdots\left(v-\rho_{r}\right)^{\sigma_{r}}}</script><p>则$G(z)$具有部分分式展开的形式为：</p><script type="math/tex; mode=display">\begin{aligned}G(v)= & \frac{A_{11}}{v-\rho_{1}}+\frac{A_{12}}{\left(v-\rho_{1}\right)^{2}}+\cdots+\frac{A_{1 \sigma_{1}}}{\left(v-\rho_{1}\right)^{\sigma_{1}}} \\& +\frac{A_{21}}{v-\rho_{2}}+\cdots+\frac{A_{2 \sigma_{2}}}{\left(v-\rho_{2}\right)^{\sigma_{2}}} \\& +\cdots+\frac{A_{r 1}}{v-\rho_{r}}+\cdots+\cdots+\frac{A_{r \sigma_{r}}}{\left(v-\rho_{r}\right)^{\sigma_{r}}} \\= & \sum_{i=1}^{r} \sum_{k=1}^{\sigma_{i}} \frac{A_{i k}}{\left(v-\rho_{i}\right)^{k}}\end{aligned}</script><p>其中$A_{i k}$可以用以下公式算出：</p><script type="math/tex; mode=display">A_{i k}=\left.\frac{1}{\left(\sigma_{i}-k\right)!}\left[\frac{\mathrm{d}^{\sigma_{i}-k}}{\mathrm{~d} v^{\sigma_{i}-k}}\left[\left(v-\rho_{i}\right)^{\sigma_{i}} G(v)\right]\right]\right|_{v=\rho_{i}}</script><blockquote><p>这是因为极限存在并等于$A_{ik}$</p></blockquote><h2 id="离散时间信号与系统"><a href="#离散时间信号与系统" class="headerlink" title="离散时间信号与系统"></a>离散时间信号与系统</h2><p>将$H(v)$转换为另一种标准形式：</p><script type="math/tex; mode=display">G(v)=\frac{d_{n-1} v^{n-1}+\cdots+d_{1} v+d_{0}}{f_{n} v^{n}+\cdots+f_{1} v+1}</script><p>这种形式的 $ G(v) $，可通过把第一种标准形式中的 $ G(v) $ 分子分母同除以 $ a_{0} $ 而得到。 其的因式分解形式为：</p><script type="math/tex; mode=display">G(v)=\sum_{i=1}^{r} \sum_{k=1}^{\sigma_{i}} \frac{B_{i k}}{\left(1-\rho_{i}^{-1} v\right)^{k}}</script><blockquote><p>$1-\rho_i^{-1}v$这样的形式更容易找到其的$z$变换对</p></blockquote><p>其中$B_{ik}$由下式计算得到：</p><script type="math/tex; mode=display">B_{i k}=\left.\frac{1}{\left(\sigma_{i}-k\right)!}\left(-\rho_{i}\right)^{\sigma_{i}-k}\left[\frac{d^{\sigma_{i}-k}}{\mathrm{~d} v^{\sigma_{i}-k}}\left[\left(1-\rho_{i}^{-1} v\right)^{\sigma_{i}} G(v)\right]\right]\right|_{v=\rho_{i}}</script>]]></content>
      
      
      <categories>
          
          <category> 我重生了，重生在考试前一天 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始配置mindtorch环境</title>
      <link href="/post/2529764766.html"/>
      <url>/post/2529764766.html</url>
      
        <content type="html"><![CDATA[<p>本文的linux（昇腾）服务器是一个刚安装好Ubuntu20.04 LST的裸机，具体的信息如下：</p><ul><li>Distributor ID: Ubuntu</li><li>Description:    Ubuntu 20.04.5 LTS</li><li>Release:        20.04</li><li>Codename:       focal</li><li><strong>NPU：910A</strong></li></ul><p>本文将会一步步展示如何完整配置一个完整的，可以运行mindtorch（0.3.0）的环境。</p><h1 id="要安装的依赖"><a href="#要安装的依赖" class="headerlink" title="要安装的依赖"></a>要安装的依赖</h1><p>为了配置一个可以运行mindtorch的环境，需要安装以下的依赖：</p><ol><li>Miniconda：用于管理Python环境</li><li>Python</li><li>NPU固件与驱动</li><li>Cann软件包：昇腾AI处理器配套软件包</li><li>Mindspore</li><li>Mindtorch</li></ol><p>下面逐个来安装</p><p>参考链接：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/671950495">Miniconda安装</a></li><li><a href="https://www.hiascend.com/document/detail/zh/canncommercial/80RC22/softwareinst/instg/instg_0003.html?Mode=PmIns&amp;OS=Ubuntu&amp;Software=cannToolKit">Cann安装</a></li><li><a href="https://www.mindspore.cn/install#安装python">Mindspore安装</a></li><li><a href="https://mindtorch.readthedocs.io/zh-cn/latest/docs/Install.html">Mindtorch安装</a></li></ol><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先需要找到一个文件夹，用于放置安装包，本文选择在<code>~/packages</code>下放置安装包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">mkdir packages</span><br><span class="line">cd packages</span><br></pre></td></tr></table></figure><h2 id="Miniconda"><a href="#Miniconda" class="headerlink" title="Miniconda"></a>Miniconda</h2><p>这里下载最新的Miniconda。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到你放置安装包的文件夹中</span></span><br><span class="line">cd ~/packages</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载最新的安装包</span></span><br><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-$(arch).sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行安装脚本</span></span><br><span class="line">sh Miniconda3-latest-Linux-$(arch).sh</span><br></pre></td></tr></table></figure><p>然后按照安装脚本里的提示安装即可。一直回车，直至让选择yes/no（是否安装），选择yes，再次回车，第二次让选择yes/no（决定是否在启动时进入base环境），选择yes，至此Miniconda安装完毕。</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>重新打开一个终端窗口，确定能在行前看到（base）的字样。这样就说明成功安装了conda并激活了conda的环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) shuziren@ubuntu:~$</span><br></pre></td></tr></table></figure><p>然后用conda创建一个虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n iplap python==3.10 -y</span><br></pre></td></tr></table></figure><p>这创建了一个Python版本为3.10的，名为iplap的虚拟环境。然后就可以激活这个虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate iplap</span><br></pre></td></tr></table></figure><h2 id="NPU固件与驱动"><a href="#NPU固件与驱动" class="headerlink" title="NPU固件与驱动"></a>NPU固件与驱动</h2><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>执行命令安装所需依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y dkms gcc linux-header-$(uname -r)</span><br></pre></td></tr></table></figure><p>暂时跳过了<code>linux-header-$(uname -r)</code>，因为没有对应版本的。</p><h3 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h3><p>然后需要安装两个东西，一个是驱动，一个是固件。可以参考：<a href="https://www.hiascend.com/document/detail/zh/canncommercial/80RC2/softwareinst/instg/instg_0001.html?Mode=PmIns&amp;OS=Ubuntu&amp;Software=cannToolKit">华为官方文档</a></p><p>这里安装的是Cann 8.0rc2的固件和驱动。</p><p>在这个网站：<a href="https://www.hiascend.com/hardware/firmware-drivers/community?product=4&amp;model=10&amp;cann=7.0.0.alpha003&amp;driver=1.0.21.alpha，找到两个包：">https://www.hiascend.com/hardware/firmware-drivers/community?product=4&amp;model=10&amp;cann=7.0.0.alpha003&amp;driver=1.0.21.alpha，找到两个包：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ascend-hdk-910-npu-driver 23.0.0 linux-aarch64.run</span><br><span class="line">Ascend-hdk-910-npu-firmware 7.1.0.3.220.run</span><br></pre></td></tr></table></figure><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/从0开始配置mindtorch环境/image-20240915102613515.png" alt="image-20240915102613515"></p><h3 id="添加HwHiAiUser"><a href="#添加HwHiAiUser" class="headerlink" title="添加HwHiAiUser"></a>添加HwHiAiUser</h3><p>为了安装固件和驱动，需要新添加一个名为HwHiAiUser的用户，在root用户模式下，用如下命令新加一个用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd HwHiAiUser</span><br><span class="line">useradd -g HwHiAiUser -d /home/HwHiAiUser -m HwHiAiUser -s /bin/bash</span><br></pre></td></tr></table></figure><p>然后需要将自己的用户（我这里是shuziren）添加到HwHiAiUser组中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -a -G HwHiAiUser shuziren</span><br></pre></td></tr></table></figure><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p><a href="https://www.hiascend.com/document/detail/zh/canncommercial/80RC22/softwareinst/instg/instg_0003.html?Mode=PmIns&amp;OS=Ubuntu&amp;Software=cannToolKit">参考链接</a></p><p>给软件包加上执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Ascend-hdk-910-npu-driver 23.0.0 linux-aarch64.run</span><br><span class="line">chmod +x Ascend-hdk-910-npu-firmware 7.1.0.3.220.run</span><br></pre></td></tr></table></figure><p>然后在安装前进行软件包的自检</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Ascend-hdk-910-npu-driver 23.0.0 linux-aarch64.run --check</span><br><span class="line">./Ascend-hdk-910-npu-firmware 7.1.0.3.220.run --check</span><br></pre></td></tr></table></figure><p>最后在<mark>root</mark>用户下进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Ascend-hdk-910-npu-driver 23.0.0 linux-aarch64.run --full --install-for-all</span><br><span class="line">./Ascend-hdk-910-npu-firmware 7.1.0.3.220.run --full</span><br></pre></td></tr></table></figure><blockquote><p>如果显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR]The list of missing tools: lspci,ifconfig,</span><br></pre></td></tr></table></figure><p>则安装一下软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y net-tools pciutils</span><br></pre></td></tr></table></figure></blockquote><ol><li><p>若系统出现如下关键回显信息，则表示驱动（driver）安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Driver package installed successfully!</span><br></pre></td></tr></table></figure></li><li><p>若系统出现如下关键回显信息，表示固件安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Firmware package installed successfully! Reboot now or after driver installation for the installation/upgrade to take effect</span><br></pre></td></tr></table></figure></li></ol><h3 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h3><p>然后需要重启一下系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>最后用<code>npu-smi info</code>检查一下是否安装成功了。</p><h2 id="Cann软件包"><a href="#Cann软件包" class="headerlink" title="Cann软件包"></a>Cann软件包</h2><p>然后给需要使用Cann的用户，比如我这是<code>shuziren</code>，安装Cann软件包。<mark>现在不是用root用户，而是用需要使用Cann的用户登录。</mark></p><h3 id="安装依赖-2"><a href="#安装依赖-2" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>首先要安装依赖：</p><ol><li><p>执行如下命令，安装软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y gcc g++ make cmake libsqlite3-dev zlib1g-dev libssl-dev libffi-dev net-tools</span><br></pre></td></tr></table></figure></li><li><p>检查系统是否安装满足版本要求的Python开发环境（支持Python3.7.<em>x</em>至3.10.<em>x</em>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 --version</span><br><span class="line">pip3 --version #如果没装需要装一下</span><br></pre></td></tr></table></figure><p>符合要求则执行下一步。</p></li><li><p>执行如下命令安装所需的Python第三方库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install attrs cython numpy==1.24 decorator sympy cffi pyyaml pathlib2 psutil protobuf==3.20 scipy requests absl-py --user</span><br></pre></td></tr></table></figure></li></ol><h3 id="准备安装包-1"><a href="#准备安装包-1" class="headerlink" title="准备安装包"></a>准备安装包</h3><p>在<a href="https://www.hiascend.com/developer/download/community/result?module=cann&amp;cann=8.0.RC2.beta1">官网</a>上找到8.0.RC2.beta1版本的安装包，对应服务器上的芯片的版本（例如我这里是910，就选择了-910，并且我是aarch64的版本的）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ascend-cann-kernels-910_8.0.Rc2_linux.run</span><br><span class="line">Ascend-cann-toolkit_8.0.Rc2_linux-aarch64.run</span><br></pre></td></tr></table></figure><p>可以用<code>wget</code>来下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -O Ascend-cann-kernels-910_8.0.RC2_linux.run https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%208.0.RC2/Ascend-cann-kernels-910_8.0.RC2_linux.run?response-content-type=application/octet-stream</span><br><span class="line">wget -O Ascend-cann-toolkit_8.0.RC2_linux-aarch64.run https://ascend-repo.obs.cn-east-2.myhuaweicloud.com/CANN/CANN%208.0.RC2/Ascend-cann-toolkit_8.0.RC2_linux-aarch64.run?response-content-type=application/octet-stream</span><br></pre></td></tr></table></figure><h3 id="安装前检查"><a href="#安装前检查" class="headerlink" title="安装前检查"></a>安装前检查</h3><p>在安装前运行check检查一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./Ascend-cann-kernels-910_8.0.RC2_linux.run</span><br><span class="line">./Ascend-cann-kernels-910_8.0.RC2_linux.run --check</span><br><span class="line"></span><br><span class="line">chmod +x Ascend-cann-toolkit_8.0.RC2_linux-aarch64.run</span><br><span class="line">./Ascend-cann-toolkit_8.0.RC2_linux-aarch64.run --check</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>先在<code>~/</code>下创建一个名为Ascend的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./Ascend-cann-toolkit_8.0.RC2_linux-aarch64.run --install</span><br><span class="line">./Ascend-cann-kernels-910_8.0.RC2_linux.run --install</span><br></pre></td></tr></table></figure><p>然后添加一下环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;source ~/Ascend/ascend-toolkit/set_env.sh&#x27; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="安装Mindspore"><a href="#安装Mindspore" class="headerlink" title="安装Mindspore"></a>安装Mindspore</h2><p>激活之前创建的conda环境后，先安装几个软件包：</p><p>还需要pip安装几个包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall te topi hccl -y</span><br><span class="line">pip install sympy</span><br><span class="line">pip install ~/Ascend/ascend-toolkit/latest/lib64/te-*-py3-none-any.whl</span><br><span class="line">pip install ~/Ascend/ascend-toolkit/latest/lib64/hccl-*-py3-none-any.whl</span><br></pre></td></tr></table></figure><p>然后用如下指令就安装Mindspore：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MS_VERSION=2.3.1</span><br><span class="line">pip install https://ms-release.obs.cn-north-4.myhuaweicloud.com/$&#123;MS_VERSION&#125;/MindSpore/unified/aarch64/mindspore-$&#123;MS_VERSION/-/&#125;-cp310-cp310-linux_aarch64.whl --trusted-host ms-release.obs.cn-north-4.myhuaweicloud.com -i https://repo.huaweicloud.com/repository/pypi/simple</span><br></pre></td></tr></table></figure><p>然后验证一下是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import mindspore;mindspore.set_context(device_target=&#x27;Ascend&#x27;);mindspore.run_check()&quot;</span><br></pre></td></tr></table></figure><h2 id="安装Mindtorch"><a href="#安装Mindtorch" class="headerlink" title="安装Mindtorch"></a>安装Mindtorch</h2><p>安装最新版本的mindtorch：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://openi.pcl.ac.cn/OpenI/MSAdapter.git</span><br><span class="line">cd MSAdapter</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm设置运行配置</title>
      <link href="/post/1176275894.html"/>
      <url>/post/1176275894.html</url>
      
        <content type="html"><![CDATA[<p>Pycharm中运行python程序的时候不会调用<code>source ~/.bashrc</code>，所以有很多环境变量可能没有。</p><p>所以可以提前开一个终端，然后将所有环境变量保存下来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env &gt; ./environment.env</span><br></pre></td></tr></table></figure><p>然后再在Pycharm运行配置中填入<code>.env</code>文件的路径。方便的加载环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Pycharm中重命名项目</title>
      <link href="/post/3715959065.html"/>
      <url>/post/3715959065.html</url>
      
        <content type="html"><![CDATA[<h1 id="噩梦伊始"><a href="#噩梦伊始" class="headerlink" title="噩梦伊始"></a>噩梦伊始</h1><p>在Pycharm中创建一个项目之后，我们可能对自己取的项目名称不满意：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221248828.png" alt="image-20240904221248828"></p><p>比如，此时我想把名称A改为名称B。此时我们会发现，在Pycharm中有一个重命名项目的功能：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221350510.png" alt="image-20240904221350510"></p><p>在执行完两个重构：重命名项目和重命名目录之后，可以发现如我们所愿，项目和目录名称都变了。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221506234.png" alt="image-20240904221506234"></p><p>但这时如果运行原来的程序，会直接报错运行出错：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221654579.png" alt="image-20240904221654579"></p><h1 id="匆忙逃窜"><a href="#匆忙逃窜" class="headerlink" title="匆忙逃窜"></a>匆忙逃窜</h1><p>这是因为，目录名称改了，但是工作目录的名称没改。也就是运行配置没改。</p><p>此时就需要编辑配置：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221638157.png" alt="image-20240904221638157"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904221719165.png" alt="image-20240904221719165"></p><p>发现有三个地方需要更改：</p><ol><li>需要将第一个解释器改为<code>~/PycharmProjects/B/.venv/bin.python</code></li><li>需要更改脚本路径为<code>/Users/wanhuabai/PycharmProjects/B/.venv/bin.python</code></li><li>需要更改工作目录为<code>/Users/wanhuabai/PycharmProjects/B</code></li></ol><p>第二三项可以直接点击旁边的文件夹图标进行更改，而第一项的修改比较麻烦。</p><p>首先进入设置，改掉Python解释器的路径。在这个界面点击全部显示。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222247329.png" alt="image-20240904222247329"></p><p>先移除解释器：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222331858.png" alt="image-20240904222331858"></p><p>然后再添加解释器：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222354808.png" alt="image-20240904222354808"></p><p>更改完这个之后运行配置中的解释器也会跟着改变。现在就可以正常运行项目了：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222459668.png" alt="image-20240904222459668"></p><h1 id="重获新生"><a href="#重获新生" class="headerlink" title="重获新生"></a>重获新生</h1><p>但此时还没完，因为现在打开终端，会发现找不到虚拟环境中的<code>pip</code>。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222758867.png" alt="image-20240904222758867"></p><p>同时查看<code>VIRTUAL_ENV</code>环境变量，会发现它没有变化：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904222842882.png" alt="image-20240904222842882"></p><p>这是因为这个环境变量的地址是硬编码在<code>./.venv/bin/activate</code>等文件中的，需要手动进行替换。打开文件，可以发现这里的路径还是没更改项目名称前的路径名。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904223043500.png" alt="image-20240904223043500"></p><p>使用<code>Pycharm</code>的在文件中替换的功能：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904223027304.png" alt="image-20240904223027304"></p><p>将<code>./.venv/bin/</code>下所有错误的路径都替换掉：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904223242875.png" alt="image-20240904223242875"></p><p>一键替换全部之后。再重新打开终端，可以发现一切都正常了：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/在Pycharm中重命名项目/image-20240904223350052.png" alt="image-20240904223350052"></p><p>至此整个重命名项目的过程就结束了，推荐用<code>anaconda</code>或者<code>miniconda</code>来管理环境，就不会遇到<code>.venv</code>那么折腾的报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体素、网格与点云</title>
      <link href="/post/2370170588.html"/>
      <url>/post/2370170588.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上的关于体素（Voxel）、网格（Mesh）和点云（Point Cloud）的资料比较分散，而它们又是三维重建中很基础且重要的内容。故写了一篇文章总结了一下网上的相关资料。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/体素、网格与点云/v2-5baf89ccc42a1ce346121266bbdacf1f_1440w.png" alt="什么是体素(Voxel)?"></p><blockquote><p>一个三维空间中的物体在计算机中可以有不同的表达形式，图a是用点云（Point Cloud）表达，图b是用体素（Voxel）表达，图c是用网格（Mesh）表达</p></blockquote><h1 id="体素"><a href="#体素" class="headerlink" title="体素"></a>体素</h1><p>二维的图片可以用一个个像素来表示，将二维图片看成一个$n\times n$的矩阵，则矩阵中存储的每一个数就是一个像素。如果这个矩阵仅存储0和1，那就有一张黑白的图片；如果这个矩阵每个数都是8位无符号数，那么就有了一张灰度图像。</p><p>三维中的物体也可以用同样的思想来表示，即将一个三维的物体看成$n\times n\times n$的矩阵，矩阵中存储的每一个数就是一个体素。同样的，这个体素可以只有1位，也可以是8位或32位数。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/体素、网格与点云/image-20240808143801248.png" alt="image-20240808143801248"></p><h1 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h1><p>多边形网格，也被称为“Mesh”，这里简称为网格，是计算机图形学中用于为各种不规则物体建立模型的一种数据结构。现实世界中的物体表面直观上看都是由曲面构成的，而在计算机里，曲面是由无数个小的多边形面片去组成的。Mesh既可以由三角形组成，也可以由其他平面形状如四边形，五边形等组成。而三角网格是最常用的一种。下面是几个由三角形网格表示的三维模型：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/体素、网格与点云/o_skull-surface.png" alt="img"></p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/体素、网格与点云/o_sphere-surface.png" alt="img"></p><p>三角面片在计算机中存储的时候只需要存储其的三个顶点就可以了，一般是将所有顶点的$(x,y,z)$坐标存为一个数组，然后每个面片就可以用三个数组索引来表示。</p><p>假设有这样的一个顶点数组：</p><div class="table-container"><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">坐标</td><td style="text-align:center">$(1,2,3)$</td><td style="text-align:center">$(4,5,6)$</td><td style="text-align:center">$(7,8,9)$</td><td style="text-align:center">$(10,11,12)$</td></tr></tbody></table></div><p>那么一个由点$(1,2,3)、(4,5,6)、(10,11,12)$的面片就可以以索引$1、2、4$来表示。</p><h1 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h1><p>点云就是点的集合，在最基础的形式中，它是一个包含多个三维坐标点$(x,y,z)$的集合。当然，也可以给这些点加上颜色信息、强度信息等附加信息。但它们本质都是一组点的集合，可以表示为$(\text{point}_1,\text{point}_2,\text{point}_3,\cdots)$。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/体素、网格与点云/v2-0ab74f0b4ba273d0a630263afaeffec9_1440w.jpg" alt="《三维点云处理》学习笔记（5）Deep Learning for Point Cloud - 知乎"></p>]]></content>
      
      
      <categories>
          
          <category> 在文献里迷路的日子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能</title>
      <link href="/post/3254563453.html"/>
      <url>/post/3254563453.html</url>
      
        <content type="html"><![CDATA[<h1 id="人工智能的三大学派"><a href="#人工智能的三大学派" class="headerlink" title="人工智能的三大学派"></a>人工智能的三大学派</h1><p>人工智能主要学派分为符号主义、连接主义、行为主义。</p><ul><li><p>符号主义（Symbolicism）学派：认为人工智能源于数理逻辑。该学派将数学严格公理化，从公理出发，由逻辑推理得到引理，定理，推论。</p></li><li><p>连接主义（Connectionism）学派：认为人工智能源于仿生学，特别是对人脑模型的研究。</p></li><li><p>行为主义（Actionism）学派：来源于控制论及“感知—动作”型控制系统。该学派认为智能取决于感知和行动，人工智能可以像人类智能一样逐步进化，以及智能行为只能在现实世界中与周围环境交互作用而表现出来。</p><script type="math/tex; mode=display">\begin{array}{|c|c|c|}\hline \text { 学习模式 } & \text { 优势 } & \text { 不足 } \\\hline \text { 用规则教 } & \begin{array}{c}\text { 与人类逻辑推理相似, 解 } \\\text { 释性强 }\end{array} & \begin{array}{c}\text { 难以构建完备的知识规则 } \\\text { 库 }\end{array} \\\hline \text { 用数据学 } & \text { 直接从数据中学 } & \begin{array}{c}\text { 以深度学习为例: 依赖于 } \\\text { 数据、解释性不强 }\end{array} \\\hline \text { 用问题引导 } & \begin{array}{c}\text { 从经验中进行能力的持续 } \\\text { 学习 }\end{array} & \begin{array}{c}\text { 非穷举式搜索而需更好策 } \\\text { 略 }\end{array} \\\hline\end{array}</script></li></ul><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="智能之根：数据"><a href="#智能之根：数据" class="headerlink" title="智能之根：数据"></a>智能之根：数据</h2><ul><li>人工智能的本质是从数据中挖掘知识，实现机器智能化的过程。</li><li>样例学习是智能体的基本学习方式之一。</li></ul><h2 id="数据的认识"><a href="#数据的认识" class="headerlink" title="数据的认识"></a>数据的认识</h2><ul><li>数据概念：数据对象及其属性的集合。</li><li>属性（变量、特征）：对象的属性或特性。</li><li>属性值：属性分配的数字或符号。<strong>属性值不一定反映出属性</strong></li><li>数据类型：类别属性、顺序属性、区间属性、比率属性。</li></ul><h2 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h2><ul><li>记录型数据（Record Data）：包含固定属性集的记录集合。</li><li>图/网络数据（Graph Data）：如社交网络、分子结构等。</li><li>有序数据（Ordered Data）：序列数据、时间序列数据、时空数据等。</li></ul><h2 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h2><p>数据的质量决定了算法的上限</p><ul><li>数据质量问题：噪声、异常值、缺失值、重复数据。</li><li>数据预处理：聚合、采样、降维、离散化、属性转换、特征创建、特征子集选择。</li></ul><h2 id="数据预处理技术"><a href="#数据预处理技术" class="headerlink" title="数据预处理技术"></a>数据预处理技术</h2><ul><li>聚合（Aggregation）：将多个属性或对象合并为单一属性或对象。</li><li>采样（Sampling）：数据选择的主要技术，用于初步调研和最终分析。</li><li><p>降维（Dimensionality Reduction）：减少数据集的维度，避免“维度的诅咒”。</p><ul><li>数据的维度越高，数据分散的就越分散。很多机器学习的方法都是基于距离的，在高维的表现不好，所以要将维度下降下来。常用的有PCA，T-SNE，SVD。</li></ul></li></ul><blockquote><p>T-SNE（t-Distributed Stochastic Neighbor Embedding）是一种非线性降维技术，通常用于高维数据的可视化。它是由Laurens van der Maaten和Geoffrey Hinton在2008年提出的。T-SNE的主要目的是将高维空间中的数据点映射到低维空间（通常是2维或3维），同时保持原始数据中的相似性结构。<br>T-SNE的特点包括但不限于：</p><ol><li><strong>非线性降维</strong>：与传统的线性降维技术（如PCA）不同，T-SNE能够捕捉数据中的非线性结构。</li><li><strong>相似性保持</strong>：T-SNE尝试在低维空间中保持高维空间中数据点之间的相似性。这意味着在高维空间中相似的数据点在低维空间中仍然相似，而不相似的数据点在低维空间中则被拉开。</li></ol><ul><li>离散化（Discretization）：将连续属性转换为分类属性。</li><li>属性转换（Attribute Transformation）：对属性值集映射到新的替代值集。</li><li>特征创建（Feature Creation）：从原始数据创建新特征，以更有效地捕捉重要信息。</li><li>特征子集选择（Feature Subset Selection）：减少数据维度，剔除冗余和不相关特征。</li></ul></blockquote><h2 id="从数据到智能的不同理解方式"><a href="#从数据到智能的不同理解方式" class="headerlink" title="从数据到智能的不同理解方式"></a>从数据到智能的不同理解方式</h2><ul><li>符号主义（Symbolism）：使用符号系统和规则来理解数据。</li><li>连接主义（Connectionism）：使用网络和学习算法来理解数据。</li><li>行为主义（Behaviorism）：使用环境和反馈来理解数据。</li></ul><h1 id="知识的表示与推理"><a href="#知识的表示与推理" class="headerlink" title="知识的表示与推理"></a>知识的表示与推理</h1><p>人工智能的本质是知识的表示</p><ul><li>人工智能的成功与否取决于其知识表示的清晰度。</li></ul><p>知识与数据、信息的区别：</p><ul><li>数据：单独的事实、信号、符号，是信息的载体。</li><li>信息：由符号组成，如文字和数字，赋予符号一定的意义。</li><li>知识：在信息的基础上增加上下文信息，提供更多意义。</li></ul><p>知识表示：将知识符号化并输入到计算机的过程和方法。</p><p>知识表示的两种基本观点：</p><ul><li>陈述性知识表示：知识表示与应用分开处理。</li><li>过程性知识表示：知识表示与应用结合，知识与程序融合。</li></ul><h2 id="现代逻辑学"><a href="#现代逻辑学" class="headerlink" title="现代逻辑学"></a>现代逻辑学</h2><h3 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h3><p><strong>命题</strong>：具有真假意义的陈述句。</p><p><strong>命题逻辑的组成</strong>：</p><ul><li>原子命题：最基本的命题。</li><li>复合命题：由联结词、标点符号和原子命题复合构成。</li></ul><blockquote><p>具体的公式参考离散数学以及人工智能课件</p></blockquote><h2 id="归结推理"><a href="#归结推理" class="headerlink" title="归结推理"></a>归结推理</h2><h3 id="1-子句"><a href="#1-子句" class="headerlink" title="1. 子句"></a>1. 子句</h3><p>在归结推理中，<strong>子句</strong>是一个关键概念。一个子句是逻辑公式的一个特殊形式，可以表示为：</p><script type="math/tex; mode=display">L_1 \vee L_2 \vee \ldots \vee L_n</script><p>其中，每个 $ L_i $ 都是一个文字（literal），文字可以是原子公式或其否定。子句也可以是空的，表示为 $\square$ 或 $\bot$，这在逻辑中代表矛盾或“假”。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>子句可以包含任意数量的文字。</li><li>子句中的文字可以是正的（原子公式）或负的（原子公式的否定）。</li><li>空子句表示逻辑矛盾。<h3 id="2-谓词公式转子句集"><a href="#2-谓词公式转子句集" class="headerlink" title="2. 谓词公式转子句集"></a>2. 谓词公式转子句集</h3></li></ul><p>要将下列谓词公式化为子句集：</p><script type="math/tex; mode=display">\forall x\{[\neg P(x) \vee \neg Q(x)] \rightarrow \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script><ol><li><p><strong>消去蕴涵符号</strong><br>将原公式中的蕴涵符号（$\rightarrow$）转换为或（$\vee$）与非（$\wedge$）的组合：</p><script type="math/tex; mode=display">\forall x\{\neg[\neg P(x) \vee \neg Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script></li><li><p><strong>移动否定符号</strong><br>将否定符号（$\neg$）移到每个谓词前：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall x[P(x) \vee B(x)]</script></li><li><p><strong>变量标准化</strong><br>为了避免变量冲突，对变量进行标准化处理：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee \exists y[S(x, y) \wedge Q(x)]\} \wedge \forall w[P(w) \vee B(w)]</script></li><li><p><strong>消去存在量词</strong><br>设 $y$ 的Skolem函数是 $f(x)$，则：</p><script type="math/tex; mode=display">\forall x\{[P(x) \wedge Q(x)] \vee[S(x, f(x)) \wedge Q(x)]\} \wedge \forall w[P(w) \vee B(w)]</script></li><li><p><strong>化为前束型</strong><br>将公式化为前束型，即将量词移至公式最前面：</p><script type="math/tex; mode=display">\forall x \forall w\{\{[P(x) \wedge Q(x)] \vee[S(x, f(x)) \wedge Q(x)]\} \wedge[P(w) \vee B(w)]\}</script></li><li><p><strong>化为标准形</strong><br>将公式化为标准形，包括整理合取与析取：</p><script type="math/tex; mode=display">\begin{array}{l}\forall x \forall w\{\{[Q(x) \wedge P(x)] \vee[Q(x) \wedge S(x, f(x))]\} \wedge[P(w) \vee B(w)]\} \\\forall x \forall w\{Q(x) \wedge[P(x) \vee S(x, f(x))] \wedge[P(w) \vee B(w)]\}\end{array}</script></li><li><p><strong>略去全称量词</strong><br>在这一步中，我们去掉全称量词：</p><script type="math/tex; mode=display">Q(x) \wedge[P(x) \vee S(x, f(x))] \wedge[P(w) \vee B(w)]</script></li><li><p><strong>消去合取词</strong><br>将公式分解为子句集，每个合取词对应一个子句：</p><script type="math/tex; mode=display">\{Q(x),(P(x), S(x, f(x))),(P(w), B(w))\}</script></li><li><p><strong>子句变量标准化</strong><br>对子句中的变量进行标准化处理：</p><script type="math/tex; mode=display">\{Q(x),(P(y), S(y, f(y))),(P(w), B(w))\}</script></li></ol><h3 id="3-归结式"><a href="#3-归结式" class="headerlink" title="3. 归结式"></a>3. 归结式</h3><p><strong>归结式</strong>（Resolution Inference Rule）是归结推理的核心。它是一个推导规则，用于从两个子句推导出一个新的子句。归结式的应用基于以下原则：</p><ul><li>选择两个子句，它们至少有一个共同的文字，且在一个子句中为正，在另一个中为反。</li><li>删除这两个子句中的共同文字及其否定。</li><li>合并剩余的文字形成一个新的子句。<h4 id="归结式的表示"><a href="#归结式的表示" class="headerlink" title="归结式的表示"></a>归结式的表示</h4>如果 $ C_1 $ 和 $ C_2 $ 是两个子句，并且它们有一个共同的文字 $ L $ 和它的否定 $ \neg L $，则归结式可以表示为：<script type="math/tex; mode=display">C_1, C_2 \rightarrow C_1 \cup C_2 - \{L, \neg L\}</script>其中 $ C_1 \cup C_2 $ 表示两个子句文字的并集，$ -\{L, \neg L\} $ 表示去除共同的文字和它的否定。</li></ul><p>假设有两个子句：</p><ul><li>$ C_1: A \vee B \vee \neg C $</li><li>$ C_2: \neg A \vee D $<br>它们可以通过归结式来推导出一个新的子句：</li><li>共同文字：$ A $ 和 $ \neg A $</li><li>应用归结式：删除 $ A $ 和 $ \neg A $，得到新的子句 $ B \vee \neg C \vee D $</li></ul><h3 id="4-归结推导"><a href="#4-归结推导" class="headerlink" title="4. 归结推导"></a>4. 归结推导</h3><h4 id="命题逻辑-1"><a href="#命题逻辑-1" class="headerlink" title="命题逻辑"></a>命题逻辑</h4><ol><li>前提转换：将所有前提转换为子句的合取范式。</li><li>归结：应用归结规则，选择两个子句进行归结，生成新的子句。</li><li>重复归结：使用新生成的子句重复归结步骤。</li><li>检查结果：检查是否生成了空子句。如果生成了空子句，则推导成功（说明之前的亲本子句也是假的，一直向前传递）；如果没有生成空子句且无法继续归结，则推导失败。</li></ol><h4 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h4><p><strong>谓词逻辑在归结的时候还可能需要进行置换和合一</strong>。</p><h5 id="置换和合一"><a href="#置换和合一" class="headerlink" title="置换和合一"></a>置换和合一</h5><p>置换：可以用$t_1 /v_1$或$v_1=t_1$来表示用$t_1$置换$v_1$​</p><ul><li>$t_i$不允许包含与$v_i$有关的项</li><li>不允许$v_i$循环出现在另一个$t_i$​中作置换</li></ul><p>合一：存在置换$\lambda$使得$\mathrm{F}_{1} \lambda=\mathrm{F}_{2} \lambda$，则$\lambda$称为一个合一。（不唯一）</p><p>最一般合一：定义设  $\sigma$  是公式集$F$的一个合一，如果对任一个合一  $\theta$  都存在一个置换  $\lambda$ , 使得  $\theta=\sigma\circ \lambda$ 则称  $\sigma$​​  是一个最一般合一（MGU）。（唯一）</p><h5 id="最一般合一算法"><a href="#最一般合一算法" class="headerlink" title="最一般合一算法"></a>最一般合一算法</h5><ol><li><p>令 $k=0$, $F_k=F$, $\sigma_k=\varepsilon$。其中 $\varepsilon$ 是空置换。</p></li><li><p>若 $F_k$ 只含一个表达式，则算法停止，$\sigma_k$ 就是最一般合一。</p></li><li><p>找出 $F_k$ 的差异集 $D_k$。</p></li><li><p>若 $D_k$ 中存在元素 $x_k$ 和 $t_k$，其中 $x_k$ 是变元，$t_k$ 是项，且 $x_k$ 不在 $t_k$ 中出现，则置：</p><script type="math/tex; mode=display">\begin{align*}F_{k+1} & = F_k \{ t_k / x_k \} \\\sigma_{k+1} & = \sigma_k \{ t_k / x_k \} \\k & = k + 1\end{align*}</script><p>然后转 (2)。若不存在这样的 $x_k$ 和 $t_k$ 则算法停止。</p></li><li><p>算法终止，$F$​的最一般合一不存在。</p></li></ol><h3 id="5-归结实例"><a href="#5-归结实例" class="headerlink" title="5. 归结实例"></a>5. 归结实例</h3><p>设A、B、C三人中有人从不说真话，也有人从不说假话。某人向这三人分别提出同一个问题：谁是说谎者？以下是他们的回答：</p><ul><li>A答：“B和C都是说谎者”；</li><li>B答：“A和C都是说谎者”；</li><li>C答：“A和B中至少有一个是说谎者”。</li></ul><p>求谁是老实人，谁是说谎者？</p><p>先写出公式：</p><script type="math/tex; mode=display">\begin{array}{l} \mathrm{T}(\mathrm{C}) \vee \mathrm{T}(\mathrm{A}) \vee \mathrm{T}(\mathrm{B}) \\\neg \mathrm{T}(\mathrm{C}) \vee \neg \mathrm{T}(\mathrm{A}) \vee \neg \mathrm{T}(\mathrm{B}) \\\mathrm{T}(\mathrm{A}) \rightarrow \neg \mathrm{T}(\mathrm{B}) \wedge \neg \mathrm{T}(\mathrm{C}) \\\neg \mathrm{T}(\mathrm{A}) \rightarrow \mathrm{T}(\mathrm{B}) \vee \mathrm{T}(\mathrm{C}) \\\mathrm{T}(\mathrm{B}) \rightarrow \neg \mathrm{T}(\mathrm{A}) \wedge \neg \mathrm{T}(\mathrm{C}) \\\neg \mathrm{T}(\mathrm{B}) \rightarrow \mathrm{T}(\mathrm{A}) \vee \mathrm{T}(\mathrm{C}) \\\mathrm{T}(\mathrm{C}) \rightarrow \neg \mathrm{T}(\mathrm{A}) \vee \neg \mathrm{T}(\mathrm{B}) \\\neg \mathrm{T}(\mathrm{C}) \rightarrow \mathrm{T}(\mathrm{A}) \wedge \mathrm{T}(\mathrm{B})\end{array}</script><p>然后，我们把上述回答公式化成子句集S：</p><ol><li>¬T(A) ∨ ¬T(B) （如果A不是老实人，则B不是老实人）</li><li>¬T(A) ∨ ¬T(C) （如果A不是老实人，则C不是老实人）</li><li>T(C) ∨ T(A) ∨ T(B) （C、A、B中至少有一个是老实人）</li><li>¬T(B) ∨ ¬T(C) （如果B不是老实人，则C不是老实人）</li><li>¬T(C) ∨ ¬T(A) ∨ ¬T(B) （C、A、B中至少有一个不是老实人）</li><li>T(A) ∨ T(C) （A或C是老实人）</li><li>T(B) ∨ T(C) （B或C是老实人）</li></ol><p>下面先求谁是老实人。把¬T(x) ∨ Answer(x)并入$S$得到$S_1$。即多一个子句：</p><ol><li>¬T(x) ∨ Answer(x) （如果x不是老实人，则x是答案）</li></ol><p>应用归结原理对$S_1$进行归结：</p><ol><li>¬T(A) ∨ T(C) （子句1和子句7归结）</li><li>T(C) （子句6和子句9归结）</li><li>Answer(C) （子句8和子句10归结）</li></ol><p>所以C是老实人，即C从不说假话。</p><h3 id="6-归结策略"><a href="#6-归结策略" class="headerlink" title="6. 归结策略"></a>6. 归结策略</h3><p>宽度优先、支持集策略、线性输入策略（不完备）、单文字策略（不完备）、祖先过滤策略。</p><p>删除策略：纯文字删除法、重言式删除法、包孕删除法。</p><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p>知识图谱是由一些相互连接的实体及其属性构成的</p><p>三元组是知识图谱的一种通用表示方式：</p><ul><li>(实体1-关系-实体2)：中国-首都-北京</li><li>(实体-属性-属性值)：北京-人口-2069万</li></ul><p><strong>知识库推理包括基于符号的推理和基于统计的推理。</strong></p><h3 id="知识图谱推理：FOIL算法"><a href="#知识图谱推理：FOIL算法" class="headerlink" title="知识图谱推理：FOIL算法"></a>知识图谱推理：FOIL算法</h3><ol><li><p><strong>初始化</strong>：选择一个目标谓词（例如，<code>Father(X, Y)</code>），这是我们想要学习推理规则的谓词。</p></li><li><p><strong>前提约束谓词的选择</strong>：从知识图谱中选择可能作为目标谓词前提约束的谓词（例如，<code>Mother(X, Y)</code>, <code>Sibling(X, Y)</code> 等）。</p></li><li><p><strong>正例和反例的构造</strong>：根据知识图谱中的信息，构造出目标谓词的正例和反例。正例是已知满足目标谓词的实体对，而反例是不满足目标谓词的实体对。</p></li><li><p><strong>信息增益计算</strong>：对于每个候选的前提约束谓词，计算其加入推理规则后的信息增益值。</p><script type="math/tex; mode=display">\text {增益值 }=\widehat{m_{+}} \cdot\left(\log _{2} \frac{\widehat{m_{+}}}{\widehat{m_{+}}+\widehat{m_{-}}}-\log _{2} \frac{m_{+}}{m_{+}+m_{-}}\right)</script></li><li><p><strong>选择最佳前提</strong>：基于信息增益值，选择最佳的前提约束谓词加入到推理规则中。</p></li><li><p><strong>推理规则的构建</strong>：将选定的前提约束谓词与目标谓词结合，形成新的推理规则（例如，<code>Couple(X, Z) -&gt; Father(X, Y)</code>）。将训练样例中与该推理规则不符的样例（正例和反例）去掉。</p></li><li><p><strong>规则评估</strong>：评估新构建的推理规则是否满足所有正例并且不覆盖任何反例。如果满足，规则学习完成，得到最终的推理规则；如果不满足，返回步骤5，选择另一个前提约束谓词并重复过程。</p></li></ol><h1 id="搜索技术"><a href="#搜索技术" class="headerlink" title="搜索技术"></a>搜索技术</h1><h2 id="盲目搜索"><a href="#盲目搜索" class="headerlink" title="盲目搜索"></a>盲目搜索</h2><p>盲目搜索有三个特点：</p><ul><li>这些策略都采用固定的规则来选择下一需要被扩展的状态</li><li>这些规则不会随着要搜索解决的问题的变化而变化</li><li>这些策略不考虑任何与要解决的问题领域相关的信息</li></ul><p>搜索算法的重要特征：</p><ul><li>完备性（Completeness）: 搜索算法是否总能在问题存在解的情况下找到解</li><li>最优性（Optimality）: 当问题中的动作是需要成本时，搜索算法是否总能找到成本最小的解</li><li>时间复杂度（Time complexity）: 搜索算法最多需要探索/生成多少个节点来找到解</li><li>空间复杂度（Space complexity）: 搜索算法最多需要将多少个节点储存在内存中</li></ul><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li>深度优先：把当前要扩展的状态的后继状态放在边界的最前面<ul><li>时间复杂度为$O(b^m),m是遍历过程中最长路径的长度$​</li><li>空间复杂度为$O(bm)$，线性复杂度</li><li>不具有完备性和最优性</li></ul></li><li>宽度优先：把当前要扩展的状态的后继状态放在边界的最后<ul><li>时间复杂度为$O(b^{d+1}),d=最短解的个数$</li><li>空间复杂度高</li><li>具有完备性和最优性</li></ul></li><li>一致代价：边界中，按路径的成本升序排列；总是扩展成本最低的那条路径<ul><li>只是将宽度优先算法的队列换成了优先队列</li><li>如果最优解为$C<em>$，则时间和空间复杂度为 $O\left(b^{C </em> / s+1}\right)$</li></ul></li><li>深度受限：深度优先搜索，但是预先限制了搜索的深度 $L$​<ul><li>不具有完备性和最优性</li><li>时间复杂度$O(b^L)$，空间复杂度$O(bL)$</li></ul></li><li><p>迭代加深搜索：一开始设置深度限制为$L = 0$，迭代地增加深度限制，对于每个深度限制都进行深度受限搜索</p><ul><li>具有完备性和最优性</li><li>时间复杂度为$O(b^{d}),d=最短解的个数$​</li><li>空间复杂度$O(bd)$</li></ul></li><li><p>双向搜索：同时进行从初始状态向前的搜索和从目标节点向后搜索，在</p><p>两个搜索在中间相遇时停止搜索</p><ul><li>难点：如何向后搜索</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="table-container"><table><thead><tr><th style="text-align:center">标准</th><th style="text-align:left">广度优先搜索</th><th>统一成本搜索</th><th>深度优先搜索</th><th>深度受限搜索</th><th>迭代深化搜索</th><th>双向搜索（如果适用）</th></tr></thead><tbody><tr><td style="text-align:center">是否完整？</td><td style="text-align:left">是 (a)</td><td>是 (a, b)</td><td>否</td><td>否</td><td>是 (a)</td><td>是 (a, d)</td></tr><tr><td style="text-align:center">时间复杂度</td><td style="text-align:left">$O(b^d)$</td><td>$O(b^{1+\lfloor C^*/\varepsilon \rfloor})$</td><td>$O(b^m)$</td><td>$O(b^\ell)$</td><td>$O(b^d)$</td><td>$O(b^{d/2})$</td></tr><tr><td style="text-align:center">空间复杂度</td><td style="text-align:left">$O(b^d)$</td><td>$O(b^{1+\lfloor C^*/\varepsilon \rfloor})$</td><td>$O(bm)$</td><td>$O(b\ell)$</td><td>$O(bd)$</td><td>$O(b^{d/2})$</td></tr><tr><td style="text-align:center">是否最优？</td><td style="text-align:left">是 (c)</td><td>是</td><td>否</td><td>否</td><td>是 (c)</td><td>是 (c, d)</td></tr></tbody></table></div><h3 id="路径检测"><a href="#路径检测" class="headerlink" title="路径检测"></a>路径检测</h3><p>路径检测：当扩展节点$n$来获得子节点$c$时，确保节点$c$不等于到达节点$c$的路径上的任何祖先节点。</p><p>环检测：记录下在之前的搜索过程中扩展过的所有节点，当扩展节点 $n_k$ 获得子节点$c$​时，确保节点c不等于<strong>之前任何扩展过的节点</strong></p><ul><li><p>对于一致代价搜索，使用环检测后仍能找到最优的解</p></li><li><p>对于启发式搜索，这个性质不一定会成立</p></li></ul><h2 id="启发搜索"><a href="#启发搜索" class="headerlink" title="启发搜索"></a>启发搜索</h2><p>常见的启发函数$h(n)$：欧氏距离、曼哈顿距离</p><p>欧氏距离：$\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + … + (x_n - y_n)^2}$​</p><p>曼哈顿距离：$| x_1 - y_1 | + | x_2 - y_2 | + … + | x_n - y_n |$</p><p>贪心最佳优先搜索：只考虑启发式函数$h(n)$​来对边界上的节点进行排序</p><ul><li>但是，这种做法忽略了从初始状态到达节点𝑛的成本</li><li>其是不完备的</li></ul><h3 id="A搜索"><a href="#A搜索" class="headerlink" title="A搜索"></a>A搜索</h3><p>盲目搜索只考虑了前半部分，能计算出从初始节点走到当前节点的优劣。启发函数则只“估计”了当前节点到最终节点的优劣。</p><p>两者相结合，就是启发式搜索策略，典型的代表是A算法。</p><p>其定义了评价函数$𝑓 (𝑛)$，利用节点对应的$𝑓 (𝑛)$值来对边界上的节点进行排序，并总扩展边界中具有最小$𝑓$​ 值的节点。$g(n)$是到$n$点的实际开销，$h(n)$是$n$点到终点的估计距离。</p><script type="math/tex; mode=display">f(n)=g(n)+h(n)</script><p>算法步骤：</p><ol><li>将初始节点的加入优先队列中。</li><li>取优先队列中$f(n)$最小的结点。</li><li>如果这个结点不是目标结点，则计算其相邻的结点的$f(n)$值，并将这些节点加入优先队列中。转2。</li><li>算法终止。</li></ol><h4 id="启发函数的要求"><a href="#启发函数的要求" class="headerlink" title="启发函数的要求"></a>启发函数的要求</h4><ul><li>如果启发函数的值太大，超出了实际的cost，就无法找到最优解</li><li>如果启发函数的值太小，A搜索就变为了一致代价搜索</li></ul><h3 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h3><p>在A算法中，如果代价函数  $f(n)=g(n)+h(n)$  始终满足  $h(n) \leqq h^{<em>}(n)$  那么该算法就是  $\mathbf{A}^{</em>}$​  算法。</p><p>一个好的$h(n)$​要满足的条件有两个：</p><blockquote><p>$ h(n)=0  时，对于任何  \mathrm{n}  这个启发式函数都是单调的。  \mathrm{A} *  搜索会退化成一致代价搜索$</p></blockquote><ul><li>可采纳性：</li></ul><script type="math/tex; mode=display">\text { 当对于所有节点 } n \text { ，满足 } h(n) \leq h^{*}(n) ， h(n) \text { 是可采纳的 }</script><p>可采纳的启发式函数<strong>低估了当前节点到达目标节点的成本</strong>，使得实际成本最小的最优路径能够被选上。</p><p><mark>可采纳性意味着最优性</mark>：$\text { 最优解一定会在所有成本大于 } C^{*} \text { 的路径之前被扩展到 }$</p><ul><li><p>单调性（一致性）：</p><script type="math/tex; mode=display">对于任意节点  n_{1}  和  n_{2} , 若，h\left(n_{1}\right) \leq c\left(n_{1} \rightarrow n_{2}\right)+h\left(n_{2}\right)，则  h(n)  具有单调性</script><p>如果是大于号，代表过大估计了cost。</p><p>如果具有单调性，则具有下面以下性质：</p><ol><li><p><mark><strong>满足一致性的启发式函数也一定满足可采纳性</strong></mark></p></li><li><p><mark><strong>在进行环检测之后仍然保持最优性</strong></mark></p></li><li>一条路径上的节点的 $f$​ 函数值应该是非递减的</li><li>如果节点  $n_2$  在节点  $n_1$  之后被扩展, 则有$f(n_1) \leq f(n_2)$</li><li>在遍历节点$n$时，所有$𝑓$值小于$𝑓(𝑛)$​​的节点都已经被遍历过了</li><li>A*搜索第一次扩展到某个状态，其已经找到到达该状态的最小成本路径</li></ol><blockquote><p>拓展指的是将该节点相邻的结点加入边界，遍历指的是探索这个结点</p></blockquote></li></ul><p>如果$h(n)$只满足可采纳性但是不满足单调性：</p><ol><li>虽然确实可以找到最优路径，但是搜索过程可能会更久。</li><li><strong>如果启发式函数只有可采纳性，则不一定能在使用了环检测之后仍保持最优性</strong>。若出现到达已遍历过节点但成本更低的路径，则需重新扩展而不能剪枝。</li></ol><h3 id="IDA-算法"><a href="#IDA-算法" class="headerlink" title="IDA*算法"></a>IDA*算法</h3><p>A∗搜索 和宽度优先搜索（BFS）或一致代价搜索（UCS）一样存在潜在的空间复杂度过大的问题。 IDA∗ （迭代加深的A∗搜索）与迭代加深搜索一样用于解决空间复杂度的问题。</p><p>但用于划定界限的不是深度，而是使用 $f$ 值$\left(g+h\right)$​</p><p>当启发函数h为可采纳时， IDA* 是最优的。</p><h3 id="松弛问题"><a href="#松弛问题" class="headerlink" title="松弛问题"></a>松弛问题</h3><p>可以通过放宽原始问题中的一些约束条件来简化问题，从而使得问题更容易解决。</p><blockquote><p>例如，在8数码问题中，原始问题要求将一些乱序的数字块通过滑动操作（只能移动到相邻的空格）恢复到正确的顺序。为了构建启发式函数，我们可以设计一个松弛问题，其中允许我们在任何时候都将一个数字块移动到目标位置，而不需要考虑是否相邻或空位的限制。这样的松弛问题简化了原始问题，因为它忽略了移动的约束条件，从而更容易计算出解决方案的成本。</p></blockquote><p>在松弛问题中，到达某个节点的最优成本可作为原始问题中到达该节点的可采纳的启发式函数值。</p><h2 id="对抗性搜索"><a href="#对抗性搜索" class="headerlink" title="对抗性搜索"></a>对抗性搜索</h2><p>上述的两个搜索算法都假设智能体对环境有完全的控制。</p><p>对抗搜索（博弈）的主要特点：超过两个以上玩家且均可以改变状态。难点在于对方会如何行动。博弈有确定的和随机的、完全的信息和不完全的信息等不同的特征.</p><p>经典的博弈问题就是双人博弈的问题，主要关注扩展形式的博弈：</p><ul><li>两个玩家：游戏的状态或决策可以映射为离散的值，游戏的状态或可以采取的行动的种类是有限的。</li><li>零和博弈：游戏的一方赢了，则另一方输掉了同等的数量</li><li>确定性：没有不确定的因素</li><li>完整的信息：任何层面的状态都是可观察的</li></ul><h3 id="MinMax策略"><a href="#MinMax策略" class="headerlink" title="MinMax策略"></a>MinMax策略</h3><p>对这种扩展式的双人博弈，采用MINMAX搜索。搜索的步骤如下：</p><ul><li>构建完整的博弈树（每个叶子节点都表示终止状态）</li><li>反向传播效益值$U(n)$：<ul><li>叶子节点的$U(n)$是提前定义的</li><li>如果结点$n$是一个$Min$节点：$U(n)=min\{U(c):c是n的子节点\}$</li><li>如果结点$n$是一个$Max$节点：$U(n)=Max\{U(c):c是n的子节点\}$</li></ul></li></ul><p>为了解决博弈树太大的问题，需要使用深度优先搜索算法来实现MinMax。</p><h3 id="Alpha-Beta剪枝"><a href="#Alpha-Beta剪枝" class="headerlink" title="Alpha-Beta剪枝"></a>Alpha-Beta剪枝</h3><p>为了进一步提高MinMax执行效率，可以对没有必要探索的分支进行剪枝。</p><p>Alpha-Beta剪枝的算法如下：（考试要求写的Alpha-Beta算法）</p><ol><li>初始化根节点的$\alpha$值为$-\infty$，$\beta$值为$+\infty$​</li><li>以后序遍历遍历整棵博弈树。<ol><li>每一个子节点都继承父节点的$\alpha$值和$\beta$值</li><li>每当一个子节点的被遍历完或$\alpha \geq \beta$时，停止遍历其并将结点值返回父节点并更新其父节点的结点值和$\alpha$值或$\beta$值。</li><li>MAX结点更新$\alpha$值，MIN结点更新$\beta$值</li></ol></li></ol><p>具体而言，如果一个节点是MIN结点，其的$\alpha$值是继承父节点MAX结点的，$\beta$值是自己更新的。当$\alpha \geq \beta$的时候，因为MIN结点的取值只会越来越小，而父节点（MAX结点）能取到的值已经大于该子节点的值了，所以已经不需要继续遍历了，可以直接返回。</p><p>如果一个节点是MAX结点，其的$\beta$值是继承父节点MIN节点的,$\alpha$值是自己更新的。当$\alpha \geq \beta$​的时候，因为MAX结点的取值只会越来越大，而父节点（MIN结点）能取到的值已经小于该子节点的值了，所以已经不需要继续遍历了，可以直接返回。</p><p>算法的伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SearchGameTree</span>(<span class="params">alpha,beta,root,level</span>):</span><br><span class="line">  <span class="comment">#叶节点则返回节点的值</span></span><br><span class="line">  <span class="keyword">if</span> IsLeaf(root):</span><br><span class="line">    <span class="keyword">return</span> root.value</span><br><span class="line">  </span><br><span class="line">  value=infinity <span class="keyword">if</span> level==<span class="string">&quot;Min&quot;</span> <span class="keyword">else</span> -infinity</span><br><span class="line">  <span class="comment">#其他结点则返回alpha或beta值</span></span><br><span class="line">  <span class="keyword">for</span> child <span class="keyword">in</span> childsOf(root):</span><br><span class="line">    <span class="comment">#每有一个子节点更新，则更新结点的值，并</span></span><br><span class="line">    <span class="keyword">if</span>(level==<span class="string">&quot;Max&quot;</span>):</span><br><span class="line">    value=<span class="built_in">max</span>(value,SearchGameTree(alpha,beta,child,<span class="string">&quot;Min&quot;</span>))</span><br><span class="line">      alpha=<span class="built_in">max</span>(alpha,value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    value=<span class="built_in">min</span>(value,SearchGameTree(alpha,beta,child,<span class="string">&quot;Max&quot;</span>))</span><br><span class="line">      beta=<span class="built_in">min</span>(beta,value)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(alpha&gt;=beta):</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><blockquote><p>一种优化的Alpha-Beta剪枝的算法如下：</p><ol><li>初始化根节点的$\alpha$值为$-\infty$，$\beta$值为$+\infty$​</li><li>以后序遍历遍历整棵博弈树。<ol><li>每一个子节点都继承父节点的$\alpha$值和$\beta$值</li><li>每当一个节点遍历完或其的$\alpha \geq \beta$，如果其是MAX结点返回$\alpha$值，MIN结点返回$\beta$值</li><li>MIN结点只更新$\beta$值，MAX结点只更新$\alpha$​值</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SearchGameTree</span>(<span class="params">alpha,beta,root,level</span>):</span><br><span class="line">  <span class="comment">#叶节点则返回节点的值</span></span><br><span class="line">  <span class="keyword">if</span> IsLeaf(root):</span><br><span class="line">    <span class="keyword">return</span> root.value</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#其他结点则返回alpha或beta值</span></span><br><span class="line">  <span class="keyword">for</span> child <span class="keyword">in</span> childsOf(root):</span><br><span class="line">    <span class="comment">#每有一个子节点更新，则更新结点的alpha-beta值</span></span><br><span class="line">    <span class="keyword">if</span>(level==<span class="string">&quot;Max&quot;</span>):</span><br><span class="line">    alpha=<span class="built_in">max</span>(alpha,SearchGameTree(alpha,beta,child,<span class="string">&quot;Min&quot;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    beta=<span class="built_in">min</span>(beta,SearchGameTree(alpha,beta,child,<span class="string">&quot;Max&quot;</span>))</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(alpha&gt;=beta):</span><br><span class="line">      <span class="keyword">return</span> alpha <span class="keyword">if</span> level==<span class="string">&quot;Max&quot;</span> <span class="keyword">else</span> beta</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> alpha <span class="keyword">if</span> level==<span class="string">&quot;Max&quot;</span> <span class="keyword">else</span> beta</span><br></pre></td></tr></table></figure></blockquote><h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><p>如果目标路径与问题解不相关，将考虑各种根本不关心路径（耗散）的算法，其中占据重要地位的就是局部搜索算法。</p><p>局部搜索算法: 局部搜索算法从单独的一个当前状态出发，通常只移动到与之相邻的状态</p><h3 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h3><p>爬山搜索算法是一种局部搜索算法。当它达到一个峰值，没有邻居有更高的值时，它将终止。</p><p>伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Hill_Climbing</span>(<span class="params">problem</span>):</span><br><span class="line">  current=problem</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    neighbor=highest_valued_neighbor(neighbors_of(current));</span><br><span class="line">    <span class="keyword">if</span> neighbor.value&lt;=current.value:</span><br><span class="line">      <span class="keyword">return</span> current</span><br><span class="line">    current=neighbor</span><br></pre></td></tr></table></figure><p>爬山算法存在以下问题：</p><ul><li><strong>局部极大值</strong>：当前状态的邻居状态值都低于当前状态，导致搜索停止。</li><li><strong>高原或山肩</strong>：多个局部极大值连成一片，搜索可能无法找到最优解。</li></ul><p>所以爬山法搜索成功与否在很大程度上取决于状态空间地形图的形状</p><h3 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h3><p>模拟退火算法（Simulated Annealing, SA）是一种模拟物理退火过程的优化算法，用于解决NP难题和避免陷入局部最优。</p><h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><p>三函数两准则一初温：</p><ul><li>三函数<ul><li>状态产生函数</li><li>状态接受函数：常使用$min(1,e^{-\frac{\Delta C}{t}})$（会以一定几率接受劣解）</li><li>温度更新函数：常使用$t_{k+1}=\alpha t_k$</li></ul></li><li>两准则<ul><li>内循环终止准则</li><li>外循环终止准则</li></ul></li><li>初始温度</li></ul><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240407194610480.png" alt="image-20240407194610480"></p><blockquote><p>计算接受概率$P(t_k)=e^{-[\frac{f(j)-f(i)}{t_k}]}$</p></blockquote><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><h4 id="基本流程-1"><a href="#基本流程-1" class="headerlink" title="基本流程"></a>基本流程</h4><p>遗传算法（Genetic Algorithms, GA）是一类借鉴生物进化机制的随机搜索算法，适用于解决复杂和非线性优化问题。</p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">procedure Simple_GA(<span class="built_in">input</span> GA_parameters):</span><br><span class="line">    <span class="comment"># 输入：遗传算法参数</span></span><br><span class="line">    <span class="comment"># 输出：最佳解决方案</span></span><br><span class="line">    generation = <span class="number">0</span>  <span class="comment"># 代数</span></span><br><span class="line">    Population = initialize_population(GA_parameters)  <span class="comment"># 种群</span></span><br><span class="line">    Population.evaluate_fitness()  <span class="comment"># 评估种群的适应度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 主循环，直到满足终止条件</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> termination_condition(t, GA_parameters):</span><br><span class="line">        Children = crossover(P_t, GA_parameters)  <span class="comment"># Children：交叉后产生的后代</span></span><br><span class="line">        Children = mutate(Children, GA_parameters)  <span class="comment"># 变异Children</span></span><br><span class="line">        Children.evaluate_fitness()  <span class="comment"># 评估Children的适应度</span></span><br><span class="line">        Population = select_next_generation(Population, Children, GA_parameters)  <span class="comment"># 选择下一代的种群</span></span><br><span class="line">        generation = generation + <span class="number">1</span>  <span class="comment"># 增加代数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出最佳解决方案</span></span><br><span class="line">    best_solution = get_best_solution(Population)</span><br><span class="line">    <span class="keyword">return</span> best_solution</span><br></pre></td></tr></table></figure><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>为了交叉（<code>crossover</code>）和变异（<code>mutate</code>），需要对问题状态进行编码，常用编码方式有：</p><ul><li>二进制编码</li><li>格雷编码</li><li>实数编码</li><li>多参数映射编码（把每个参数先进行二进制编码得到子串，再把这些子串连成一个完整的染色体）</li></ul><h4 id="适应度计算方式"><a href="#适应度计算方式" class="headerlink" title="适应度计算方式"></a>适应度计算方式</h4><p>若目标函数为<strong>最大化</strong>问题，则$Fitness(f(x))=f(x)$。若目标函数为<strong>最小化</strong>问题，则$Fitness(f(x))=\frac 1 {f(x)}$。</p><p>在遗传算法中，将所有妨碍适应度值高的个体产生，从而影响遗传算法正常工作的问题统称为<strong>欺骗问题</strong>。常见的有过早收敛、停滞现象等。</p><p>解决方法有：</p><ul><li>缩小这些个体的适应度，以降低这些超级个体的竞争力；</li><li>或改变原始适应值对应的比例关系，以提高个体之间的竞争力；</li><li>或对适应度函数值域的某种映射变换。</li></ul><h4 id="选择子代方式"><a href="#选择子代方式" class="headerlink" title="选择子代方式"></a>选择子代方式</h4><p>常见的选择子代方式有；</p><ul><li>适应度比例方法：各个个体被选择的概率和其适应度值成比例。个体$i$被选择的概率为：$\quad p_{s i}=\frac{f_{i}}{\sum_{i=1}^{M} f_{i}}$​</li><li>排序方法：排序选择进入下一代的个体</li><li>赌盘轮转法：按个体的选择概率产生一个轮盘，轮盘每个区的角度与个体的选择概率成比例。产生一个随机数，它落入转盘的哪个区域就选择相应的个体。</li><li>锦标赛选择方法：从群体中随机选择个个体，将其中适应度最高的个体保存到下一代。</li></ul><h4 id="交叉方式"><a href="#交叉方式" class="headerlink" title="交叉方式"></a>交叉方式</h4><p>常见的交叉方式有；</p><ul><li>一点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体。</li><li>两点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换。</li></ul><h1 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h1><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><script type="math/tex; mode=display">P(C|A) = \frac{P(A|C)P(C)}{P(A)}</script><p>其中：</p><ul><li>$P(C|A)$  是后验概率，即在已知特征A的情况下，样本属于类别C的概率。</li><li>$P(A|C)$ 是似然概率，即在已知类别C的情况下，观察到特征A的概率。</li><li>$P(C)$  是先验概率，即在没有观察到任何特征之前，样本属于类别C的概率。</li><li>$P(A)$  是边缘概率，即样本具有特征A的概率。</li></ul><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>朴素贝叶斯分类器是贝叶斯分类器的一种，它假设所有特征在给定类别的条件下都是相互独立的。</p><script type="math/tex; mode=display">P(A_1, A_2, ..., A_n | C) = P(A_1 | C)P(A_2 | C)...P(A_n | C)</script><p>朴素贝叶斯分类器通过以下方式从数据中估计概率：</p><ul><li>对于离散属性，使用类别下具有特定属性的样本数除以该类别的总样本数。</li><li>对于连续属性，可以离散化，也可以假设属性服从正态分布，并使用数据的均值和方差来估计分布的参数，然后利用这些参数来估计条件概率。</li></ul><h3 id="Laplace-平滑"><a href="#Laplace-平滑" class="headerlink" title="Laplace 平滑"></a>Laplace 平滑</h3><p>为了避免在计算概率时出现零概率的问题，可以使用Laplace平滑（也称为加一平滑）。</p><script type="math/tex; mode=display">P(c) = \frac{N_c + 1}{N + K}</script><p>其中，$N_c$ 是类别c的样本数量，$N$ 是所有样本的总数，$K$ 是类别总数。通过添加1，可以避免计算得到的概率为零的情况。</p><p>对于条件概率，Laplace平滑也可以应用于特征值和类别组合的计数：</p><script type="math/tex; mode=display">P(x|c) = \frac{N_{xc} + 1}{N_c + V}</script><p>其中，$N_{xc}$ 是在类别c下特征x取某个值的样本数量，$V$ 是特征x的所有可能值的数量。同样地，通过添加1，可以避免在训练集中没有出现过的特征值-类别组合导致概率为零的情况。</p><h3 id="分类过程"><a href="#分类过程" class="headerlink" title="分类过程"></a>分类过程</h3><p>给定一个新的样本，贝叶斯分类器通过计算其属于每个类别的后验概率$\frac{P(A|C)P(C)}{P(A)}$，然后选择具有最大后验概率的类别作为预测结果。</p><h2 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h2><p>朴素贝叶斯的局限性在于它要求所有特征在给定类别的条件下都是相互独立的。而贝叶斯网络则考虑了不同特特征之间的依赖关系。</p><p>贝叶斯网络由以下两个部分组成：</p><ul><li>一个有向无环图</li><li>多个条件概率表</li></ul><p>一个贝叶斯网络如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRa((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))--&gt;e((E))  </pre></div><p>为了计算$P(A,B,C,D,E)$，就需要计算$P(E|A,B,C,D)P(D|A,B,C)P(C|A,B)P(B|A)P(A)$。计算这个式子比较复杂。</p><p>而又观察到，在B发生的情况下，A和C是条件独立的（A发不发生都不影响C，因为A只能通过影响B发生的概率影响C，而B已经发生）。所以可以化简$P(C|A,B)$为$P(C|B)$。</p><p>所以将原来的式子化简，可以得到$P(A,B,C,D,E)=P(E|D)P(D|C)P(C|B)P(B|A)P(A)$​，这样就简化了计算。</p><blockquote><p>[!NOTE]</p><p><strong>基于因果关系的变量序列可以获得更加自然紧致的贝叶斯网络结构</strong></p></blockquote><h3 id="三类条件独立"><a href="#三类条件独立" class="headerlink" title="三类条件独立"></a>三类条件独立</h3><p>所以如果能找到条件独立的变量，就能进行化简。条件独立的变量有三类。</p><hr><h4 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRa((A))--&gt;b((B))--&gt;c((C))  </pre></div><p>在B发生的条件下，A和C条件独立。</p><h4 id="共因"><a href="#共因" class="headerlink" title="共因"></a>共因</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TBa((A))--&gt;b((B)) &amp; c((C))  </pre></div><p>当A发生的条件下，B和C条件独立。</p><blockquote><p>反过来说，如果A还不知道发不发生，B发生了。说明A很有可能发生，进而C有可能发生，因此不独立。</p></blockquote><h4 id="共果"><a href="#共果" class="headerlink" title="共果"></a>共果</h4><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TBa((A)) &amp; b((B)) --&gt; c((C))--&gt;d((D))  </pre></div><p>A和B相互独立。但在C（或者其子节点D）发生的条件下，它们没有条件独立。</p><blockquote><p>如果C（或D）发生了，说明可能是A或B发生了。如果此时A没发生，那说明很可能是B发生了。</p></blockquote><hr><p>判断有向无环图中在特定条件下两个变量是否条件独立，可以看两个变量之间是否有连通的路（这里的路是无方向的）。<strong>连通不独立，独立不联通</strong>。</p><ul><li>传递链路上的事件发生，会阻塞路</li><li>共因的因发生，会阻塞路</li><li>共果的果发生，会连通路</li></ul><p>举一个例子：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRa((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))--&gt;a &amp; cb &amp; g((G))--&gt;f((F))  </pre></div><p>当C发生的时候，C阻塞了传递链路，因此E和D独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef red fill:#f96;a((A))-.-&gt;b((B))-.-&gt;c((C))--&gt;d((D))e((E))-.-&gt;a &amp; cb &amp; g((G))--&gt;f((F))class c red;  </pre></div><p>当E和B发生的时候，E和B产生阻塞，因此A和D独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef red fill:#f96;a((A))-.-&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))-.-&gt;ae((E))--&gt;cb &amp; g((G))--&gt;f((F))class b red;class e red;  </pre></div><p>当F发生的时候，F是一个通路，因此B和G不独立</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart LRclassDef green fill:#90ee90;a((A))--&gt;b((B))--&gt;c((C))--&gt;d((D))e((E))--&gt;ae((E))--&gt;cb &amp; g((G))&#x3D;&#x3D;&gt;f((F))class f green;  </pre></div><h3 id="分类过程-1"><a href="#分类过程-1" class="headerlink" title="分类过程"></a>分类过程</h3><p>给定一个新的样本，贝叶斯网络也是通过计算其属于每个类别的后验概率$\frac{P(A|C)P(C)}{P(A)}$，然后选择具有最大后验概率的类别作为预测结果。只不过此时$P(A)$和$P(A|C)$​​在展开的时候用的不是相互独立而是条件独立去计算。</p><p>比如，在下面这个贝叶斯网络。计算$P(+b,+j,+m)$的时候就用条件独立代替了相互独立。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240420102307131.png" alt="image-20240420102307131"></p><script type="math/tex; mode=display">\begin{aligned}P(+b,+j,+m)= & P(+b) P(+e) P(+a \mid+b,+e) P(+j \mid+a) P(+m \mid+a)+ \\& P(+b) P(+e) P(-a \mid+b,+e) P(+j \mid-a) P(+m \mid-a)+ \\& P(+b) P(-e) P(+a \mid+b,-e) P(+j \mid+a) P(+m \mid+a)+ \\& P(+b) P(-e) P(-a \mid+b,-e) P(+j \mid-a) P(+m \mid-a)\end{aligned}</script><h4 id="变量消除"><a href="#变量消除" class="headerlink" title="变量消除"></a>变量消除</h4><p>如果直接枚举所有的情况，变量还是太多。这时候，就可以消除一些变量。</p><h5 id="合并因子"><a href="#合并因子" class="headerlink" title="合并因子"></a>合并因子</h5><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240420103339493.png" alt="image-20240420103339493"></p><p>比如果知道了$P(R)$和$P(T|R)$的概率表，就可以将其变为$P(R,T)$的概率表。</p><blockquote><p>如果$P(R)*P(T|R)$在一串式子中，那么两个乘积就可以变为一个乘积。</p></blockquote><h5 id="消除因子"><a href="#消除因子" class="headerlink" title="消除因子"></a>消除因子</h5><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240420105425960.png" alt="image-20240420105425960"></p><p>如果知道$R$不会以$-R$或$+R$的形式出现在表达式当中。就可以将这个因子消除。将$P(R,T)$的概率表变为$P(T)$的概率表。</p><h5 id="已知取值变量"><a href="#已知取值变量" class="headerlink" title="已知取值变量"></a>已知取值变量</h5><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240420110635467.png" alt="image-20240420110635467"></p><p>如果一个变量的取值已知，那它也可以被消除。</p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>机器学习基本类别有两种：</p><ul><li>回归：函数的输出是一个数值</li><li>分类：函数的输出是一个类别</li></ul><p>这两类的目的都是找到一个最优的函数，而寻找函数的三个步骤是：</p><ol><li>确定候选函数的集合（Model）</li><li>确定「评价函数好坏」的标准（Loss）</li><li>找出最好的函数（最优化Optimization）</li></ol><p>根据学习模式对机器学习进行分类，机器学习可以分为：</p><ul><li>监督学习</li><li>无监督学习</li><li>半监督学习</li><li>强化学习</li></ul><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p>聚类算法目的是找到几个组，使组内相似度较高，而组间相似度较少。</p><p>聚类（clustering）是由一系列集群（clusters）组成的集合。其的类别有：</p><ul><li><p>分割式聚类：将数据对象划分为不重叠的子集(簇) ，这样每个数据对象都恰好在一个子集中。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427160359945.png" alt="image-20240427160359945"></p></li><li><p>阶层式聚类：一组嵌套的集群，组织成一个层次树。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427160411657.png" alt="image-20240427160411657"></p></li></ul><h3 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h3><p>算法流程：</p><ol><li>选择K个点作为初始的聚类中心</li><li>计算所有点到K个初始聚类中心的距离，每个点被划分到距离最近的聚类中心的那个簇。</li><li>重新计算每个簇的聚类中心（求坐标的平均值）</li><li>如果聚类中心没有变化，则算法结束，否则转2</li></ol><p>初始的聚类中心通常是随机选择的。也是因为随机选择，所以可能聚类效果并不好。</p><h4 id="算法评价方法"><a href="#算法评价方法" class="headerlink" title="算法评价方法"></a>算法评价方法</h4><p>可以用SSE（Sum of Squared Errors误差平方和）来评估聚类的质量。SSE 越小，表示数据点在聚类内部越紧密，聚类效果越好。</p><script type="math/tex; mode=display">SSE=∑_{i=1}^{K} ∑_{x∈C_i} d^2(m_i, x)</script><p>其中，K 是聚类的数量，$C_i$ 是第 $i$ 个聚类，$m_i$ 是第 $i$ 个聚类的中心点，$x$ 是聚类 $C_i$ 中的一个数据点，$d(m_i, x)$ 是点 $x$ 到中心点 $m_i$ 的距离。</p><h4 id="K-means算法的改进"><a href="#K-means算法的改进" class="headerlink" title="K-means算法的改进"></a>K-means算法的改进</h4><h5 id="K-means"><a href="#K-means" class="headerlink" title="K-means++"></a>K-means++</h5><p>改进了初始选择聚类中心的方法：</p><ol><li>第一个聚类中心随机选取</li><li>以每个点分别为$\frac{D\left(x^{\prime}\right)^{2}}{\sum_{x \in \mathcal{X}} D(x)^{2}}$的概率选择下一个聚类中心。$D(x)$是数据点$x$到已经选择的最近的聚类中心的距离，也就是会选尽量与已选择的聚类中心较远的点作为聚类中心。</li><li>如果没选择到K个聚类中心则转2。</li></ol><p>但其也有缺点：每次选择聚类中心都需要遍历一次剩下的点，一共K次遍历。</p><h5 id="K-means-1"><a href="#K-means-1" class="headerlink" title="K-means||"></a>K-means||</h5><p>K-means||也叫稳定的K-means。</p><p>主要思路在于改变每次遍历时的取样策略，并非按照 kmeans++ 那样每次遍历只取样一个样本，而是每次遍历取样 $O(k)$ 个样本，重复该取样过程大约 $O(logn)$ 次，共得到 $O(klogn)$ 个样本点组成的集合。然后再聚类这 $O(klogn)$ 个点成 $k$ 个点，最后将这 $k$ 个点作为初始聚类中心。</p><h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><p>DBSCAN是一个基于密度的算法。（密度：指定半径内的点数）</p><p>给定$Eps$作为半径、$MinPts$作为最小的点的数量，其将点分为三类：</p><ul><li><p>核心点（core point）：在$Eps$（半径范围内）就有超过指定数量（$MinPts$）的点。</p></li><li><p>边界点（border point）：在$Eps$内少于$MinPts$个点，但它位于一个核心点的邻域内</p></li><li>噪声点（noise point）：其他点。</li></ul><p>算法流程：</p><ol><li>对所有点进行标记，核心点、边界点或噪声点</li><li>消除所有的噪声点。</li><li>对于所有核心点，如果在$Eps$范围内，则它们之间添加一条边。</li><li>将相连的核心点组成不同的簇</li><li>将每个边界点分配到它相关的核心点的某个簇中</li></ol><p>但其对$Eps$和$MinPts$的选择有要求。</p><h3 id="评价方法"><a href="#评价方法" class="headerlink" title="评价方法"></a>评价方法</h3><ol><li>相似度矩阵</li><li>SSE（凝聚度）和SSB（分离度）两者之和是定值（TSS）<ul><li>$SSE = \sum_{i=1}^{k} \sum_{x \in C_i} | x - m_i |^2$ </li><li>$SSB = \sum_{i=1}^{k} n_i | m_i - m |^2$。其中，$k$ 是聚类的数量，$n_i$ 是第 $i$个聚类中的点的数量，$m_i$ 是第 $i$个聚类的中心点，$m$是所有数据点的中心点（通常是所有点的均值）。</li></ul></li></ol><h3 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h3><p><a href="https://zhuanlan.zhihu.com/p/29849122">参考文章</a></p><p>谱聚类(Spectral Clustering)要求比K-means少，结果比K-means好，复杂度比K-means小。</p><h4 id="图的一些概念"><a href="#图的一些概念" class="headerlink" title="图的一些概念"></a>图的一些概念</h4><ul><li><p>$|A|$：图中顶点的个数</p></li><li><p>$vol(A)$：图的所有顶点的度数之和</p></li><li><p>相似度矩阵：</p><ul><li>$A(i, j)=0。如果i,j不相邻$</li><li>$A(i, j)=s(i, j)。如果i,j相邻$</li></ul></li><li><p>度矩阵：</p><ul><li><p>$D(i, j)=0。如果i\neq j$</p></li><li><p>$D(i,j)=d(v_i)。如果i=j相邻$​</p><blockquote><p>对角线上是每个节点自己的度</p></blockquote></li></ul></li><li><p>拉普拉斯矩阵：$L=D-W$​，其有如下性质：</p><blockquote><p>D是度矩阵，W是邻接矩阵</p></blockquote><ul><li><p><strong>对称性</strong>：由于D和W都是对称的，L也是对称的。</p></li><li><p><strong>半正定性</strong>：拉普拉斯矩阵的所有 eigenvalues（特征值）都是非负的，这意味着对于所有的向量$x，x^T L x ≥ 0$。</p></li><li><p><strong>最小特征值</strong>：拉普拉斯矩阵的最小特征值是0，对应的特征向量是所有元素都是1的常数向量。</p></li><li><p><strong>特征值排序</strong>：拉普拉斯矩阵的特征值可以按照非递减的顺序排列：$0 = λ_1 ≤ λ_2 ≤ … ≤ λ_N$。</p></li><li><p><strong>特征值之间的差距</strong>：最小非零特征值$λ_2$被称为谱隙（spectral gap），它度量了图结构的扩展性。</p></li><li><p><strong>特征向量的正交性</strong>：拉普拉斯矩阵有一组完整的正交特征向量。</p></li><li><p>对于任意的向量有</p><script type="math/tex; mode=display">f^{T} L f=\frac{1}{2} \sum_{i, j=1}^{n} w_{i j}\left(f_{i}-f_{j}\right)^{2}</script></li></ul></li></ul><h4 id="图分割"><a href="#图分割" class="headerlink" title="图分割"></a>图分割</h4><p>图分割要求把一个图分割为几个子图，并使得那些被切断的边的权值之和最小。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240429203641057.png" alt="image-20240429203641057"></p><h5 id="无向图切图"><a href="#无向图切图" class="headerlink" title="无向图切图"></a>无向图切图</h5><h6 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h6><p>对于任意两个子图点的集合 $A, B \subset V$，其中 $A \cap B=\emptyset$，定义 $A$ 和 $B$ 之间的切图权重为：</p><script type="math/tex; mode=display">W(A, B)=\sum_{i \in A, j \in B} w_{ij}</script><p>其中 $w_{ij}$ 表示点 $i$ 和点 $j$ 之间的权重。</p><p>对于 $k$ 个子图点的集合 $A_{1}, A_{2}, \ldots A_{k}$，定义切图Cut为：</p><script type="math/tex; mode=display">\operatorname{cut}(A_{1}, A_{2}, \ldots A_{k})=\frac{1}{2} \sum_{i=1}^{k} W\left(A_{i}, \bar{A}_{i}\right)</script><p>这里，$\bar{A}_{i}$ 表示 $A_{i}$ 的补集，即除 $A_{i}$ 子集外其他 $V$ 的子集的并集。</p><blockquote><p>一个好的切图，要让切图Cut最小</p></blockquote><p>但是仅使用这个Cut定义，会得到不够好的切图：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240429211438139.png" alt="image-20240429211438139"></p><h6 id="RatioCut"><a href="#RatioCut" class="headerlink" title="RatioCut"></a>RatioCut</h6><p>RatioCut切图对每个切图，不光考虑最小化$\operatorname{cut}(A_{1}, A_{2}, \ldots A_{k})$ ，它还同时考虑最大化每个子图点的个数：</p><script type="math/tex; mode=display">\operatorname{RatioCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\left|A_{i}\right|}</script><p>而要最小化RatioCut，需要引入指示向量：$h_{j} \in\left\{h_{1}, h_{2}, . . h_{k}\right\} ,j=1,2, \ldots k$，它是一个$n$维向量。$h_{ij}$定义为：</p><script type="math/tex; mode=display">h_{i j}=\left\{\begin{array}{ll}0 & v_{i} \notin A_{j} \\\frac{1}{\sqrt{\left|A_{j}\right|}} & v_{i} \in A_{j}\end{array}\right.</script><p>意思是如果点$v_i$属于$A_j$集合，则$h_{ij}=\frac{1}{\sqrt{\left|A_{j}\right|}}$。</p><p>有了指示向量后，RatioCut就可以化简为：</p><script type="math/tex; mode=display">\operatorname{RatioCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\sum_{i=1}^{k} h_{i}^{T} L h_{i}=\sum_{i=1}^{k}\left(H^{T} L H\right)_{i i}=\operatorname{tr}\left(H^{T} L H\right)</script><p>要最小化RatioCut，需要优化每一个$h_{i}^{T} L h_{i}$。其中 $h$ 是单位正交基， $L$ 为对称矩阵，此时 $h^T L h$ 的最大值为 $L$ 的最大特征值，最小值是 $L$ 的最小特征值。</p><p>所以通过找到$L$的最小的$k$个特征值，可以得到对应的$k$个特征向量，这$k$个特征向量组成一个$n\cdot k$维度的矩阵，即为$H$​。</p><p>由于在使用维度规约的时候损失了少量信息，导致得到的优化后的指示向量$h$对应的$H$现在不能完全指示各样本的归属。</p><blockquote><p>如果没有损失信息，$h_{ij}=\frac{1}{\sqrt{\left|A_{j}\right|}}$代表点$v_i$属于$A_j$集合。</p></blockquote><p>因此一般在得到$n\cdot k$维度的矩阵$H$后还需要对每一行进行一次传统的聚类，比如使用K-Means聚类。</p><h6 id="NCut"><a href="#NCut" class="headerlink" title="NCut"></a>NCut</h6><p>Ncut切图和RatioCut切图很类似，但是把RatioCut的分母 $|A_i|$ 换成 $\text{vol}(A_i)$：</p><script type="math/tex; mode=display">\operatorname{NCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\frac{1}{2} \sum_{i=1}^{k} \frac{W\left(A_{i}, \bar{A}_{i}\right)}{\operatorname{vol}\left(A_{i}\right)}</script><p>同样选取指示向量：</p><script type="math/tex; mode=display">h_{i j}=\left\{\begin{array}{ll}0 & v_{i} \notin A_{j} \\\frac{1}{\sqrt{\operatorname{vol}\left(A_{j}\right)}} & v_{i} \in A_{j}\end{array}\right.</script><p>将优化目标转换为：</p><script type="math/tex; mode=display">\operatorname{NCut}\left(A_{1}, A_{2}, \ldots A_{k}\right)=\sum_{i=1}^{k} h_{i}^{T} L h_{i}=\sum_{i=1}^{k}\left(H^{T} L H\right)_{i i}=\operatorname{tr}\left(H^{T} L H\right)</script><p>此时$H$中的指示向量$h$并不是标准正交基，而是$H^{T} D H=I$，所以在RatioCut里面的降维思想不能直接用。</p><p>令$H=D^{-1 / 2} F$,则$H^{T} L H=F^{T} D^{-1 / 2} L D^{-1 / 2} F$。此时$H^{T} D H=F^{T} F=I$。可以继续按照RatioCut的方法降维，求出 $D^{-1/2} L D^{-1/2}$ 的最小的前$k$个特征值，然后求出对应的特征向量，并标准化，得到最后的特征矩阵 $F$，最后对 $F$ 进行一次传统的聚类（比如K-Means）即可。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><h5 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h5><p>用于构建图的方法有：</p><ul><li>全连接图</li><li>$r$-邻接图（结点与以其为圆心，$r$为半径内的其他结点相连）</li><li>$k$-最近邻图（结点与最近的$k$个邻居相连）</li></ul><h5 id="构建拉普拉斯矩阵"><a href="#构建拉普拉斯矩阵" class="headerlink" title="构建拉普拉斯矩阵"></a>构建拉普拉斯矩阵</h5><p>根据相似矩阵$S$构建邻接矩阵$W$，构建度矩阵$D$。然后计算拉普拉斯矩阵$L=D-W$​。</p><h5 id="根据切图方法计算特征值"><a href="#根据切图方法计算特征值" class="headerlink" title="根据切图方法计算特征值"></a>根据切图方法计算特征值</h5><p>以下$k_1$为降维后的维度</p><ul><li>RatioCut计算 $L$ 的最小的前$k_1$个特征值</li><li>NCut计算$D^{-1/2} L D^{-1/2}$ 的最小的前$k_1$​​个特征值</li></ul><h5 id="计算特征矩阵"><a href="#计算特征矩阵" class="headerlink" title="计算特征矩阵"></a>计算特征矩阵</h5><p>将各自对应的特征向量$f$组成的矩阵按行标准化，最终组成$n\cdot k_1$维的特征矩阵$F$​。</p><h5 id="对特征矩阵聚类"><a href="#对特征矩阵聚类" class="headerlink" title="对特征矩阵聚类"></a>对特征矩阵聚类</h5><p>对$F$中的每一行作为一个$k_1$维的样本，共$n$个样本，用输入的聚类方法（比如K-means）进行聚类，聚类维数为$k_2$（划分为$k_2$个簇）。</p><p>最后得到簇划分 $C(c_1, c_2, \ldots, c_{k})$。</p><h2 id="SVM-不考"><a href="#SVM-不考" class="headerlink" title="SVM(不考)"></a>SVM(不考)</h2><blockquote><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7624837">参考文章</a>，这篇博客写的非常透彻，强推。</p></blockquote><p>SVM（Support Vector Machine）也称支持向量机，是一个将数据单元表示在多维空间中，然后对这个空间做划分的算法。而支持向量指的是支撑平面上把两类类别划分开来的超平面的向量点。</p><p>SVM在解决<strong>小样本</strong>、<strong>非线性</strong>、及<strong>高维模式识别</strong>中有很多优势。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="结构风险"><a href="#结构风险" class="headerlink" title="结构风险"></a>结构风险</h4><p>结构风险 = 经验风险 + 置信风险。</p><ul><li><strong>经验风险</strong>：在给定样本上的误差。</li><li><strong>置信风险</strong>：在多大程度上可以信任分类器在未知样本上分类的结果。</li></ul><p>SVM 的目标是最小化结构风险，而不再只是优化经验风险，否则会过拟合。</p><h4 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h4><p>几何间隔，指的是点到超平面距离（不同于点到平面的距离）：</p><script type="math/tex; mode=display">\tilde{\gamma}=y \gamma=\frac{\hat{\gamma}}{\|w\|}=\frac{y\left(w^{T} x+b\right)}{\|w\|}</script><p>其中，超平面为$y=\omega^T x+b$。$\hat y$是函数间隔。</p><h3 id="SVM目标函数"><a href="#SVM目标函数" class="headerlink" title="SVM目标函数"></a>SVM目标函数</h3><h4 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h4><p> 对一个数据点进行分类，当超平面离数据点的“间隔”越大，分类的效果就越好。所以对所有点来说，应该使得平面恰好夹在两类点的中间。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240516101840880.png" alt="image-20240516101840880"></p><p>所以就需要使最靠近分界线的点离分界线的几何间隔最大。所以目标函数定义为：</p><script type="math/tex; mode=display">\max \tilde{\gamma}\\约束条件:y_{i}\left(w^{T} x_{i}+b\right)=\hat{\gamma}_{i} \geq \hat{\gamma}, \quad i=1, \ldots, n</script><p>如果令函数间隔 $\hat{\gamma}$​ 等于1（方便推导和优化，且这样做对目标函数的优化没有影响）。则目标问题变为：</p><script type="math/tex; mode=display">\max \frac{1}{\|w\|} \\约束条件:y_{i}\left(w^{T} x_{i}+b\right) \geq 1, i=1, \ldots, n</script><p>由于求 $\frac{1}{|w|}$ 的最大值相当于求 $\frac{1}{2}|w|^{2}$ 的最小值，所以可以将目标函数转换为：</p><script type="math/tex; mode=display">\min \frac{1}{2}\|w\|^{2} \\约束条件:y_{i}\left(w^{T} x_{i}+b\right) \geq 1, i=1, \ldots, n</script><p> 因为原问题的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题，有全局的最优解。</p><h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><h5 id="拉格朗日变换"><a href="#拉格朗日变换" class="headerlink" title="拉格朗日变换"></a>拉格朗日变换</h5><p>由于原问题的特殊结构，还可以通过<strong>拉格朗日对偶性</strong>变换为对对偶问题的求解。</p><p>通过给每一个约束条件加上一个拉格朗日乘子$\alpha$，可以将约束条件融合到目标函数里去，从而将约束优化问题转换为无约束优化问题：</p><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{n} \alpha_{i}\left(y_{i}\left(w^{T} x_{i}+b\right)-1\right)</script><p>并令：</p><script type="math/tex; mode=display">\theta(w)=\max _{\alpha_{i} \geq 0} \mathcal{L}(w, b, \alpha)</script><p>而当所有约束条件都满足时，则最优值为$\theta(w)=\frac{1}{2}|w|^{2}$。因此，在要求约束条件得到满足的情况下最小化 $\frac{1}{2}|w|^{2}$，实际上等价于直接最小化 $\theta(w)$。</p><p>用$p^*$​表示问题的最优值，则目标函数变为：</p><script type="math/tex; mode=display">\min _{w, b} \theta(w)=\min _{w, b} \max _{\alpha_{i} \geq 0} \mathcal{L}(w, b, \alpha)=p^{*}</script><p>这个问题的求解较为困难（因为有参数$w、b$，并且$a_i$​​还受到不等式约束）。<strong>所以把最小和最大的位置交换一下，得到原问题的对偶问题：</strong></p><script type="math/tex; mode=display">\max _{\alpha_{i} \geq 0} \min _{w, b} \mathcal{L}(w, b, \alpha)=d^{*}</script><p>$d^{<em>}$是新问题的最优解，并且有$d^{</em>}\leq p^{<em>}$。并且因为Slater 条件成立，所以$d^{</em>}\leq p^{*}$​可以取等号。</p><h5 id="求解对偶问题"><a href="#求解对偶问题" class="headerlink" title="求解对偶问题"></a>求解对偶问题</h5><p>首先固定 $\alpha$ ，要让 $\mathcal{L}$ 关于 $w$ 和 $b$ 最小化 我们分别对 $w, b$ 求偏导数，即令 $\partial \mathcal{L} / \partial w$ 和 $\partial \mathcal{L} / \partial b$ 等于零。 可以得到：</p><script type="math/tex; mode=display">\begin{array}{l}\frac{\partial \mathcal{L}}{\partial w}=0 \Rightarrow w=\sum_{i=1}^{n} \alpha_{i} y_{i} x_{i} \\\frac{\partial \mathcal{L}}{\partial b}=0 \Rightarrow \sum_{i=1}^{n} \alpha_{i} y_{i}=0\end{array}</script><p>将以上结果代入之前的$\mathcal{L}$，化简后得到：</p><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha)==\sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{i}^{T} x_{j}</script><p>此时的拉格朗日函数只包含了一个变量$\alpha_i$。然后就可以根据下式求解出$\alpha_i$：</p><script type="math/tex; mode=display">\begin{array}{l}&\max _{\alpha} \sum_{i=1}^{n} \alpha_{i}-\frac{1}{2} \sum_{i, j=1}^{n} \alpha_{i} \alpha_{j} y_{j} y_{j} x_{i}^{T} x_{j} \\\text {约束条件:}&\alpha_{i} \geq 0, i=1, \ldots, n \\&\sum_{i=1}^{n} \alpha_{i} y=0\end{array}</script><p>然后就可以根据$w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}$，求解出$\omega$；根据$b^{<em>}=-\frac{\max _{i: y^{(i)}=-1} w^{</em> T} x^{(i)}+\min _{i: y^{(i)}=1} w^{* T} x^{(i)}}{2}$求解出$b$​。最终得出分离超平面和分类决策函数。</p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><h4 id="SVM分类过程"><a href="#SVM分类过程" class="headerlink" title="SVM分类过程"></a>SVM分类过程</h4><p>对于一个数据点 $x$ 进行分类, 实际上是通过把 $x$ 带入到 $f(x)=w^{T} x+b$ 算出结果然后根据其正负号来进行类别划分的。</p><p>而$w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}$，所以分类函数为：</p><script type="math/tex; mode=display">\begin{aligned}f(x) & =\left(\sum_{i=1}^{n} \alpha_{i} y_{i} x_{i}\right)^{T} x+b \\& =\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle x_{i}, x\right\rangle+b\end{aligned}</script><p><strong>那么，对于新点$x$​的预测，只需要计算它与训练数据点的内积即可。</strong></p><blockquote><p>事实上，所有非支持向量所对应的系数$\alpha$​都是等于零的，因此对于新点的内积计算实际上只要针对少量的“支持向量”，而不是所有的训练数据。</p></blockquote><h4 id="核函数的作用"><a href="#核函数的作用" class="headerlink" title="核函数的作用"></a>核函数的作用</h4><p>对于非线性的情况，SVM 的处理方法是选择一个核函数 $κ(⋅,⋅)$​ ，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。</p><blockquote><p>而在核函数之前，如果用原始的方法，在用线性学习器学习一个非线性关系时，需要选择一个非线性特征集，并且将数据写成新的表达形式，这等价于应用一个固定的非线性映射，将数据映射到特征空间，在特征空间中使用线性学习器。</p></blockquote><p>如果将原来的分类函数</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle x_{i}, x\right\rangle+b</script><p>直接找一个映射 $\phi(\cdot)$，把原来的数据映射到新空间中, 再做线性SVM。就会有维度爆炸的问题。</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^{n} \alpha_{i} y_{i}\left\langle\phi\left(x_{i}\right), \phi(x)\right\rangle+b</script><p>所以相比映射到高维空间中，然后再根据内积的公式进行计算。核函数选择另一个方式：<strong>直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果</strong>。</p><h4 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h4><p>核函数是一个函数 $\kappa$，对所有 $x, z \in X$，满足 $\kappa(\mathbf{x}, \mathbf{z}) = \langle\phi(\mathbf{x}) \cdot \phi(\mathbf{z})\rangle$，这里 $\phi$ 是从 $X$ 到内积特征空间 $F$ 的映射。</p><p><strong>计算两个向量在隐式映射过后的空间中的内积的函数叫做核函数。</strong>它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就避免了直接在高维空间中的复杂计算。</p><h4 id="常见的核函数"><a href="#常见的核函数" class="headerlink" title="常见的核函数"></a>常见的核函数</h4><p>常见的核函数有：</p><ul><li>多项式核：$\kappa(x, y)=\left(\alpha x^{T} y+c\right)^{d}$</li><li>高斯核：$\kappa(x, y)=\exp \left(-\gamma|x-y|^{2}\right)$</li><li>线性核 ：$\kappa\left(x, y\right)=\left\langle x, y\right\rangle$</li></ul><h3 id="松弛变量处理离群点"><a href="#松弛变量处理离群点" class="headerlink" title="松弛变量处理离群点"></a>松弛变量处理离群点</h3><p>虽然通过映射 $\phi(\cdot)$ 将原始数据映射到高维空间之后，能够线性分隔的概率大大增加，但是对于某些情况还是很难处理。</p><p>例如一些离群点（偏离正常位置很远的数据点），会对SVM模型造成很大影响。</p><blockquote><p>因为超平面本身就是只有少数几个支持向量组成的，如果这些支持向量里又存在离群点的话，其影响就很大了</p></blockquote><p>通过向约束条件中加入松弛变量$\xi_{i}$：</p><script type="math/tex; mode=display">y_{i}\left(w^{T} x_{i}+b\right) \geq 1-\xi_{i}, \quad i=1, \ldots, n</script><p>允许数据点离超平面更近。并且向目标函数中加入惩罚项，限制这种松弛：</p><script type="math/tex; mode=display">\min \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{n} \xi_{i}</script><p>再进行上面的一系列操作（拉格朗日对偶、核函数），就可以得到一个完整的、可以处理线性和非线性、并能容忍噪音和离群点的支持向量机。</p><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><h4 id="MP模型"><a href="#MP模型" class="headerlink" title="MP模型"></a>MP模型</h4><p>最初提出的神经网络模型是MP（McCulloch-Pitts ）模型，其的权重是预先设置的：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427181414661.png" alt="image-20240427181414661"></p><h4 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h4><p>之后发展出了感知机，也被称为单层神经网络，其的权重是通过训练得到的，训练法则为：</p><script type="math/tex; mode=display">\begin{array}{l}W_{t} \leftarrow W_{t}+\Delta W_{t} \\\Delta W_{t}=\eta(y-\hat{y}) \boldsymbol{a}\end{array}</script><p>其$f$神经元中执行的是线性运算$\mathbf{z}=g(\boldsymbol{W} \times \boldsymbol{a})$，所以只能执行线性分类。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427181445146.png" alt="image-20240427181445146"></p><p>也是因为神经元执行的是线性运算，所以<strong>感知机只能做简单的线性分类任务</strong>，无法解决XOR（异或）问题。</p><h4 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>之后就发展出了多层感知机（多层的神经网络）</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427181959937.png" alt="image-20240427181959937"></p><p>并且其不再使用sgn函数做激活函数，而是使用sigmoid函数</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240427182037505.png" alt="image-20240427182037505"></p><p>关键在于: 从输入层到隐藏层时，<strong>数据在激活函数作用下发生了空间变换</strong></p><p>其通过前向传播和反向传播来进行训练，前向传播为了计算当前参数下的误差，反向传播是为了根据误差调整参数。反向传播常用的算法是梯度下降。</p><h3 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h3><p>神经网络的一个神经元的基础操作是对输入$x$执行：</p><ol><li>线性运算：$z=W x+b$​</li><li>通过激活函数：$y=\sigma(z)$</li></ol><p>从功能角度讲，神经网络就是多层的<strong>特征提取</strong>加上<strong>线性分类</strong>。</p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h4><p>人观测图片的特点： <strong>① 局部特征影响大 ② 重要位置常变化</strong> <strong>③ 采样压缩也没差</strong></p><p>根据前两个特点特点，设计卷积神经网络，就设计出了可以移动的卷积核。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240511163332296.png" alt="image-20240511163332296"></p><p>卷积过程中的步长（stride）指的是卷积核在输入图像上每次移动的像素数量；卷积操作前的填充（padding）操作，指的是在输入图像的边界周围添加额外的像素。</p><h5 id="卷积维度公式"><a href="#卷积维度公式" class="headerlink" title="卷积维度公式"></a>卷积维度公式</h5><p>假设图片尺寸为 $n_{h} \times n_{w} \times n_{c}$，卷积核为 $f \times f \times n_{c}$，步长 $s$，填充 $p$​。其中：</p><ul><li><p>$n_{h}$ 是高度，$n_{w}$ 是宽度，$n_{c}$ 是深度（通道数）</p></li><li><p>$f$ 是卷积核的尺寸，$n_{c}$​ 是卷积核的深度（与输入图片的深度相同）</p></li></ul><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240511164341249.png" alt="image-20240511164341249"></p><p>那么特征图（卷积层输出）维度公式：</p><script type="math/tex; mode=display">\begin{array}{l}\text { 高度 } h=\left\lfloor\frac{n_{h}-f+2 p}{s}+1\right\rfloor \\\text { 宽度 } w=\left\lfloor\frac{n_{w}-f+2 p}{s}+1\right\rfloor \\\text { 宽度 } k=K\end{array}</script><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>池化操作将特征图划分为若干个子区域，并对每个子区域进行统计汇总。</p><p>池化操作的方式可以有很多种，比如最大池化、平均池化等。</p><ul><li>最大池化：选取每个子区域内的最大值作为输出</li><li>平均池化：计算每个子区域内的平均值作为输出</li></ul><h3 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h3><p>循环神经网络要解决的槽填充问题：</p><p>I would like to arrive <u>Guangzhou</u> on <u>May</u>.</p><p>CNN和普通的神经网络都没有记忆功能，而RNN可以记忆。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240511183046525.png" alt="image-20240511183046525"></p><h3 id="长短期记忆网络（LSTM）"><a href="#长短期记忆网络（LSTM）" class="headerlink" title="长短期记忆网络（LSTM）"></a>长短期记忆网络（LSTM）</h3><p>RNN网络没有遗忘的功能，所以以往的所有输入都会影响输出，而LSTM加入了遗忘功能。它用特殊的神经元代替了普通神经网络中的神经元。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240511183946686.png" alt="image-20240511183946686"></p><p>这个特殊的神经网络有三个门：</p><ul><li>输出门：控制是否输出</li><li>遗忘门：选择是否遗忘</li><li>输入门：控制是否输入</li></ul><p>一份输入要充当这三个门的信号和神经元的输入。</p><p>缺点是参数量大了，训练和计算时间也长了。</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>强化学习是通过与环境进行交互、试错，从而学会做出一系列好的决策。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init:{&#39;flowchart&#39;:{&#39;curve&#39;:&#39;basis&#39;}}}%%flowchart TDa[Agent]--Action--&gt;e[Environment]e--Reward--&gt;ae--state--&gt;a  </pre></div><p>强化学习的特殊之处在于：</p><ul><li><p>环境刚开始是未知的</p></li><li><p>智能体要与环境互动</p></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="随机性的两个来源"><a href="#随机性的两个来源" class="headerlink" title="随机性的两个来源"></a>随机性的两个来源</h4><p>随机性的来源有两个：</p><ul><li><p>给定状态，智能体的行为具有随机性，由策略来决定。</p><script type="math/tex; mode=display">A \sim \pi(\cdot \mid s)</script><p><strong>其中$\pi$是策略</strong>，$\pi(a_1|s)$代表的是在状态$s$下选择行为$a_1$的概率。</p></li><li><p>状态的转移也具有随机性，由状态转移函数来决定。</p><script type="math/tex; mode=display">S^{\prime} \sim p(\cdot \mid s, a)</script><p>其中$S’$是次态，$p(\cdot \mid s, a)$指的是在状态$s$和行为$a$下转移到次态$S’$的概率。</p></li></ul><h4 id="AI玩游戏"><a href="#AI玩游戏" class="headerlink" title="AI玩游戏"></a>AI玩游戏</h4><p>可以将AI玩游戏的过程看成一个由状态（$s$）、行为（$a$）和奖励（$r$）组成的序列。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240523192432446.png" alt="image-20240523192432446"></p><p>一个完整的交互序列（episode），就是从初始状态开始到最终状态结束。一个好的策略能让最后<strong>积累</strong>的奖励最大。</p><h4 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h4><p>回报（Return）即累计未来奖励。假设$R_t$是$t$时刻的奖励，那么回报$U_t$的定义为：</p><script type="math/tex; mode=display">U_{\mathrm{t}}=R_{\mathrm{t}}+\gamma R_{\mathrm{t}+1}+\gamma^{2} R_{\mathrm{t}+2}+\cdots+\gamma^{\mathrm{n}-\mathrm{t}} R_{\mathrm{n}} .</script><p>因为在$t$时刻，未来的奖励具有随机性，所以$U_t$也具有随机性。并且因为奖励的越早，奖励越具有吸引力。所以随着获得奖励所需的时间越久，其的价值也越低，在公式中以衰减因子$\gamma$表示。</p><h4 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h4><h5 id="行为价值函数"><a href="#行为价值函数" class="headerlink" title="行为价值函数"></a>行为价值函数</h5><p>行为价值函数$Q_\pi(s,a)$是针对策略$\pi$而言的。其的定义如下：</p><script type="math/tex; mode=display">Q_{\pi}\left(s_{t}, a_{t}\right)=\mathbb{E}\left[U_{t} \mid S_{t}=s_{t}, A_{t}=a_{t}\right]</script><p>$Q_{\pi}\left(s_{t}, a_{t}\right)$代表的是，在$\pi$策略下，在$s_t$的状态下、选择行动$a_t$，获得回报的期望。</p><p>可以定义最优行为价值函数为：</p><script type="math/tex; mode=display">Q^{\star}\left(s_{t}, a_{t}\right)=\max _{\pi} Q_{\pi}\left(s_{t}, a_{t}\right)</script><p>其代表着在$s_t$的状态下、选择行动$a_t$，在所有策略中，能获得的最大的回报的期望。</p><h5 id="状态价值函数"><a href="#状态价值函数" class="headerlink" title="状态价值函数"></a>状态价值函数</h5><p>状态价值函数$V_\pi(s_t)$的定义如下：</p><script type="math/tex; mode=display">V_{\pi}\left(s_{t}\right)=\mathbb{E}_{A}\left[Q_{\pi}\left(s_{t}, A\right)\right]=\sum_{a} \pi\left(a \mid s_{t}\right) \cdot Q_{\pi}\left(s_{t}, a\right)</script><p>$V_\pi(s_t)$代表的是，在$\pi$策略下，在$s_t$的状态下，获得回报的期望。</p><blockquote><p>状态价值函数和行为无关。</p></blockquote><p>可以用$\mathbb{E}_{S}\left[V_{\pi}(S)\right]$来衡量策略$\pi$有多棒。</p><h3 id="进行强化学习"><a href="#进行强化学习" class="headerlink" title="进行强化学习"></a>进行强化学习</h3><p>单智能体强化学习问题可以形式化定义为马尔可夫决策过程（MDP）六元组：</p><script type="math/tex; mode=display">\left(S, A, R, T, P_{0}, \gamma\right)</script><p>其中：</p><ul><li>$S$ 表示状态空间，</li><li>$\boldsymbol{A}$ 表示动作空间，</li><li>$R=R(S, \boldsymbol{a})$ 表示奖励函数，</li><li>$T: S \times \boldsymbol{A} \times S \rightarrow [\mathbf{0}, \mathbf{1}]$ 表示状态转移函数，</li><li>$\boldsymbol{P}_{0}$ 表示初始状态分布，</li><li>$\gamma$ 是折扣因子。</li></ul><p>强化学习的学习目标: <strong>找到能最大化累计奖励的策略$\pi$​</strong>。</p><hr><p>有这几种学习方式：</p><ul><li>基于价值（Value-based learning）：它的目标是学习出一个价值函数，这个价值函数能够评估给定状态下采取某个动作的期望回报。</li><li>基于策略（Policy-based learning）：它直接学习策略函数，这个策略函数能够根据当前状态直接输出一个动作分布或确定性的动作。</li><li>Actor-critic方法：它结合了Value-based learning和Policy-based learning两种方法的优点。</li></ul><h4 id="基于价值学习"><a href="#基于价值学习" class="headerlink" title="基于价值学习"></a>基于价值学习</h4><p>基于价值学习需要近似$Q^{\star}\left(s_{t}, a_{t}\right)$，那么就可以知道每一个行动$a_t$能带来多大的价值。近似所用的方法是DQN（Deep Q-Network），即深度Q网络。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240524094425103.png" alt="image-20240524094425103"></p><p>但在训练DQN的时候，和训练任何一个神经网络一样，需要给出标签值，也就是$a_t$实际的价值是多少，然后与预测出来的$a_t$的价值去求损失。但直接求实际价值又太慢了（需要完整的完成一个迭代），所以就有了TD学习（Temporal Difference (TD) Learning）。</p><p>TD学习将实际价值近似为「当前奖励+下一步预测值」，只关注时间差分，即当前时间步的预测值和下一时间步的预测值之间的差异。数学的表达形式为：</p><script type="math/tex; mode=display">Q\left(s_{t}, a_{t} ; \mathbf{w}\right) \approx r_{t}+\gamma \cdot Q\left(s_{t+1}, a_{t+1} ; \mathbf{w}\right)</script><p>右边就是「当前奖励+下一步预测值」（还乘了损失因子），用其来近似实际价值。然后就可以用这个近似的实际价值当做神经网络的标签，去进行训练。</p><h4 id="基于策略学习"><a href="#基于策略学习" class="headerlink" title="基于策略学习"></a>基于策略学习</h4><p>基于策略学习和基于价值学习的方法类似，它也是用神经网络去近似策略函数$\pi(a|s)$。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240524102021748.png" alt="image-20240524102021748"></p><p>它的目的是优化${\theta}$使得$J({\theta})=\mathbb{E}_{S}[V(S ; {\theta})]$​最大。也就是让所有状态下采取给定策略得到的回报期望最大。这个回报期望可以通过跑完全程得到，也可以通过训练一个神经网络去预测这个回报。</p><p>在优化的过程中，梯度为让$V(s;\theta)$上升最快的方向。神经网络中是减去梯度，来梯度下降，这里是加上梯度来梯度上升。</p><h4 id="Actor-Critic方法"><a href="#Actor-Critic方法" class="headerlink" title="Actor-Critic方法"></a>Actor-Critic方法</h4><p>Actor-Critic方法结合了基于价值学习和基于策略学习两者，它有一个actor作为策略网络，有一个critic作为价值网络：</p><ul><li>actor：用神经网络$\pi(a|s ; \theta)$去近似$\pi(a|s)$。</li><li>critic：用神经网络$q(s,a;\omega)$去近似$Q_\pi(s,a)$</li></ul><p>在训练过程中两者是一起训练的，训练的过程如下：</p><ol><li>观察到状态$s_t$</li><li>actor根据自己的$\pi(a|s ; \theta)$网络给出的概率，（按概率）随机选一个动作执行。</li><li>观察到下一个状态$s_{t+1}$并得到奖励$r_t$</li><li>用TD学习更新critic网络中的参数$\omega$</li><li>用策略梯度（需要critic预测回报），更新critic网络中的$\theta$</li></ol><p>在训练全部完成后，以后做出决策就只需要策略网络（actor），而不需要critic。</p><h3 id="AlphaGo"><a href="#AlphaGo" class="headerlink" title="AlphaGo"></a>AlphaGo</h3><p>AlphaGo的训练有三步：</p><ol><li>通过behavior cloning初始化策略网络</li><li>通过策略梯度训练策略网络。</li><li>训练完策略网络后，用策略网络去训练一个价值网络。</li></ol><p>最后通过蒙特卡洛树搜索的方法使用策略网络和价值网络。</p><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><h5 id="behavior-cloning"><a href="#behavior-cloning" class="headerlink" title="behavior cloning"></a>behavior cloning</h5><p>因为如果直接进行强化学习，速度太慢。所以首先根据人类已有的棋局资料，去训练策略网络。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240529171455797.png" alt="image-20240529171455797"></p><h5 id="训练策略网络"><a href="#训练策略网络" class="headerlink" title="训练策略网络"></a>训练策略网络</h5><p>因为仅仅用behavior cloning还会有很多状况考虑不到。所以还需要训练策略网络。在训练策略网络的过程中，通过跑完全程得到回报期望。即如果最终赢了，这局所有的行为的分数都+1；如果平局则这句行为的分数不变；如果最终输了，这局所有行为的分数都-1。</p><h5 id="训练价值网络"><a href="#训练价值网络" class="headerlink" title="训练价值网络"></a>训练价值网络</h5><p>仅用策略网络，有可能出现在某一步走错之后步步错。所以还需要用策略网络训练一个价值网络（与之前不同，这里是拟合状态价值函数）。之后就可以结合策略网络和价值网络进行决策。</p><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>运行的过程用到了蒙特卡洛树搜索的方法。其有四步：</p><ul><li><p>Selection：</p><ul><li><p>设当前状态为$s_t$</p></li><li><p>对所有有效的行为$a$，计算行为$a$的得分：</p><script type="math/tex; mode=display">\operatorname{score}(a)=Q(a)+\eta * \frac{\pi\left(a | s_{t} ; \theta\right)}{1+N(a)}</script><p>其中$Q(a)$是蒙特卡洛树计算的行为得分，$\pi\left(a | s_{t}\right)$是策略网络给出的行为概率，$N(a)$是到目前为止一共选择了行为$a$​多少次。</p></li><li><p>选择具有最大$\operatorname{score}(a)$的行为$a_t$​。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240529191318821.png" alt="image-20240529191318821"></p></li></ul></li><li><p>Expansion：</p><ul><li><p>选择了$a_t$行为，所以到达了$s_{t+1}$的状态。</p></li><li><p>然后通过策略网络，不断自我博弈，直到走到游戏结束</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240529191348057.png" alt="image-20240529191348057"></p></li></ul></li><li><p>Evaluation：</p><ul><li>计算：<script type="math/tex; mode=display">V(s_{t+1})=\frac{1}{2} v\left(s_{t+1} ; w\right)+\frac{1}{2} r_{T}</script>其中$v\left(s_{\mathrm{t}+1} ; {w}\right)$是价值网络的评分；如果赢了，则$r_T=1$，如果输了，则$r_T=-1$。</li></ul></li><li><p>Backup：</p><ul><li><p>重复上面三步，每一个$a_t$都会记录一系列的$V_i$​值</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240529191705228.png" alt="image-20240529191705228"></p></li><li><p>更新</p><script type="math/tex; mode=display">\left.Q\left(a_{\mathrm{t}}\right)=\text { mean(the recorded } V^{\prime} s\right)</script></li></ul></li></ul><p>最后，选择被蒙特卡洛树搜索选择最多次的$a_t$作为下一个行为。</p><h1 id="数据降维"><a href="#数据降维" class="headerlink" title="数据降维"></a>数据降维</h1><p>大多数机器学习和数据挖掘技术可能对高维数据无效。并且高维的数据会比较稀疏，有可能导致数据“过于”可分，导致过拟合。而且高维度中用距离来衡量样本相似性的方法会渐渐失效。</p><p>数据降维不仅可以帮助可视化，还可以进行数据压缩和噪声过滤。</p><p>数据降维的方法主要有特征选择与特征降维。它们的区别如下：</p><ol><li>特征选择：减少特征的数量，只使用选中的特征。</li><li>特征降维：所有原始特征都用于计算，但最终模型使用的是这些原始特征的线性或非线性组合，以降低数据的维度</li></ol><p>特征降维的方法有：</p><ul><li>无监督学习：<ul><li>截断奇异值分解（Truncated Singular Value Decomposition, SVD）</li><li>独立成分分析（Independent Component Analysis, ICA）</li><li>主成分分析（Principal Component Analysis, PCA）</li><li>局部线性嵌入（Locally Linear Embedding, LLE）</li><li>拉普拉斯特征映射（Laplacian Eigenmaps, LE）</li></ul></li><li>有监督学习：<ul><li>线性判别分析（Linear Discriminant Analysis, LDA）</li><li>典型相关分析（Canonical Correlation Analysis, CCA）</li></ul></li></ul><h2 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h2><p>主成分分析（PCA）是一种常用于降维的数据分析技术，通过<strong>将原始高维数据投影到新的低维空间来保留数据中的主要信息</strong>。以下是PCA的算法流程：</p><ol><li><p><strong>数据标准化</strong>：将数据标准化为均值为0，方差为1的形式。这一步是为了消除不同特征之间量纲不一致的影响。</p><script type="math/tex; mode=display">\text{Standardized data} = \frac{X - \mu}{\sigma}</script></li><li><p><strong>计算协方差矩阵</strong>：计算标准化数据的协方差矩阵，以了解特征之间的相关性。</p><script type="math/tex; mode=display">\mathbf{C} = \frac{1}{n-1} \mathbf{X}^T \mathbf{X}</script><p>其中，$\mathbf{X}$ 是标准化后的数据矩阵， $n$​是样本数量。</p><blockquote><p>如果两个变量的协方差为正，则表示一个变量的增加通常与另一个变量的增加相联系；如果协方差为负，则表示一个变量的增加通常与另一个变量的减少相联系。</p></blockquote></li><li><p><strong>特征值分解</strong>：对协方差矩阵进行特征值分解，得到特征值和特征向量。</p><script type="math/tex; mode=display">\mathbf{C} \mathbf{v} = \lambda \mathbf{v}</script><p>其中，$\lambda$ 为特征值，$\mathbf{v}$ 为对应的特征向量。</p></li><li><p><strong>选择主成分</strong>：根据特征值的大小选择前k个最大的特征值对应的特征向量，作为主成分。</p></li><li><p><strong>转换数据</strong>：将原始数据投影到选定的特征向量空间，得到降维后的数据。</p><script type="math/tex; mode=display">\mathbf{X}_{\text{new}} = \mathbf{X} \mathbf{W}</script><p>其中， $\mathbf{W}$ 是由选定的特征向量构成的矩阵。</p></li></ol><h3 id="示例：应用PCA进行降维"><a href="#示例：应用PCA进行降维" class="headerlink" title="示例：应用PCA进行降维"></a>示例：应用PCA进行降维</h3><p>假设我们有一个三维数据集如下：</p><div class="table-container"><table><thead><tr><th>特征1</th><th>特征2</th><th>特征3</th></tr></thead><tbody><tr><td>2.5</td><td>2.4</td><td>3.5</td></tr><tr><td>0.5</td><td>0.7</td><td>1.2</td></tr><tr><td>2.2</td><td>2.9</td><td>3.1</td></tr><tr><td>1.9</td><td>2.2</td><td>2.9</td></tr><tr><td>3.1</td><td>3.0</td><td>3.6</td></tr><tr><td>2.3</td><td>2.7</td><td>3.4</td></tr><tr><td>2.0</td><td>1.6</td><td>2.7</td></tr><tr><td>1.0</td><td>1.1</td><td>1.2</td></tr><tr><td>1.5</td><td>1.6</td><td>1.9</td></tr><tr><td>1.1</td><td>0.9</td><td>1.5</td></tr></tbody></table></div><h4 id="1-数据标准化"><a href="#1-数据标准化" class="headerlink" title="1. 数据标准化"></a>1. 数据标准化</h4><p>将每个特征标准化，标准化后的数据：</p><script type="math/tex; mode=display">\begin{bmatrix}0.926 & 0.610 & 1.096 \\-1.759 & -1.507 & -1.425 \\0.524 & 1.233 & 0.658 \\0.121 & 0.361 & 0.439 \\1.732 & 1.357 & 1.206 \\0.658 & 0.984 & 0.987 \\0.255 & -0.386 & 0.219 \\-1.087 & -1.009 & -1.425 \\-0.416 & -0.386 & -0.658 \\-0.953 & -1.258 & -1.096 \\\end{bmatrix}</script><h4 id="2-计算协方差矩阵"><a href="#2-计算协方差矩阵" class="headerlink" title="2. 计算协方差矩阵"></a>2. 计算协方差矩阵</h4><p>计算标准化数据的协方差矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}1.111 & 1.029 & 1.065 \\1.029 & 1.111 & 1.042 \\1.065 & 1.042 & 1.111 \\\end{bmatrix}</script><h4 id="3-特征值分解"><a href="#3-特征值分解" class="headerlink" title="3. 特征值分解"></a>3. 特征值分解</h4><p>对协方差矩阵进行特征值分解，得到特征值和特征向量。</p><p>特征值：</p><script type="math/tex; mode=display">\begin{bmatrix}3.201, & 0.045, & 0.087\end{bmatrix}</script><p>特征向量：</p><script type="math/tex; mode=display">\begin{bmatrix}-0.578 & -0.619 & 0.531 \\-0.574 & -0.155 & -0.804 \\-0.580 & 0.770 & 0.266 \\\end{bmatrix}</script><h4 id="4-选择主成分"><a href="#4-选择主成分" class="headerlink" title="4. 选择主成分"></a>4. 选择主成分</h4><p>选择前两个最大的特征值对应的特征向量作为主成分，则选择的特征向量：</p><script type="math/tex; mode=display">\begin{bmatrix}-0.578 & 0.531 \\-0.574 & -0.804 \\-0.580 & 0.266 \\\end{bmatrix}</script><h4 id="5-转换数据"><a href="#5-转换数据" class="headerlink" title="5. 转换数据"></a>5. 转换数据</h4><p>将原始数据投影到选定的特征向量空间，转换后的数据：</p><script type="math/tex; mode=display">\begin{bmatrix}-1.522 & 0.293 \\2.708 & -0.102 \\-1.392 & -0.538 \\-0.532 & -0.110 \\-2.479 & 0.149 \\-1.517 & -0.179 \\-0.053 & 0.504 \\2.034 & -0.146 \\0.844 & -0.086 \\1.909 & 0.213 \\\end{bmatrix}</script><p>这样，我们将原始的三维数据降维成了二维数据，同时保留了数据中的主要信息。</p><h2 id="SVD（奇异值分解）"><a href="#SVD（奇异值分解）" class="headerlink" title="SVD（奇异值分解）"></a>SVD（奇异值分解）</h2><p>SVD是另一种数据降维的技术。算法流程如下：</p><ol><li><p><strong>构建矩阵</strong>：构建一个数据矩阵 $A$，其中包含要处理的所有数据。</p></li><li><p><strong>奇异值分解</strong>：对矩阵 $A$ 进行奇异值分解，得到三个矩阵 $U$、$\Sigma$ 和 $V^T$。</p><script type="math/tex; mode=display">A = U \Sigma V^T</script><p>其中，$ U $是$ m \times m $的正交矩阵，$ \Sigma $是$ m \times n $的对角矩阵，$ V^T $是$ n \times n $​ 的正交矩阵。</p></li><li><p><strong>选择主成分</strong>：根据奇异值的大小选择前k个最大的奇异值，构建低秩近似。</p></li><li><p><strong>重构矩阵</strong>：利用选择的奇异值和对应的左右奇异向量重构原始矩阵的低秩近似。</p><script type="math/tex; mode=display">A_k = U_k \Sigma_k V_k^T</script><p>其中，$ U_k $和$ V_k $分别是$ U $和$ V $的前 k 列，$ \Sigma_k $是$ \Sigma $ 的前 k 个奇异值构成的对角矩阵。</p></li></ol><p>给定一个向量$q$，可以通过$qV$得到它属于哪一个类。</p><h3 id="示例：Latent-Semantic-Indexing（潜在语义索引）"><a href="#示例：Latent-Semantic-Indexing（潜在语义索引）" class="headerlink" title="示例：Latent Semantic Indexing（潜在语义索引）"></a>示例：Latent Semantic Indexing（潜在语义索引）</h3><div class="table-container"><table><thead><tr><th>document\term</th><th>data</th><th>information</th><th>retrieval</th><th>brain</th><th>lung</th></tr></thead><tbody><tr><td>CS-TR1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>CS-TR2</td><td>2</td><td>2</td><td>2</td><td>0</td><td>0</td></tr><tr><td>CS-TR3</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>CS-TR4</td><td>5</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>MED-TR1</td><td>0</td><td>0</td><td>0</td><td>2</td><td>2</td></tr><tr><td>MED-TR2</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td></tr><tr><td>MED-TR3</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table></div><p>假设有这样的一个数据集，其中第一列是文档类型（CS代表计算机，MED代表医学）。可以看到data、information、retrieval这些词只在计算机类的文档中出现；而brain、lung只在医学类的文档中出现。</p><h4 id="1-构建矩阵"><a href="#1-构建矩阵" class="headerlink" title="1. 构建矩阵"></a>1. 构建矩阵</h4><p>构建文档-词项矩阵  $A$ ：</p><script type="math/tex; mode=display">A = \begin{bmatrix}1 & 1 & 1 & 0 & 0 \\2 & 2 & 2 & 0 & 0 \\1 & 1 & 1 & 0 & 0 \\5 & 5 & 5 & 0 & 0 \\0 & 0 & 0 & 2 & 2 \\0 & 0 & 0 & 3 & 3 \\0 & 0 & 0 & 1 & 1 \\\end{bmatrix}</script><h4 id="2-奇异值分解"><a href="#2-奇异值分解" class="headerlink" title="2. 奇异值分解"></a>2. 奇异值分解</h4><p>对矩阵$A$进行奇异值分解，可以得到三个矩阵为：</p><script type="math/tex; mode=display">U \Sigma V^T=\left[\begin{array}{ll}0.18 & 0 \\0.36 & 0 \\0.18 & 0 \\0.90 & 0 \\0 & 0.53 \\0 & 0.80 \\0 & 0.27\end{array}\right]\times\left[\begin{array}{ll}9.64 & 0 \\0 & 5.29\end{array}\right]\times\left[\begin{array}{ll}0.58 & 0.58 & 0.58 & 0 & 0 \\0 & 0 & 0 & 0.71 & 0.71\end{array}\right]</script><p>在这里其实就可以发现矩阵$U$前三行第一列不为0的刚好对应的是CS类的。而第二列不为0的刚好对应的是MED类的。而$V$也同理。</p><h4 id="3-选择主成分"><a href="#3-选择主成分" class="headerlink" title="3. 选择主成分"></a>3. 选择主成分</h4><p>这里可以看到为9.64的奇异值较大，所以就选择其。</p><h4 id="4-重构矩阵"><a href="#4-重构矩阵" class="headerlink" title="4. 重构矩阵"></a>4. 重构矩阵</h4><p>然后将$\Sigma$矩阵中的没有选择的奇异值改为0。也就是：</p><script type="math/tex; mode=display">\left[\begin{array}{ll}9.64 & 0 \\0 & 5.29\end{array}\right]\rightarrow\left[\begin{array}{ll}9.64 & 0 \\0 & 0\end{array}\right]</script><p>然后再重新计算$A_k$。</p><script type="math/tex; mode=display">A_k=\left[\begin{array}{ll}0.18 & 0 \\0.36 & 0 \\0.18 & 0 \\0.90 & 0 \\0 & 0.53 \\0 & 0.80 \\0 & 0.27\end{array}\right]\times\left[\begin{array}{ll}9.64 & 0 \\0 & 0\end{array}\right]\times\left[\begin{array}{ll}0.58 & 0.58 & 0.58 & 0 & 0 \\0 & 0 & 0 & 0.71 & 0.71\end{array}\right]</script><p>得到低秩近似$A_k$：</p><script type="math/tex; mode=display">A_k=\left[\begin{array}{lllll}1 & 1 & 1 & 0 & 0 \\2 & 2 & 2 & 0 & 0 \\1 & 1 & 1 & 0 & 0 \\5 & 5 & 5 & 0 & 0 \\0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0\end{array}\right]</script><h2 id="LDA（线性判别法）"><a href="#LDA（线性判别法）" class="headerlink" title="LDA（线性判别法）"></a>LDA（线性判别法）</h2><p>LDA的原理是，将带上标签的数据（点），通过投影的方法，投影到维度更低的空间中，使得投影后的点，会形成按类别区分，一簇一簇的情况，相同类别的点，将会在投影后的空间中更接近。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/人工智能/image-20240612113559022.png" alt="image-20240612113559022"></p><p>参考文章：<a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html">https://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html</a></p><h2 id="LLE（局部线性嵌入）"><a href="#LLE（局部线性嵌入）" class="headerlink" title="LLE（局部线性嵌入）"></a>LLE（局部线性嵌入）</h2><p>LLE(Locally Linear Embedding)优势在于降维时保持样本局部的线性特征。它广泛的用于图像图像识别，高维数据可视化等领域。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>LLE首先假设数据在较小的局部是线性的。即某一个数据可以由它邻域中的几个样本来线性表示。</p><p>比如有一个样本 $x_1$，在它的原始高维邻域里用K-近邻思想找到和它最近的三个样本 $x_2, x_3, x_4$。然后假设 $x_1$ 可以由 $x_2, x_3, x_4$ 线性表示，即：</p><script type="math/tex; mode=display">x_1 = w_{12}x_2 + w_{13}x_3 + w_{14}x_4</script><p>其中，$w_{12}, w_{13}, w_{14}$ 为权重系数。在通过LLE降维后，希望 $x_1$ 在低维空间对应的投影 $x’_1$ 和 $x_2, x_3, x_4$ 对应的投影 $x’_2, x’_3, x’_4$ 也尽量保持同样的线性关系，即</p><script type="math/tex; mode=display">x'_1 \approx w_{12}x'_2 + w_{13}x'_3 + w_{14}x'_4</script><p>也就是说，投影前后线性关系的权重系数 $w_{12}, w_{13}, w_{14}$ 是尽量不变或者最小改变的。</p><p>从上面可以看出，线性关系只在样本的附近起作用，离样本远的样本对局部的线性关系没有影响，因此降维的复杂度降低了很多。</p><p>参考文章：<a href="https://www.cnblogs.com/pinard/p/6266408.html">https://www.cnblogs.com/pinard/p/6266408.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 我重生了，重生在考试前一天 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Macports常用指令</title>
      <link href="/post/554039588.html"/>
      <url>/post/554039588.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果要安装名为<code>portname</code>的端口，则在命令行中输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port install portname</span><br></pre></td></tr></table></figure><p>如果想查看安装时的详细信息，则加上<code>-v</code>参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port -v install portname</span><br></pre></td></tr></table></figure><p>如果安装失败了想要重装，在重新运行<code>sudo port install portname</code>之前，需要运行以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port clean portname</span><br></pre></td></tr></table></figure><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>如果想卸载名为<code>portname</code>的端口，则在命令行中输入以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port uninstall portname</span><br></pre></td></tr></table></figure><p>如果想将安装<code>portname</code>时同时安装的那些依赖卸载，则加上<code>--follow-dependencies</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo port uninstall --follow-dependents portname</span><br></pre></td></tr></table></figure><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>如果要更新Macports或者安装的软件包，可以运行下面两条指令：</p><ol><li><code>sudo port selfupdate</code>：<ul><li>这个命令会更新MacPorts本身，即MacPorts的基础系统。</li><li>同时，它会同步ports树，即更新可用的软件包列表。（只是软件包列表，不是软件包本身）</li><li>如果检测到有新的MacPorts版本，它会自动升级已安装的MacPorts基础系统到最新版本。</li><li>使用<code>--no-sync</code>参数时，它只会检查并安装（如果有）新的MacPorts版本，而不会更新ports树。</li></ul></li><li><code>sudo port upgrade outdated</code>：<ul><li>这个命令会升级所有已安装的、有过时新版本的ports（软件包）及其依赖到MacPorts中可用的最新版本。</li><li>通常，会运行这个命令来更新所有有更新可用的ports（软件包）。</li><li>也可以选择性地升级特定的ports，但这通常不推荐，因为未升级的ports可能会导致软件错误。</li></ul></li></ol><p><code>ports</code>树就像一个图书馆的索引系统，而里面的<code>ports</code>是一本本具体的书</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Macports指导手册：<a href="https://guide.macports.org">https://guide.macports.org</a></p><p>Macports端口信息：<a href="https://ports.macports.org/">https://ports.macports.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm配Jupyter NoteBook</title>
      <link href="/post/3576418838.html"/>
      <url>/post/3576418838.html</url>
      
        <content type="html"><![CDATA[<p>配置：</p><ul><li>Mac</li><li>Pycharm 2024.1</li></ul><hr><p>首先，需要有Pycharm Professional（学生免费）。</p><p>然后点击左下角终端：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/Pycharm配Jupyter/image-20240523210445720.png" alt="image-20240523210445720"></p><p>命令行中输入<code>pip install jupyter</code>。</p><p>之后新建一个<code>Jupyter Notebook</code>文件，就可以愉快写代码了。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/Pycharm配Jupyter/image-20240523210534667.png" alt="image-20240523210534667"></p>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块和cmake</title>
      <link href="/post/2136934485.html"/>
      <url>/post/2136934485.html</url>
      
        <content type="html"><![CDATA[<p>首先需要指定cmake的最低版本为3.28（3.28才支持扫描模块）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(untitle)</span><br></pre></td></tr></table></figure><p>然后需要设置C++的标准为C++20（C++20才有模块），并启用了对C++模块的支持。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure><p>创建了一个名为<code>simple_module</code>的库。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(simple_module</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>将几个<code>.cppm</code>文件作为C++模块添加到<code>simple_module</code>库中。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(simple_module</span><br><span class="line">        PUBLIC</span><br><span class="line">        FILE_SET CXX_MODULES FILES</span><br><span class="line">        simple.cppm</span><br><span class="line">        simpe_1.cppm</span><br><span class="line">        simple_2.cppm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>这行代码创建了一个名为<code>untitled1</code>的可执行文件，其主文件为<code>main.cpp</code>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(untitled1 main.cpp)</span><br></pre></td></tr></table></figure><p>最后，将<code>simple_module</code>库链接到<code>untitled1</code>可执行文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(untitled1 simple_module)</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(untitled1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(simple_module</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(simple_module</span><br><span class="line">        PUBLIC</span><br><span class="line">        FILE_SET CXX_MODULES FILES</span><br><span class="line">        simple.cppm</span><br><span class="line">        simpe_1.cppm</span><br><span class="line">        simple_2.cppm</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(untitled1 main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(untitled1 simple_module)</span><br></pre></td></tr></table></figure><blockquote><p>注意，编译器需要支持对模块的扫描</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac用ssh连linux服务器</title>
      <link href="/post/1909324461.html"/>
      <url>/post/1909324461.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网上的一些ssh免密连接linux服务器的资料都写的过于复杂，因此笔者写了一份简明的教程。</p><p>配置如下：</p><ul><li>客户端（发起SSH连接的一方）：<strong>Mac Sonoma14.4.1</strong> </li><li>服务器（接受SSH请求的一方）：22.04.1-Ubuntu </li></ul><h1 id="简单SSH连接"><a href="#简单SSH连接" class="headerlink" title="简单SSH连接"></a>简单SSH连接</h1><p>基本的<code>ssh</code>命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>例如，如果用户名是<code>john</code>，想要连接到主机地址为<code>example.com</code>的远程服务器，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh john@example.com</span><br></pre></td></tr></table></figure><p>这个命令会尝试以用户<code>john</code>的身份建立到<code>example.com</code>的SSH连接。如果连接成功，将需要提供密码（如果有的话），之后就可以开始远程操作该服务器了。</p><p>可以使用远程主机的IP地址来代替域名。例如，如果远程服务器的IP地址是<code>192.168.1.100</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@192.168.1.100</span><br></pre></td></tr></table></figure><h1 id="SSH免密连接"><a href="#SSH免密连接" class="headerlink" title="SSH免密连接"></a>SSH免密连接</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>SSH免密连接需要在客户端生成公钥和私钥：</p><ul><li>公钥：公钥将复制到服务器一端。</li><li>私钥：私钥要保存在客户端本地，也就是Mac上。</li></ul><p>在SSH连接的时候，会根据公钥和私钥进行验证，具体的过程如下：</p><blockquote><ul><li>服务器使用存储的公钥对客户端发送的认证请求进行加密，生成一个挑战（challenge）。</li><li>客户端使用自己的私钥对挑战进行解密，然后将解密结果发送回服务器。</li><li>服务器验证收到的解密结果是否与原始挑战匹配。如果匹配，服务器就知道客户端持有对应的私钥，因此认证成功</li></ul></blockquote><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h3><p>如果不想知道详细的过程，可以直接执行以下的命令：</p><p>首先在Mac终端上执行下面指令生成公钥秘钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里用任意邮箱替代<code>&quot;your_email@qq.com&quot;</code>即可。</p></blockquote><p>然后在终端中，SSH连接到服务器上并进行一系列权限设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>在终端中，用<code>exit</code>退出SSH：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>在终端中，拷贝公钥到服务器<code>~/.ssh/authorized_keys</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>之后就可以用ssh免密登陆了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="生成私钥与公钥"><a href="#生成私钥与公钥" class="headerlink" title="生成私钥与公钥"></a>生成私钥与公钥</h3><p>首先，打开Mac上的终端（Command+空格搜索终端即可）。然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@qq.com&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>-t rsa</code>：指定要创建的密钥类型。这里使用的是RSA算法，RSA是一种非对称加密算法，广泛用于SSH密钥生成。</li><li><code>-b 4096</code>：指定密钥的长度。这里设置为4096位。密钥长度越长，安全性越高，但同时也会增加计算负担。4096位是一个当前普遍认为安全的长度。</li><li><code>-C &quot;your_email@qq.com&quot;</code>：添加注释。这里的注释是邮箱<code>your_email@qq.com</code>，这个注释会添加到公钥文件中，帮助识别密钥的拥有者。这通常用于当多个密钥存在时，区分不同的密钥。</li></ul><p>这个秘钥会生成在你的Mac的<code>用户名/.ssh</code>文件夹下。</p><h3 id="更改服务器中文件夹权限"><a href="#更改服务器中文件夹权限" class="headerlink" title="更改服务器中文件夹权限"></a>更改服务器中文件夹权限</h3><h4 id="更改-ssh文件夹权限"><a href="#更改-ssh文件夹权限" class="headerlink" title="更改.ssh文件夹权限"></a>更改.ssh文件夹权限</h4><p>先使用密码<a href="#简单SSH连接">手动登录到服务器</a>上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><p>然后检查 <code>.ssh</code> 目录权限（之后要把公钥复制到.ssh/authorized_keys下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ld ~/.ssh</span><br></pre></td></tr></table></figure><p>会看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwxr-x 2 node1 node1 4096  4月 20 20:47 /home/node1/.ssh</span><br></pre></td></tr></table></figure><p><code>drwxrwxr-x</code>：这部分表示文件（或目录）的权限。这里<code>d</code>表示这是一个目录。</p><ul><li>接下来的三个字符<code>rwx</code>表示目录所有者（user，这里是node1）的权限，</li><li>再接下来的三个字符<code>rwx</code>表示所属组（group，这里也是node1）的权限。</li><li>最后的三个字符<code>r-x</code>表示其他用户（others）的权限。</li></ul><p>所以这里的意思是所有者和所属组有读写和执行权限，而其他用户有读和执行权限，但没有写权限。</p><p><code>.ssh</code> 目录的权限过于宽松，任何用户都可以进入这个目录。所以更改一下其的权限，将 <code>.ssh</code> 目录的权限修改为只有所有者可以读写执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure><blockquote><p><code>chmod</code>（change mode）： <code>chmod</code> 命令用于改变文件或目录的访问权限，权限设置使用符号表示法或八进制表示法。</p></blockquote><h4 id="更改-ssh-authorized-keys的权限"><a href="#更改-ssh-authorized-keys的权限" class="headerlink" title="更改.ssh/authorized_keys的权限"></a>更改.ssh/authorized_keys的权限</h4><p>查看<code>.ssh/authorized_keys</code>的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 96  3月 11 21:26 /home/node1/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><code>-rw-r--r--</code>：这部分表示文件（或目录）的权限。</p><ul><li>这里<code>-</code>表示这是一个普通文件。接下来的三个字符<code>rw-</code>表示文件所有者（user，这里是root）有读写权限，没有执行权限；</li><li>再接下来的三个字符<code>r--</code>表示所属组（group，这里也是root）有读权限，没有写和执行权限；</li><li>最后的三个字符<code>r--</code>表示其他用户（others）有读权限，没有写和执行权限。</li></ul><p><code>authorized_keys</code>文件可以被所有用户读取，这通常不是推荐的做法。并且<code>authorized_keys</code> 文件目前属于 <code>root</code> 用户，应该改为目前的登录用户（也就是ssh时输入的用户名部分）。</p><p>首先，修改 <code>authorized_keys</code> 文件权限：，将 <code>authorized_keys</code> 文件的权限修改为只有所有者可以读写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>然后修改 <code>authorized_keys</code> 文件所有者为目前登录的用户（将你的用户名替换掉<code>[用户名]</code>这一部分）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> [用户名]:[用户名] ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><blockquote><p><code>chown</code>（change owner）： <code>chown</code> 命令用于改变文件或目录的所有者和/或所属组。</p></blockquote><h3 id="拷贝公钥"><a href="#拷贝公钥" class="headerlink" title="拷贝公钥"></a>拷贝公钥</h3><p>刚才的一系列操作都是为了能将生成的公钥拷贝到<code>~/.ssh.authorized_keys</code>下。然后在客户端（你的Mac）上，使用这个命令进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [用户名]@[主机地址]</span><br></pre></td></tr></table></figure><h3 id="测试SSH免密登录是否成功"><a href="#测试SSH免密登录是否成功" class="headerlink" title="测试SSH免密登录是否成功"></a>测试SSH免密登录是否成功</h3><p>上面的都设置完之后，用<code>exit</code>指令可以退出目前的ssh登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>然后再次使用ssh登录，就不需要密码了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [用户名]@[主机地址]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置C++20环境</title>
      <link href="/post/1240948986.html"/>
      <url>/post/1240948986.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文写于2024.5.19，我的系统为22.04.1-Ubuntu，默认带的是gcc11，它还不支持C++20。为了用上一些C++20的特性，便打算配置一下C++20的环境，期间走了不少弯路，故写一份笔记造福后人。</p><p>这里列出我的一些配置：</p><ul><li>22.04.1-Ubuntu</li><li>CLion 2024.1</li></ul><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="下载clang18"><a href="#下载clang18" class="headerlink" title="下载clang18"></a>下载clang18</h2><p>首先，需要下载支持C++20的编译器。从<a href="https://zh.cppreference.com/w/cpp/compiler_support/20">cppreference</a>上可以找到支持C++20的编译器有哪些。这里选择下载clang18，因为当下的gcc13尚不支持C++20的模块功能。</p><blockquote><p>如果用cmake，cmake需要3.28以上才支持C++20模块功能</p></blockquote><p>参考一篇<a href="https://zhuanlan.zhihu.com/p/670338052">知乎文章</a>，在命令行下输入以下内容安装LLVM18（其带有clang18）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 18</span><br></pre></td></tr></table></figure><p>下载完之后用下面的命令查看一下clang18是否成功安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-18 --v</span><br></pre></td></tr></table></figure><p>输出应该如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu clang version 18.1.6 (++20240517093811+3d0752b9492e-1~exp1~20240517213934.128)</span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: /usr/bin</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/11</span><br><span class="line">Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><h2 id="下载gcc12"><a href="#下载gcc12" class="headerlink" title="下载gcc12"></a>下载gcc12</h2><p>从刚才<code>clang-18 --v</code>可以看到，clang18需要gcc12，如果没有的话，需要安装一下。</p><blockquote><p>具体而言，是需要gcc12带的C++标准库libstdc++。如果没有的话会报错。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/12</span><br></pre></td></tr></table></figure><p>用下面的命令安装gcc12和g++12：</p><blockquote><ul><li><code>gcc</code> 是GCC套件中的C语言编译器，用于编译C语言源代码。</li><li><code>g++</code> 是GCC套件中的C++语言编译器，用于编译C++语言源代码。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-12 g++12</span><br></pre></td></tr></table></figure><h2 id="安装libc"><a href="#安装libc" class="headerlink" title="安装libc++"></a>安装libc++</h2><p>gcc12带的C++标准库libstdc++是不含C++20的库的（gcc13带的C++标准库才含有C++20的库），所以还需要下载llvm带的另一个C++标准库libc++（是的，刚才安装llvm-18的时候并没有安装这个C++标准库）。</p><p>用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libc++-18-dev libc++abi-18-dev</span><br></pre></td></tr></table></figure><h2 id="配置工具链"><a href="#配置工具链" class="headerlink" title="配置工具链"></a>配置工具链</h2><p>打开CLion的设置，打开构建、执行、部署中的工具链一项。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/Ubuntu配置C20环境/image-20240519114554944.png" alt="image-20240519114554944"></p><p>应该可以在/usr/bin中找到clang-18（点C Compiler旁边像文件夹的那个按钮）。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/Ubuntu配置C20环境/image-20240519114703299.png" alt="image-20240519114703299"></p><p>同样，设置C++ compiler为clang++-18，到这里编译器就设置好了。</p><h2 id="更改cmakelist"><a href="#更改cmakelist" class="headerlink" title="更改cmakelist"></a>更改cmakelist</h2><p>现在直接编译还成功不了，因为clang-18会去找gcc12的标准库libstdc++，而其还不支持C++20。所以需要设置标准库为我们安装的libc++-18。在cmakelist.txt中添加如下语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br></pre></td></tr></table></figure><p>在CMake中，<code>CMAKE_CXX_FLAGS</code>是一个变量，它用于存储编译C++源文件时的编译器标志。这行CMake代码是修改这个变量的值的命令，通过将<code>-stdlib=libc++</code>添加到现有的编译器标志中。</p><p>这行代码的作用是告诉C++编译器（比如Clang）使用<code>libc++</code>作为标准的C++库而不是默认的<code>libstdc++</code>。<code>libc++</code>是LLVM项目的一部分，它是C++标准库的一个实现，旨在提供对最新C++标准的良好支持。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>最后用一个小文件测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span> <span class="comment">//format是C++20引入的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;std::format(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cmakelist.txt如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span></span><br><span class="line">        main.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果成功输出了<code>hello world!</code>，那么就配置成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 学海泛舟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础 - Python</title>
      <link href="/post/2575511367.html"/>
      <url>/post/2575511367.html</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://blog.algorithmpark.xyz/2023/07/23/language/python/index/">算法乐园的Python笔记</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>最简单的用法就是直接打印一个字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这将在控制台上输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印多个值"><a href="#打印多个值" class="headerlink" title="打印多个值"></a>打印多个值</h3><p>你也可以在一次<code>print</code>调用中打印多个值，只需用逗号隔开它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello,&quot;</span>, <span class="string">&quot;World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h3><p>当然，<code>print</code>函数也可以用于打印变量的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;, y =&quot;</span>, y)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span> , y = <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="换行与分隔符"><a href="#换行与分隔符" class="headerlink" title="换行与分隔符"></a>换行与分隔符</h3><p>默认情况下，<code>print</code>函数会在每个值之间添加一个空格，并在最后添加一个换行符。你可以通过<code>sep</code>和<code>end</code>参数来自定义这些行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, sep=<span class="string">&quot;-&quot;</span>, end=<span class="string">&quot;!!!\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello-World!!!</span><br></pre></td></tr></table></figure><h3 id="格式化字符串的语法"><a href="#格式化字符串的语法" class="headerlink" title="格式化字符串的语法"></a>格式化字符串的语法</h3><p>格式化字符串使用<code>f</code>或<code>F</code>前缀来标识，后面跟着一个字符串字面量，其中可以包含花括号<code>&#123;&#125;</code>内的表达式。这些花括号内的表达式将在运行时被计算，并用其结果替换花括号。</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span>  </span><br><span class="line">age = <span class="number">30</span>  </span><br><span class="line">greeting = <span class="string">f&quot;Hello, my name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(greeting)  <span class="comment"># 输出: Hello, my name is Alice and I am 30 years old.</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，变量<code>name</code>和<code>age</code>被插入到了字符串中的相应位置。</p><h2 id="input语句"><a href="#input语句" class="headerlink" title="input语句"></a>input语句</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>input()</code>函数的基本用法非常简单。当调用它时，程序会暂停并等待用户输入。用户可以在命令行或交互式环境中输入文本，然后按Enter键提交输入。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入一些文本：&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你输入的是：&quot;</span>, user_input)</span><br></pre></td></tr></table></figure><p>在这个例子中，程序首先打印出提示信息”请输入一些文本：”，然后等待用户输入。用户输入的内容将被赋值给变量<code>user_input</code>，然后程序打印出”你输入的是：”后面跟着用户输入的内容。</p><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>需要注意的是，<code>input()</code>函数返回的总是一个字符串类型。即使你输入的是一个数字，它也会被当作字符串处理。如果你需要将输入转换为其他类型（如整数或浮点数），你需要使用相应的类型转换函数。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>Python 中的单行注释以 <code>#</code> 开头。<code>#</code> 符号后面的所有内容都会被视为注释，直到该行的结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释  </span></span><br><span class="line">x = <span class="number">5</span>  <span class="comment"># 可以在代码行的末尾添加注释</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>Python 本身并没有直接支持多行注释的语法，但我们可以使用三重引号（<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>）来实现类似的效果。三重引号通常用于多行字符串，但如果没有将它们赋值给变量或用作其他目的，它们也可以用作多行注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">这是一个多行注释的  </span></span><br><span class="line"><span class="string">示例。你可以在这里写下  </span></span><br><span class="line"><span class="string">多行文字来描述你的代码。  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 或者使用三个单引号  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">这也是一个多行注释的示例，  </span></span><br><span class="line"><span class="string">和上面的三重双引号具有相同的效果。  </span></span><br><span class="line"><span class="string">选择哪种风格通常取决于个人或团队的偏好。  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Python 中一般以新行作为语句的结束标识，可以使用 \ 将一行语句分为多行显示。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">128</span></span><br><span class="line">b = <span class="number">1024</span></span><br><span class="line">c = <span class="number">512</span></span><br><span class="line">d = a + \</span><br><span class="line">    b - \</span><br><span class="line">    c</span><br></pre></td></tr></table></figure><p>如果包含在 []、{}、() 括号中，则不需要使用 \。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python变量及基本数据"><a href="#Python变量及基本数据" class="headerlink" title="Python变量及基本数据"></a>Python变量及基本数据</h1><h2 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h2><p>在Python编程语言中，数据类型是一个重要的概念，它决定了变量可以保存何种类型的数据以及可以对这些变量执行哪些操作。Python有几种基本（或内置）的数据类型，包括整数（int）、浮点数（float）、字符串（str）等，但请注意字符（char）这一概念在Python中并不作为一个独立的基本数据类型存在，字符通常被视为长度为1的字符串。</p><h3 id="1-整数（Integers）"><a href="#1-整数（Integers）" class="headerlink" title="1. 整数（Integers）"></a>1. 整数（Integers）</h3><p>整数是没有小数部分的数字，可以是正数或负数。在Python中，整数的大小只受限于可用内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>   <span class="comment"># 定义一个整数</span></span><br><span class="line">y = -<span class="number">20</span>  <span class="comment"># 定义一个负整数</span></span><br></pre></td></tr></table></figure><p>Python 3中的整数是动态大小的，意味着Python整数可以处理任意大小的整数，只要内存允许。</p><h3 id="2-浮点数（Floating-Point-Numbers）"><a href="#2-浮点数（Floating-Point-Numbers）" class="headerlink" title="2. 浮点数（Floating Point Numbers）"></a>2. 浮点数（Floating Point Numbers）</h3><p>浮点数是有小数点的数字，它们用于表示实数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1.23</span>   <span class="comment"># 定义一个浮点数</span></span><br><span class="line">y = -<span class="number">4.56</span>  <span class="comment"># 定义一个负的浮点数</span></span><br></pre></td></tr></table></figure><p>浮点数在计算机中的表示是近似的，因此在进行浮点数运算时要特别注意精度问题。</p><h3 id="3-字符串（Strings）"><a href="#3-字符串（Strings）" class="headerlink" title="3. 字符串（Strings）"></a>3. 字符串（Strings）</h3><p>字符串是由零个或多个字符组成的有序字符序列。在Python中，字符串是不可变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># 定义一个字符串</span></span><br><span class="line">s2 = <span class="string">&#x27;World&#x27;</span>  <span class="comment"># 字符串也可以用单引号定义</span></span><br></pre></td></tr></table></figure><p>字符串可以通过连接（concatenation）形成新的字符串，也可以用切片（slicing）来访问子字符串。</p><h3 id="4-字符（Characters）"><a href="#4-字符（Characters）" class="headerlink" title="4. 字符（Characters）"></a>4. 字符（Characters）</h3><p>在Python中，并没有专门的“字符”数据类型。相反，字符被视为长度为1的字符串。你可以通过索引字符串来获取单个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">char = s[<span class="number">0</span>]  <span class="comment"># 获取字符串中的第一个字符，结果为 &#x27;H&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>char</code> 实际上是一个长度为1的字符串，它包含了字符 ‘H’。在Python中处理单个字符时，你通常会使用长度为1的字符串。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量money，并赋值为10</span></span><br><span class="line">money = <span class="number">10</span></span><br><span class="line"><span class="comment"># 对money变量进行减法操作，减去5</span></span><br><span class="line">money = money - <span class="number">5</span></span><br><span class="line"><span class="comment"># 打印money变量的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;余额为&quot;</span>, money, <span class="string">&quot;元&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h2><p>可以使用<code>type()</code>函数来查看一个变量的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义几个变量，并分别赋予不同的数据类型</span></span><br><span class="line">string_type = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">int_type = <span class="number">666</span></span><br><span class="line">float_type = <span class="number">114.514</span></span><br><span class="line"><span class="comment"># 使用type()函数查看变量的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(string_type), <span class="built_in">type</span>(int_type), <span class="built_in">type</span>(float_type))</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到输出<code>&lt;class &#39;str&#39;&gt; &lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt;</code>，说明这三个变量的数据类型分别是字符串、整数和浮点数。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Python中，你可以使用内置的函数来进行数据类型之间的转换。常见的转换函数有<code>int()</code>、<code>float()</code>和<code>str()</code>。</p><ul><li><code>int(x)</code>：将x转换为一个整数。如果x是一个浮点数，会舍去小数部分。如果x是一个字符串，且字符串内容可以转换为整数，则会转换为相应的整数；<strong>否则会报错</strong>。</li><li><code>float(x)</code>：将x转换为一个浮点数。如果x是一个整数，会在其后面添加<code>.0</code>。如果x是一个字符串，且字符串内容可以转换为浮点数，则会转换为相应的浮点数；<strong>否则会报错</strong>。</li><li><code>str(x)</code>：将x转换为一个字符串。无论x是什么数据类型，都会转换为其对应的字符串形式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将浮点数转换为字符串</span></span><br><span class="line">float_str = <span class="built_in">str</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(float_str), float_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为整数</span></span><br><span class="line">num = <span class="built_in">int</span>(<span class="string">&quot;11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num), num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为浮点数</span></span><br><span class="line">num2 = <span class="built_in">float</span>(<span class="string">&quot;1919.810&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num2), num2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整数转换为浮点数</span></span><br><span class="line">fnum = <span class="built_in">float</span>(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fnum), fnum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将浮点数转换为整数，注意这里不会四舍五入，而是直接舍去小数部分</span></span><br><span class="line">inum = <span class="built_in">int</span>(<span class="number">114.514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(inum), inum)</span><br></pre></td></tr></table></figure><p>运行这段代码，你会得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt; 114.514</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 11</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 1919.81</span><br><span class="line">&lt;class &#x27;float&#x27;&gt; 11.0</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; 114</span><br></pre></td></tr></table></figure><p>注意在进行数据类型转换时，要确保转换是合法的，否则程序会报错。例如，尝试将一个包含非数字字符的字符串转换为整数或浮点数会导致<code>ValueError</code>。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符命名只允许出现:（和C++一样）</p><ul><li>英文字母</li><li>中文(不推荐)</li><li>数字(<strong>不可以开头</strong>)</li><li>下划线_</li></ul><h1 id="处理数据类型"><a href="#处理数据类型" class="headerlink" title="处理数据类型"></a>处理数据类型</h1><h2 id="Python的运算符介绍"><a href="#Python的运算符介绍" class="headerlink" title="Python的运算符介绍"></a>Python的运算符介绍</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>算术运算符用于执行基本的数学运算。</p><ul><li><code>+</code>：加法运算符，用于计算两个数的和。</li><li><code>-</code>：减法运算符，用于计算两个数的差。</li><li><code>*</code>：乘法运算符，用于计算两个数的积。</li><li><code>/</code>：除法运算符，用于计算两个数的商。<strong>(python两个整数相除会得到浮点数)</strong></li><li><code>//</code>：整除运算符，用于计算两个数整除后的结果（只保留整数部分）。整除取整方向默认为$−∞$。</li><li><code>%</code>：取模运算符，用于计算两个数相除后的余数。</li><li><code>**</code>：幂运算符，用于计算一个数的幂。</li></ul><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><p>比较运算符用于比较两个值的大小关系，返回一个布尔值（True或False）。</p><ul><li><code>==</code>：等于运算符，用于判断两个值是否相等。</li><li><code>!=</code>：不等于运算符，用于判断两个值是否不相等。</li><li><code>&gt;</code>：大于运算符，用于判断左侧的值是否大于右侧的值。</li><li><code>&lt;</code>：小于运算符，用于判断左侧的值是否小于右侧的值。</li><li><code>&gt;=</code>：大于等于运算符，用于判断左侧的值是否大于或等于右侧的值。</li><li><code>&lt;=</code>：小于等于运算符，用于判断左侧的值是否小于或等于右侧的值。</li></ul><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>逻辑运算符用于组合多个条件表达式，返回一个布尔值。</p><ul><li><p><code>and</code>：逻辑与运算符，当所有条件都为True时，返回True。</p></li><li><p><code>or</code>：逻辑或运算符，当至少有一个条件为True时，返回True。</p></li><li><p><code>not</code>：逻辑非运算符，用于取反一个布尔值。</p><blockquote><h4 id="Python中的逻辑判断：与、或、非"><a href="#Python中的逻辑判断：与、或、非" class="headerlink" title="Python中的逻辑判断：与、或、非"></a><strong>Python中的逻辑判断：与、或、非</strong></h4><p>在Python中，逻辑运算符用于连接布尔表达式，并根据这些表达式的真假值返回结果。与Java等其他语言相比，Python的逻辑运算符有一些独特之处，特别是在处理非布尔类型的值时。</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>Python中的逻辑运算符包括：</p><ul><li><code>and</code>：逻辑与</li><li><code>or</code>：逻辑或</li><li><code>not</code>：逻辑非</li></ul><h6 id="逻辑运算符的行为"><a href="#逻辑运算符的行为" class="headerlink" title="逻辑运算符的行为"></a>逻辑运算符的行为</h6><h5 id="逻辑与-and"><a href="#逻辑与-and" class="headerlink" title="逻辑与 (and)"></a>逻辑与 (<code>and</code>)</h5><p>当使用<code>and</code>运算符时：</p><ul><li>如果所有表达式的值都为真（非零、非空等），则返回最后一个表达式的值。</li><li>如果有一个或多个表达式的值为假（零、空等），则返回第一个假值。</li></ul><h6 id="逻辑或-or"><a href="#逻辑或-or" class="headerlink" title="逻辑或 (or)"></a>逻辑或 (<code>or</code>)</h6><p>当使用<code>or</code>运算符时：</p><ul><li>如果有一个或多个表达式的值为真，则返回第一个真值。</li><li>如果所有表达式的值都为假，则返回最后一个假值。</li></ul><h5 id="逻辑非-not"><a href="#逻辑非-not" class="headerlink" title="逻辑非 (not)"></a>逻辑非 (<code>not</code>)</h5><p><code>not</code>运算符返回表达式的布尔否定值。如果表达式为真，则返回<code>False</code>；如果表达式为假，则返回<code>True</code>。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>下面是一些Python逻辑运算符的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑与 (and)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">1</span>)  <span class="comment"># True，因为两个条件都为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span>)          <span class="comment"># 2，因为3为真，返回第二个值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="literal">None</span>)       <span class="comment"># 0，因为0为假，返回第一个假值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑或 (or)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> &gt; <span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">1</span>)   <span class="comment"># True，因为至少有一个条件为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">2</span>)       <span class="comment"># 2，因为2为真，返回第一个真值2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">None</span>)        <span class="comment"># None，因为两者都为假，返回最后一个假值None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑非 (not)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">3</span>)            <span class="comment"># False，因为3为真值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span>)            <span class="comment"># True，因为0为假值</span></span><br></pre></td></tr></table></figure><h4 id="为假的值"><a href="#为假的值" class="headerlink" title="为假的值"></a>为假的值</h4><p>在Python中，以下值在布尔上下文中被视为<code>False</code>：</p><ul><li>数值类型中的<code>0</code>和<code>0.0</code></li><li>空序列类型，如空字符串<code>&#39;&#39;</code>、空列表<code>[]</code>、空元组<code>()</code>、空字典<code>&#123;&#125;</code></li><li><code>None</code>对象</li><li>布尔类型本身的<code>False</code>值</li></ul><p>需要注意的是，当这些“假值”作为逻辑表达式的一部分时，它们本身会被返回作为结果，而不是布尔值<code>False</code>。这是Python逻辑运算符与其他语言（如Java）的一个主要区别。在Java中，逻辑运算符只能用于布尔表达式，并且结果总是布尔值。而在Python中，逻辑运算符可以更加灵活地用于不同类型的值，并返回这些值本身作为结果。这种特性使得Python代码在某些情况下可以更加简洁和高效。但同时也需要注意逻辑运算符的这种行为可能会带来的潜在混淆和错误。因此在使用时需要特别小心并确保理解其行为规则。</p></blockquote></li></ul><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>位运算符用于对二进制位进行操作。</p><ul><li><code>&amp;</code>：按位与运算符，对两个数的二进制位进行与操作。</li><li><code>|</code>：按位或运算符，对两个数的二进制位进行或操作。</li><li><code>^</code>：按位异或运算符，对两个数的二进制位进行异或操作。</li><li><code>~</code>：按位取反运算符，对一个数的二进制位进行取反操作。</li><li><code>&lt;&lt;</code>：左移运算符，将一个数的二进制位向左移动指定的位数。</li><li><code>&gt;&gt;</code>：右移运算符，将一个数的二进制位向右移动指定的位数。</li></ul><h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. 赋值运算符</h3><p>赋值运算符用于将表达式的值赋给变量。</p><ul><li><code>=</code>：赋值运算符，将右侧表达式的值赋给左侧的变量。</li><li><code>+=</code>：加法赋值运算符，将右侧的值加到左侧的变量上，并将结果赋给左侧的变量。</li><li><code>-=</code>：减法赋值运算符，将右侧的值从左侧的变量中减去，并将结果赋给左侧的变量。</li><li><code>*=</code>：乘法赋值运算符，将右侧的值与左侧的变量相乘，并将结果赋给左侧的变量。</li><li><code>/=</code>：除法赋值运算符，将左侧的变量除以右侧的值，并将结果赋给左侧的变量。</li><li><code>%=</code>：取模赋值运算符，将左侧变量与右侧值进行取模运算，并将结果赋给左侧的变量。</li><li><code>**=</code>：幂赋值运算符，将左侧变量进行幂运算后的结果赋给左侧的变量。</li><li><code>//=</code>：整除赋值运算符，将左侧变量与右侧值进行整除运算后的结果赋给左侧的变量。</li></ul><h3 id="6-身份运算符"><a href="#6-身份运算符" class="headerlink" title="6. 身份运算符"></a>6. 身份运算符</h3><p>身份运算符用于比较两个对象的身份是否相同。</p><ul><li><code>is</code>：判断两个标识符是否引用同一个对象。</li><li><code>is not</code>：判断两个标识符是否引用不同的对象。</li></ul><h3 id="7-成员运算符"><a href="#7-成员运算符" class="headerlink" title="7. 成员运算符"></a>7. 成员运算符</h3><p>成员运算符用于判断一个值是否存在于序列中（如列表、元组、字符串等）。</p><ul><li><code>in</code>：如果指定的值在序列中找到，则返回True，否则返回False。</li><li><code>not in</code>：如果指定的值没有在序列中找到，则返回True，否则返回False。</li></ul><p>这些运算符在Python编程中非常常用，掌握它们对于编写高效的Python代码至关重要。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在Python中，你可以使用加号（<code>+</code>）操作符来拼接（连接）两个或多个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;defg&quot;</span></span><br><span class="line">s3 = s1 + s2</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出：abcddefg</span></span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python 提供了多种方式来格式化字符串，其中 <code>%</code> 操作符是一种较旧的方法，但在某些情况下仍然很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用%s作为字符串占位符，%d作为整数占位符，%f作为浮点数占位符</span></span><br><span class="line">num = <span class="number">114514</span></span><br><span class="line">s = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">message1 = <span class="string">&quot;%s你好世界&quot;</span> % s</span><br><span class="line"><span class="built_in">print</span>(message1)  <span class="comment"># 输出：abcde你好世界</span></span><br><span class="line"></span><br><span class="line">message2 = <span class="string">&quot;%s你好世界%d&quot;</span> % (s, num)</span><br><span class="line"><span class="built_in">print</span>(message2)  <span class="comment"># 输出：abcde你好世界114514</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子，包含浮点数</span></span><br><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">&quot;%s高达%.1f,老铁%d&quot;</span> % (s, gpa, num)</span><br><span class="line"><span class="built_in">print</span>(message)  <span class="comment"># 输出：绩点高达0.1,老铁666</span></span><br></pre></td></tr></table></figure><p>注意：<code>%.1f</code> 表示浮点数将被格式化为小数点后保留一位。</p><h4 id="字符串格式化的一种快速写法"><a href="#字符串格式化的一种快速写法" class="headerlink" title="字符串格式化的一种快速写法"></a>字符串格式化的一种快速写法</h4><p>格式:<code>f”内容&#123;变量&#125;”</code>(不关心精度控制)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;绩点&quot;</span></span><br><span class="line">gpa = <span class="number">0.1</span></span><br><span class="line">num = <span class="number">666</span></span><br><span class="line">message = <span class="string">f&quot;<span class="subst">&#123;s&#125;</span>高达<span class="subst">&#123;gpa&#125;</span>,大佬<span class="subst">&#123;num&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h3 id="字符转ASCII和ASCII转字符串"><a href="#字符转ASCII和ASCII转字符串" class="headerlink" title="字符转ASCII和ASCII转字符串"></a>字符转ASCII和ASCII转字符串</h3><p>在Python中，你可以使用 <code>ord()</code> 函数将一个字符转换成其对应的ASCII数值，使用 <code>chr()</code> 函数将一个ASCII数值转换成对应的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))  <span class="comment"># 输出：97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))   <span class="comment"># 输出：a</span></span><br></pre></td></tr></table></figure><h3 id="字符串的大小写转化"><a href="#字符串的大小写转化" class="headerlink" title="字符串的大小写转化"></a>字符串的大小写转化</h3><p>Python 提供了几种方法来改变字符串的大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 title() 方法将字符串中每个单词的首字母变成大写，其余小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;wHat a beaUTIFul GIrl!!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.title())  <span class="comment"># 输出：What A Beautiful Girl!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 upper() 方法将字符串中所有字母变成大写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Cpp Is The Best Programing Language&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.upper())  <span class="comment"># 输出：CPP IS THE BEST PROGRAMING LANGUAGE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lower() 方法将字符串中所有字母变成小写</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;I HATE PYTHOn&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.lower())  <span class="comment"># 输出：i hate python</span></span><br></pre></td></tr></table></figure><p>注意：这些方法都不会改变原始字符串，而是返回一个新的字符串。因为Python中的字符串是不可变的。</p><h3 id="浮点数精度控制"><a href="#浮点数精度控制" class="headerlink" title="浮点数精度控制"></a>浮点数精度控制</h3><h4 id="使用-格式化浮点数"><a href="#使用-格式化浮点数" class="headerlink" title="使用%格式化浮点数"></a>使用%格式化浮点数</h4><p>下面是一些使用<code>%</code>运算符和<code>.yf</code>格式来格式化浮点数的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个浮点数  </span></span><br><span class="line">number = <span class="number">3.141592653589793</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用%格式化方法，保留两位小数  </span></span><br><span class="line">formatted_number = <span class="string">&quot;%.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number)  <span class="comment"># 输出: 3.14  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果需要指定总宽度（包括小数点和小数），则使用x.yf格式  </span></span><br><span class="line"><span class="comment"># 但这里的总宽度仅包括小数点前的数字、小数点和小数点后的数字，不包括可能的负号或指数部分  </span></span><br><span class="line">formatted_number_with_width = <span class="string">&quot;%8.2f&quot;</span> % number  </span><br><span class="line"><span class="built_in">print</span>(formatted_number_with_width)  <span class="comment"># 输出: &quot;    3.14&quot;（前面有空格填充以达到总宽度8）  </span></span><br></pre></td></tr></table></figure><h1 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h1><h2 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h2><h3 id="1-1-布尔类型"><a href="#1-1-布尔类型" class="headerlink" title="1.1 布尔类型"></a>1.1 布尔类型</h3><p>布尔类型（bool）用于表示逻辑值，其中 <code>True</code> 表示真（逻辑上的1），<code>False</code> 表示假（逻辑上的0）。</p><h3 id="1-2-条件表达式"><a href="#1-2-条件表达式" class="headerlink" title="1.2 条件表达式"></a>1.2 条件表达式</h3><p>条件表达式的结果是布尔类型。例如，比较运算符（如 <code>&gt;</code>、<code>&lt;</code>、<code>==</code> 等）的结果就是布尔类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">11</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;11 &gt; 20 的结果是 <span class="subst">&#123;<span class="number">11</span> &gt; <span class="number">20</span>&#125;</span>, 类型为 <span class="subst">&#123;<span class="built_in">type</span>(<span class="number">11</span> &gt; <span class="number">20</span>)&#125;</span>&quot;</span>)  <span class="comment"># 输出 False 和 &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-if-elif-else-语句"><a href="#1-3-if-elif-else-语句" class="headerlink" title="1.3 if-elif-else 语句"></a>1.3 if-elif-else 语句</h3><p><code>if-elif-else</code> 语句用于根据条件执行不同的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt; 10&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> &lt;= 100&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>在这个例子中，根据输入的数字大小，程序会输出不同的结果。<strong>注意要写$:$</strong></p><h3 id="1-4-pass-语句"><a href="#1-4-pass-语句" class="headerlink" title="1.4 pass 语句"></a>1.4 pass 语句</h3><p><code>pass</code> 是一个空语句，它不做任何事情。它通常用作占位符，以保持程序结构的完整性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 这里什么也不做</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)  <span class="comment"># 只有当 num &gt; 100 时才会执行这条语句</span></span><br></pre></td></tr></table></figure><h2 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h2><h3 id="2-1-while-循环"><a href="#2-1-while-循环" class="headerlink" title="2.1 while 循环"></a>2.1 while 循环</h3><p><code>while</code> 循环会重复执行一段代码，直到条件不再满足为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">add = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">100</span>:</span><br><span class="line">    add += x  <span class="comment"># 累加 x 的值到 add 变量中</span></span><br><span class="line">    x += <span class="number">1</span>    <span class="comment"># x 自增 1</span></span><br><span class="line"><span class="built_in">print</span>(add)  <span class="comment"># 输出累加结果，从 1 加到 100 的和为 5050</span></span><br></pre></td></tr></table></figure><h3 id="2-2-for-循环"><a href="#2-2-for-循环" class="headerlink" title="2.2 for 循环"></a>2.2 for 循环</h3><p><code>for</code> 循环用于遍历序列类型（如字符串、列表、元组等）中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> s:  <span class="comment"># 遍历字符串 s 中的每个字符</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过当前循环的剩余部分，进入下一次循环</span></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="string">&quot;e&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 跳出整个循环</span></span><br><span class="line">    <span class="built_in">print</span>(ch)  <span class="comment"># 输出字符，但不会输出 &quot;a&quot; 和 &quot;e&quot; 之后的字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-range-函数"><a href="#2-3-range-函数" class="headerlink" title="2.3 range() 函数"></a>2.3 range() 函数</h3><p><code>range()</code> 函数用于生成一个数字序列。它有三种用法：</p><ul><li><code>range(num)</code>：生成从 0 开始到 num-1 的数字序列。</li><li><code>range(num1, num2)</code>：生成从 num1 开始到 num2-1 的数字序列。</li><li><code>range(num1, num2, step)</code>：生成从 num1 开始到 num2-1 的数字序列，步长为 step。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 range() 函数的例子</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>, <span class="number">11</span>, <span class="number">2</span>):  <span class="comment"># 生成 [5, 7, 9] 这样的序列并遍历它</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 5 7 9</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 输出一个换行符以美观结束输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个例子：倒序输出 10 到 1 的数字序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 生成 [10, 9, 8, ..., 1] 这样的序列并遍历它（注意不包含0）</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出每个数字并用空格分隔它们，结果是 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="built_in">print</span>()  <span class="comment"># 同样输出一个换行符以结束输出</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><p>在Python中，函数是通过<code>def</code>关键字定义的，后面跟函数名和括号内的参数列表。函数体由一系列语句组成，并且使用缩进来表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Docstring: 函数说明文档&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 函数体：由语句组成，执行特定的任务</span></span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment"># 可选：返回函数执行的结果</span></span><br></pre></td></tr></table></figure><p>调用函数时，需要在函数名后加上括号和必要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = function_name(arguments)  <span class="comment"># 调用函数，并将返回值存储在变量中（如果有返回值的话）</span></span><br></pre></td></tr></table></figure><blockquote><p> 注：Python不支持函数重载</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>如果函数中有<code>return</code>语句，那么函数会返回<code>return</code>后面的值。如果函数中没有<code>return</code>语句或者<code>return</code>语句后面没有跟任何值，那么函数会默认返回<code>None</code>。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>在Python中，函数不仅可以返回单个值，还可以返回多个值。</p><h4 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h4><p>当函数需要返回多个值时，可以将这些值<strong>以逗号分隔</strong>放在<code>return</code>语句后。这些值会被打包成一个元组返回。调用函数时，可以使用多个变量来接收这些返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test01</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span></span><br><span class="line"></span><br><span class="line">x, y = test01()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=22</span></span><br></pre></td></tr></table></figure><p>函数也可以返回不同类型的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test02</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">4.5</span>, <span class="string">&quot;14&quot;</span></span><br><span class="line"></span><br><span class="line">x, y, z = test02()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x=<span class="subst">&#123;x&#125;</span>, y=<span class="subst">&#123;y&#125;</span>, z=<span class="subst">&#123;z&#125;</span>&quot;</span>)  <span class="comment"># 输出：x=11, y=4.5, z=14</span></span><br></pre></td></tr></table></figure><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>位置参数是按照函数声明中参数的顺序来传递的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test03</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test03(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是通过参数名来指定要传递的参数值。关键字参数可以不按照函数声明中的顺序来传递，但是要注意在函数调用时关键字参数的名称必须与函数声明中的参数名一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test04</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test04(name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><p>关键字参数和位置参数可以混用，但位置参数必须放在关键字参数前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test05</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test05(<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">10</span>, gender=<span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>缺省参数是指在函数声明时为参数指定一个默认值。如果在函数调用时没有为该参数传递值，则使用默认值。<strong>缺省参数必须放在函数声明的最后</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test06</span>(<span class="params">name, age, gender=<span class="string">&quot;Male&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, gender)</span><br><span class="line"></span><br><span class="line">test06(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：Tom 10 Male</span></span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>不定长参数是指函数可以接受任意数量的参数。在函数声明中，使用<code>*args</code>来表示接受任意数量的位置参数，使用<code>**kwargs</code>来表示接受任意数量的关键字参数。这些参数在函数内部被收集为一个元组或一个字典。</p><h4 id="位置传递（-args）"><a href="#位置传递（-args）" class="headerlink" title="位置传递（*args）"></a>位置传递（*args）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test07</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">test07(<span class="string">&#x27;Jerry&#x27;</span>)  <span class="comment"># 输出：(&#x27;Jerry&#x27;,)</span></span><br><span class="line">test07(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出：(&#x27;Tom&#x27;, 10)</span></span><br><span class="line">test07(<span class="string">&#x27;Trump&#x27;</span>, <span class="number">77</span>, <span class="string">&#x27;Male&#x27;</span>)  <span class="comment"># 输出：(&#x27;Trump&#x27;, 77, &#x27;Male&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="关键字传递（-kwargs）"><a href="#关键字传递（-kwargs）" class="headerlink" title="关键字传递（**kwargs）"></a>关键字传递（**kwargs）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test08</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">test08(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure><h2 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h2><p>在函数内部定义的变量是局部变量，只能在该函数内部访问。在函数外部定义的变量是全局变量，可以在任何地方访问，包括函数内部（除非被局部变量覆盖）。</p><p>如果需要在函数内部修改全局变量，需要使用<code>global</code>关键字声明。</p><h2 id="函数说明文档（Docstring）"><a href="#函数说明文档（Docstring）" class="headerlink" title="函数说明文档（Docstring）"></a>函数说明文档（Docstring）</h2><p>函数说明文档是一种特殊的注释，用于解释函数的作用、参数和返回值。它位于函数定义的开始，由三个双引号（可以是三个单引号）包围。</p><p>Docstring可以通过<code>help()</code>函数或者函数的<code>__doc__</code>属性查看。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个包含函数定义、调用、局部变量、全局变量和Docstring的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strlen</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算字符串的长度</span></span><br><span class="line"><span class="string">    :param s: 输入的字符串</span></span><br><span class="line"><span class="string">    :return: 字符串的长度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_global</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示全局变量的访问和修改</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 声明是全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num before modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">    num = <span class="number">500</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Global num after modification: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_local</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    演示局部变量的作用范围</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    local_num = <span class="number">100</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Local num: <span class="subst">&#123;local_num&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数并打印结果</span></span><br><span class="line">s1 = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Length of &#x27;<span class="subst">&#123;s1&#125;</span>&#x27;: <span class="subst">&#123;strlen(s1)&#125;</span>&quot;</span>)  <span class="comment"># 调用strlen函数计算字符串长度并打印结果</span></span><br><span class="line">test_global()  <span class="comment"># 调用test_global函数修改全局变量并打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Global num after test_global function: <span class="subst">&#123;num&#125;</span>&quot;</span>)  <span class="comment"># 打印修改后的全局变量值以确认修改生效</span></span><br><span class="line">test_local()  <span class="comment"># 调用test_local函数演示局部变量的作用范围（不会修改全局变量）</span></span><br></pre></td></tr></table></figure><h1 id="Python中的数据结构"><a href="#Python中的数据结构" class="headerlink" title="Python中的数据结构"></a>Python中的数据结构</h1><h2 id="List——列表"><a href="#List——列表" class="headerlink" title="List——列表"></a>List——列表</h2><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>在Python中，列表（List）是一种可变的数据容器，可以包含任意类型的对象：数字、字符串、其他列表等。列表中的元素通过逗号分隔，并包含在方括号 <code>[]</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串列表</span></span><br><span class="line">name_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表可以存储多种不同类型的元素</span></span><br><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="number">666</span>, <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, 666, True]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表支持嵌套</span></span><br><span class="line">two_dimension = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(two_dimension)  <span class="comment"># 输出: [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(two_dimension))  <span class="comment"># 输出: &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h3><p>列表中的元素可以通过下标索引来访问。在Python中，下标从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出: abc</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">2</span>])  <span class="comment"># 输出: ghi</span></span><br></pre></td></tr></table></figure><p>尝试访问超出范围的索引会导致<code>IndexError</code>。</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>在Python中，你可以使用<code>list.index()</code>函数来查找列表中某个元素的索引。这个函数会返回元素在列表中首次出现的索引，如果元素不在列表中，则会抛出一个<code>ValueError</code>异常。</p><p>下面是一个基本的使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个列表  </span></span><br><span class="line">my_list = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查找&#x27;banana&#x27;的索引  </span></span><br><span class="line">index = my_list.index(<span class="string">&#x27;banana&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出索引  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;The index of &#x27;banana&#x27; is <span class="subst">&#123;index&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这段代码会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码</span><br><span class="line">The index of <span class="string">&#x27;banana&#x27;</span> is 1</span><br></pre></td></tr></table></figure><p>因为在这个列表中，’banana’的索引是1（索引是从0开始的）。</p><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>列表中的元素可以通过下标索引来修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list[<span class="number">1</span>] = <span class="string">&quot;bcd&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;bcd&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="insert-方法"><a href="#insert-方法" class="headerlink" title=".insert()方法"></a>.insert()方法</h4><p>使用<code>.insert()</code>方法可以在列表的指定位置插入一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.insert(<span class="number">1</span>, <span class="string">&quot;666&quot;</span>)  <span class="comment"># 在下标1处插入&quot;666&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;666&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="append-方法"><a href="#append-方法" class="headerlink" title=".append()方法"></a>.append()方法</h4><p>使用<code>.append()</code>方法可以在列表的末尾追加一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.append(<span class="string">&quot;jkl&quot;</span>)  <span class="comment"># 在末尾追加&quot;jkl&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="extend-方法"><a href="#extend-方法" class="headerlink" title=".extend()方法"></a>.extend()方法</h4><p>使用<code>.extend()</code>方法可以在列表的末尾追加另一个容器（例如列表）的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]</span><br><span class="line">my_list.extend([<span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqr&quot;</span>])  <span class="comment"># 追加另一个列表的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;, &#x27;mno&#x27;, &#x27;pqr&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h4><p>使用<code>del</code>语句可以删除列表中指定位置的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]  <span class="comment"># 删除下标为1的元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="pop-方法"><a href="#pop-方法" class="headerlink" title=".pop()方法"></a>.pop()方法</h4><p>使用<code>.pop()</code>方法可以删除并返回列表中指定位置的元素。如果不提供索引，则默认删除并返回最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">element = my_list.pop(<span class="number">1</span>)  <span class="comment"># 删除下标为1的元素，并将其值赋给element</span></span><br><span class="line"><span class="built_in">print</span>(element)  <span class="comment"># 输出: def</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title=".remove()方法"></a>.remove()方法</h4><p>使用<code>.remove()</code>方法可以删除列表中第一个出现的指定元素。如果元素不存在于列表中，则会导致<code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.remove(<span class="string">&quot;def&quot;</span>)  <span class="comment"># 删除第一个出现的&quot;def&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [&#x27;abc&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="清空列表"><a href="#清空列表" class="headerlink" title="清空列表"></a>清空列表</h3><p>使用<code>.clear()</code>方法可以清空列表中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>]</span><br><span class="line">my_list.clear()  <span class="comment"># 清空列表</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: []</span></span><br></pre></td></tr></table></figure><h3 id="统计元素数量"><a href="#统计元素数量" class="headerlink" title="统计元素数量"></a>统计元素数量</h3><p>使用<code>.count()</code>方法可以统计列表中某个元素出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="number">1</span>))  <span class="comment"># 输出: 2，因为1在列表中出现了2次</span></span><br></pre></td></tr></table></figure><h3 id="列表长度"><a href="#列表长度" class="headerlink" title="列表长度"></a>列表长度</h3><p>使用内置函数<code>len()</code>可以获取列表的长度（即元素的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))  <span class="comment"># 输出: 5，因为列表中有5个元素</span></span><br></pre></td></tr></table></figure><h3 id="遍历容器"><a href="#遍历容器" class="headerlink" title="遍历容器"></a>遍历容器</h3><p>可以使用<code>for</code>循环来遍历列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p>如果需要在遍历过程中同时获取元素的下标和值，可以使用<code>enumerate()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list, start=<span class="number">1</span>):  <span class="comment"># 设置下标从1开始</span></span><br><span class="line">    <span class="built_in">print</span>(index, item)  <span class="comment"># 输出元素的下标和值</span></span><br></pre></td></tr></table></figure><p>这将输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 apple</span><br><span class="line">2 banana</span><br><span class="line">3 cherry</span><br></pre></td></tr></table></figure><blockquote><p>如果start=0，将输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;0 apple</span><br><span class="line">1 banana</span><br><span class="line">2 cherry</span><br></pre></td></tr></table></figure></blockquote><h3 id="Python中列表的拷贝方法"><a href="#Python中列表的拷贝方法" class="headerlink" title="Python中列表的拷贝方法"></a>Python中列表的拷贝方法</h3><p>在Python中，拷贝一个列表可以有多种方法，但每种方法都有其特定的用途和后果。本笔记将详细介绍使用赋值运算符（<code>=</code>）、<code>.copy()</code>方法，以及<code>copy</code>模块中的<code>deepcopy()</code>函数进行列表拷贝的区别。</p><h4 id="1-赋值运算符（-）"><a href="#1-赋值运算符（-）" class="headerlink" title="1. 赋值运算符（=）"></a>1. 赋值运算符（<code>=</code>）</h4><p>使用赋值运算符并不是真正的拷贝，而是创建了一个新的引用指向同一个列表对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1  <span class="comment"># 这不是拷贝，list2只是指向list1的引用</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>list1</code>和<code>list2</code>实际上是指向内存中同一个对象的两个不同名字。任何对<code>list2</code>的修改都会反映到<code>list1</code>上，反之亦然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2.append(<span class="number">6</span>)  <span class="comment"># 修改list2</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5], 6] —— list1也被修改了</span></span><br></pre></td></tr></table></figure><h4 id="2-copy-方法（浅拷贝）"><a href="#2-copy-方法（浅拷贝）" class="headerlink" title="2. .copy()方法（浅拷贝）"></a>2. <code>.copy()</code>方法（浅拷贝）</h4><p>Python的列表对象有一个<code>.copy()</code>方法，用于创建列表的浅拷贝。这意味着它创建了列表的一个新副本，但副本中的元素仍然是原始列表中元素的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = list1.copy()  <span class="comment"># 执行浅拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list1</code>和<code>list2</code>是两个不同的列表对象，<strong>但它们的元素（特别是可变对象，如内部列表）仍然是共享的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [&#x27;four&#x27;, 5]] —— list1也被影响了</span></span><br></pre></td></tr></table></figure><p>尽管<code>list1</code>和<code>list2</code>是不同的列表对象，但由于浅拷贝的性质，它们共享对内部列表的引用。</p><h4 id="3-deepcopy-函数（深拷贝）"><a href="#3-deepcopy-函数（深拷贝）" class="headerlink" title="3. deepcopy()函数（深拷贝）"></a>3. <code>deepcopy()</code>函数（深拷贝）</h4><p><strong>要创建一个完全独立的列表拷贝，包括其所有嵌套对象，应使用<code>copy</code>模块中的<code>deepcopy()</code>函数</strong>。深拷贝会递归地复制对象及其所有子对象，生成一个全新的对象树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">list2 = copy.deepcopy(list1)  <span class="comment"># 执行深拷贝</span></span><br></pre></td></tr></table></figure><p>现在，<code>list2</code>是<code>list1</code>的一个完全独立的拷贝，包括所有嵌套对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">&#x27;four&#x27;</span>  <span class="comment"># 修改list2中的内部列表</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3, [4, 5]] —— list1未受影响</span></span><br></pre></td></tr></table></figure><p>修改<code>list2</code>不会影响<code>list1</code>，因为<code>deepcopy()</code>创建了所有对象的独立拷贝。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>赋值运算符（<code>=</code>）不创建拷贝，只创建引用。</li><li><code>.copy()</code>方法执行浅拷贝，创建新列表但<strong>共享嵌套对象</strong>。</li><li><code>deepcopy()</code>函数执行深拷贝，递归地复制所有对象，生成完全独立的对象树。</li></ul><h2 id="tuple——元组"><a href="#tuple——元组" class="headerlink" title="tuple——元组"></a>tuple——元组</h2><p><strong>和list的区别是不可修改</strong></p><p>元组（Tuple）是Python中的一种不可变序列类型，用于存储一系列有序的元素。与列表（List）不同，元组一旦定义，就不能再修改其内容。元组通常用于存储不应该被改变的数据集合。</p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组使用圆括号<code>()</code>来定义，元素之间使用逗号<code>,</code>分隔。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含多个元素的元组</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="number">5.5</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple)  <span class="comment"># 输出：(1, 2, 3, &#x27;hello&#x27;, 5.5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"><span class="built_in">print</span>(empty_tuple)  <span class="comment"># 输出：()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用tuple()函数来创建一个空元组</span></span><br><span class="line">another_empty_tuple = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="built_in">print</span>(another_empty_tuple)  <span class="comment"># 输出：()</span></span><br></pre></td></tr></table></figure><p>注意，如果元组只包含一个元素，那么该元素后面必须跟一个逗号，否则它不会被识别为元组。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个包含单个元素的元组（注意逗号）</span></span><br><span class="line">single_element_tuple = (<span class="number">42</span>,)</span><br><span class="line"><span class="built_in">print</span>(single_element_tuple)  <span class="comment"># 输出：(42,)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_element_tuple))  <span class="comment"># 输出：&lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有逗号，它会被当作一个普通的表达式，而不是元组</span></span><br><span class="line">not_a_tuple = (<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(not_a_tuple))  <span class="comment"># 输出：&lt;class &#x27;int&#x27;&gt;，因为它被当作了一个整数</span></span><br></pre></td></tr></table></figure><h3 id="元组的不可变性"><a href="#元组的不可变性" class="headerlink" title="元组的不可变性"></a>元组的不可变性</h3><p>元组是不可变的，这意味着一旦创建了一个元组，你就不能添加、删除或更改其元素。尝试这样做会导致TypeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 尝试修改元组（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple[0] = 0  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>然而，如果元组中包含可变对象（如列表），那么这些对象的内容是可以被修改的。但请注意，你不能更改这些可变对象在元组中的身份（即不能用一个新的列表替换原有的列表）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组中包含一个列表</span></span><br><span class="line">my_tuple_with_list = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 修改列表的内容是可以的</span></span><br><span class="line">my_tuple_with_list[<span class="number">2</span>][<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple_with_list)  <span class="comment"># 输出：(1, 2, [-1, 4, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试用一个新的列表替换原有的列表（会导致错误）</span></span><br><span class="line"><span class="comment"># my_tuple_with_list[2] = [6, 7, 8]  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>在实际应用中，如果你需要一个不可变的序列来存储数据，并且这些数据在程序的整个生命周期中都不会改变，那么使用元组是一个很好的选择。元组的不可变性也使其在某些情况下比列表更加高效，因为Python可以在内部对其进行优化。</p><h2 id="string——字符串"><a href="#string——字符串" class="headerlink" title="string——字符串"></a>string——字符串</h2><p>字符串（String）是 Python 中常见的数据容器之一，用于存储字符序列。字符串具有一些独特的特点和操作方法。</p><h3 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h3><p>字符串中的字符可以通过下标进行访问。下标从0开始递增，表示从前往后访问字符；而从-1开始递减，则表示从后往前访问字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 输出: H</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>]) <span class="comment"># 输出: !</span></span><br></pre></td></tr></table></figure><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><p>同元组（Tuple）一样，字符串是一个无法修改的数据容器。一旦一个字符串被创建，就不能修改它的内容。任何对字符串的修改操作都会生成一个新的字符串对象。</p><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h4><p><code>index</code> 方法用于查找子字符串在字符串中首次出现的位置，并返回该位置的索引。如果子字符串不存在，<strong>则会抛出异常</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;you are a handsome boy&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.index(<span class="string">&quot;hand&quot;</span>))  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></table></figure><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h4><p><code>replace</code> 方法用于将字符串中的某个子字符串替换为另一个字符串，并返回替换后的新字符串。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">s1 = s.replace(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;tiger&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># 输出替换后的新字符串</span></span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split 方法"></a>split 方法</h4><p><code>split</code> 方法用于根据指定的分隔符将字符串分割成多个子字符串，并将这些子字符串存储在列表中返回。原始字符串本身不会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;cats and dogs are good cats and dogs and cats and dogs do things cats and dogs like do&quot;</span></span><br><span class="line">l = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出原始字符串</span></span><br><span class="line"><span class="built_in">print</span>(l)  <span class="comment"># 输出分割后的列表</span></span><br></pre></td></tr></table></figure><h4 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip 方法"></a>strip 方法</h4><p><code>strip</code> 方法用于去除字符串开头和结尾的空白字符（包括空格、制表符、换行符等），并返回处理后的新字符串。原始字符串本身不会被修改。如果指定了参数，则会去除前后指定的字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;  12abcde1  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip())      <span class="comment"># 输出: &quot;12abcde1&quot;</span></span><br><span class="line">s = <span class="string">&quot;12abcde1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.strip(<span class="string">&quot;12&quot;</span>))  <span class="comment">#输出:&quot;abcde&quot;</span></span><br></pre></td></tr></table></figure><h4 id="count-方法"><a href="#count-方法" class="headerlink" title="count 方法"></a>count 方法</h4><p><code>count</code> 方法用于统计某个子字符串在字符串中出现的次数，并返回该次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">&quot;114&quot;</span>))  <span class="comment"># 输出: 4</span></span><br></pre></td></tr></table></figure><h4 id="len-函数"><a href="#len-函数" class="headerlink" title="len 函数"></a>len 函数</h4><p><code>len</code> 函数用于获取字符串的长度，即字符的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;114514514114514514114114&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出: 24</span></span><br></pre></td></tr></table></figure><p>请注意，虽然 <code>len</code> 是一个内置函数而不是字符串的方法，但它经常用于获取字符串的长度，因此在这里也一并提及。</p><h3 id="Python-中常用处理字符串的相关函数"><a href="#Python-中常用处理字符串的相关函数" class="headerlink" title="Python 中常用处理字符串的相关函数"></a>Python 中常用处理字符串的相关函数</h3><p>在Python中，字符串是不可变的，但Python提供了很多方法来操作字符串。这些方法可以帮助我们完成各种任务，如查找子字符串，替换子字符串，分割字符串等。下面列出了一些Python中常用的字符串方法：</p><h4 id="字符串首字母大写"><a href="#字符串首字母大写" class="headerlink" title="字符串首字母大写"></a>字符串首字母大写</h4><p><code>string.capitalize()</code></p><p>该方法返回字符串的一个副本，其中第一个字符为大写，其余为小写。</p><h4 id="计数子字符串"><a href="#计数子字符串" class="headerlink" title="计数子字符串"></a>计数子字符串</h4><p><code>string.count(str, beg=0, end=len(string))</code></p><p>该方法返回子字符串在字符串中出现的次数。可选参数<code>beg</code>和<code>end</code>是字符串中要开始和结束搜索的索引范围。</p><h4 id="检查字符串结束"><a href="#检查字符串结束" class="headerlink" title="检查字符串结束"></a>检查字符串结束</h4><p><code>string.endswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的后缀结束，如果是则返回<code>True</code>，否则返回<code>False</code>。可选参数<code>beg</code>和<code>end</code>指定需要检查的字符串的子集。</p><h4 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h4><p><code>string.find(str, beg=0, end=len(string))</code></p><p>该方法检测字符串中是否包含子字符串<code>str</code>，如果包含则返回开始的索引值，否则返回-1。搜索可以指定开始和结束的索引范围。</p><h4 id="类似find但异常"><a href="#类似find但异常" class="headerlink" title="类似find但异常"></a>类似find但异常</h4><p><code>string.index(str, beg=0, end=len(string))</code></p><p>与<code>find()</code>方法类似，但如果子字符串不在字符串中，则会引发一个异常。</p><h4 id="检查字母和数字"><a href="#检查字母和数字" class="headerlink" title="检查字母和数字"></a>检查字母和数字</h4><ul><li><code>string.isalnum()</code>：如果字符串至少有一个字符并且所有字符都是字母或数字，则返回<code>True</code>。</li><li><code>string.isalpha()</code>：如果字符串至少有一个字符并且所有字符都是字母，则返回<code>True</code>。</li><li><code>string.isdecimal()</code>：如果字符串只包含十进制数字，则返回<code>True</code>。</li><li><code>string.isdigit()</code>：如果字符串只包含数字，则返回<code>True</code>。</li></ul><h4 id="检查大小写"><a href="#检查大小写" class="headerlink" title="检查大小写"></a>检查大小写</h4><ul><li><code>string.islower()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是小写，则返回<code>True</code>。</li><li><code>string.isupper()</code>：如果字符串中包含至少一个区分大小写的字符，并且所有这些字符都是大写，则返回<code>True</code>。</li></ul><h4 id="其他检查"><a href="#其他检查" class="headerlink" title="其他检查"></a>其他检查</h4><ul><li><code>string.isnumeric()</code>：如果字符串中只包含数字字符，则返回<code>True</code>。</li><li><code>string.isspace()</code>：如果字符串中只包含空格，则返回<code>True</code>。</li><li><code>string.istitle()</code>：如果字符串是标题化的（即每个单词的首字母大写），则返回<code>True</code>。</li></ul><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p><strong><code>string.join(seq)</code></strong></p><p>该方法以指定的字符串作为分隔符，将序列中的元素连接成一个新的字符串。</p><p><strong>使用加号 <code>+</code> 运算符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello&quot;</span>  </span><br><span class="line">str2 = <span class="string">&quot;World&quot;</span>  </span><br><span class="line">str3 = str1 + <span class="string">&quot; &quot;</span> + str2  </span><br><span class="line"><span class="built_in">print</span>(str3)  <span class="comment"># 输出: Hello World</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <code>+</code> 运算符和空格字符串来连接 <code>str1</code> 和 <code>str2</code>。</p><h4 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h4><ul><li><code>string.lower()</code>：将字符串中的所有大写字符转换为小写。</li><li><code>string.upper()</code>：将字符串中的所有小写字符转换为大写。</li></ul><h4 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h4><ul><li><code>string.lstrip()</code>：删除字符串左边的空格。</li><li><code>string.rstrip()</code>：删除字符串右边的空格（注：该方法未在上文列出，但经常与<code>lstrip()</code>一起使用）。</li><li><code>string.strip([obj])</code>：在字符串上同时执行<code>lstrip()</code>和<code>rstrip()</code>，删除两端的空格或指定字符。</li></ul><h4 id="替换子字符串"><a href="#替换子字符串" class="headerlink" title="替换子字符串"></a>替换子字符串</h4><p><code>string.replace(str1, str2, num=string.count(str1))</code></p><p>该方法把字符串中的<code>str1</code>替换成<code>str2</code>，如果指定了<code>num</code>，则替换不超过<code>num</code>次。</p><h4 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h4><p><code>string.split(str=&quot;&quot;, num=string.count(str))</code></p><p>该方法以指定的分隔符切片字符串，如果指定了<code>num</code>，则仅分隔出<code>num+1</code>个子字符串。</p><h4 id="检查字符串开始"><a href="#检查字符串开始" class="headerlink" title="检查字符串开始"></a>检查字符串开始</h4><p><code>string.startswith(obj, beg=0, end=len(string))</code></p><p>该方法检查字符串是否以指定的前缀开始，如果是则返回<code>True</code>，否则返回<code>False</code>。</p><h4 id="交换大小写"><a href="#交换大小写" class="headerlink" title="交换大小写"></a>交换大小写</h4><p><code>string.swapcase()</code></p><p>该方法翻转字符串中的大小写，即大写变小写，小写变大写。</p><h4 id="标题化字符串"><a href="#标题化字符串" class="headerlink" title="标题化字符串"></a>标题化字符串</h4><p><code>string.title()</code></p><p>该方法返回“标题化”的字符串，即所有单词的首字母大写，其余小写。</p><p>需要注意的是，字符串的方法很多，而且功能强大，但这里只列出了一些常用的方法。在实际编程中，可以根据需要选择合适的方法来操作字符串。</p><h2 id="序列的切片"><a href="#序列的切片" class="headerlink" title="序列的切片"></a>序列的切片</h2><p>序列是内容连续、有序，且可以使用下标索引的一类数据容器。在Python中，列表、元组、字符串均可以视为序列。</p><p>对序列进行切片操作可以得到序列的一个子序列。切片操作使用冒号(<code>:</code>)分隔的下标索引来实现，基本语法为<code>sequence[start:end:step]</code>，其中：</p><ul><li><code>sequence</code>表示要进行切片操作的序列。</li><li><code>start</code>表示切片操作的起始位置（包含该位置），如果省略则表示从头开始。</li><li><code>end</code>表示切片操作的结束位置（不包含该位置），如果省略则表示直到序列末尾。</li><li><code>step</code>表示切片操作的步长，即每隔多少个元素取一个，如果省略则表示步长为1。</li></ul><p>注意，<strong>切片操作不会影响序列本身</strong>，而是会得到一个新的序列。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引1开始到索引4之前（不包含索引4）的子序列</span></span><br><span class="line">result1 = mylist[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(result1)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引2开始到索引9之前，每隔2个元素取一个的子序列</span></span><br><span class="line">result2 = mylist[<span class="number">2</span>:<span class="number">9</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result2)  <span class="comment"># 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组的切片操作与列表类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mytuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头到尾的子序列（复制整个元组）</span></span><br><span class="line">r1 = mytuple[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r1=<span class="subst">&#123;r1&#125;</span>&quot;</span>)  <span class="comment"># 输出: r1=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从尾到头的子序列（反转整个元组）</span></span><br><span class="line">r2 = mytuple[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;r2=<span class="subst">&#123;r2&#125;</span>&quot;</span>)  <span class="comment"># 输出: r2=(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)</span></span><br></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>字符串也可以进行切片操作，得到一个新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mystring = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引7开始到末尾的子字符串</span></span><br><span class="line">result3 = mystring[<span class="number">7</span>:]</span><br><span class="line"><span class="built_in">print</span>(result3)  <span class="comment"># 输出: World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从头开始到索引5之前（不包含索引5）的子字符串，每隔2个字符取一个</span></span><br><span class="line">result4 = mystring[:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result4)  <span class="comment"># 输出: Hlo</span></span><br></pre></td></tr></table></figure><h2 id="Set——集合"><a href="#Set——集合" class="headerlink" title="Set——集合"></a>Set——集合</h2><p>集合是一个无序的、不重复的数据集合。在Python中，集合用花括号<code>&#123;&#125;</code>或者<code>set()</code>函数创建，但由于花括号<code>&#123;&#125;</code>同时用于表示字典，所以空集合必须用<code>set()</code>表示，而不是<code>&#123;&#125;</code>。</p><h3 id="集合的创建与特性"><a href="#集合的创建与特性" class="headerlink" title="集合的创建与特性"></a>集合的创建与特性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用花括号创建集合（非空集合）</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="comment"># 使用set()创建空集合</span></span><br><span class="line">c = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印集合a和c</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 11&#125;，注意重复元素被自动去除了</span></span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出: set()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：空的大括号表示字典，不是集合</span></span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))  <span class="comment"># 输出: &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="集合的修改"><a href="#集合的修改" class="headerlink" title="集合的修改"></a>集合的修改</h3><p>集合是可变的，可以添加或删除元素。</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>使用<code>.add()</code>方法向集合添加元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.add(<span class="number">1</span>)  <span class="comment"># 添加元素1到集合a中</span></span><br><span class="line">a.add(<span class="number">5</span>)  <span class="comment"># 添加元素5（已存在，不会重复添加）</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5, 6, 7, 11&#125;</span></span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>使用<code>.remove()</code>方法从集合中移除指定元素；使用<code>.pop()</code>方法随机移除并返回集合中的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">a.remove(<span class="number">3</span>)  <span class="comment"># 移除元素3</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: &#123;2, 4, 5, 6, 7, 11&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pop()方法从集合中随机移除元素并打印</span></span><br><span class="line">a = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(a) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(a.pop())</span><br><span class="line"><span class="comment"># 输出可能是集合a中的任意元素，因为移除是随机的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：pop()取出的过程对于字符串是随机的,即每次运行结果都不同</span></span><br></pre></td></tr></table></figure><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>使用<code>.difference()</code>方法可以得到两个集合的差集，即存在于第一个集合但不存在于第二个集合的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">diff = set1.difference(set2)</span><br><span class="line"><span class="built_in">print</span>(diff)  <span class="comment"># 输出: &#123;1, 2, 3&#125;，这些元素只存在于set1中</span></span><br></pre></td></tr></table></figure><h4 id="差集并更新左集合"><a href="#差集并更新左集合" class="headerlink" title="差集并更新左集合"></a>差集并更新左集合</h4><p>使用<code>.difference_update()</code>方法可以直接更新左集合为差集结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">set1.difference_update(set2)  <span class="comment"># set1现在更新为差集结果</span></span><br><span class="line"><span class="built_in">print</span>(set1)  <span class="comment"># 输出: &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>使用<code>.union()</code>方法可以得到两个集合的并集，即两个集合中所有不重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">union_set = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(union_set)  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="集合的长度"><a href="#集合的长度" class="headerlink" title="集合的长度"></a>集合的长度</h3><p>使用<code>len()</code>函数可以得到集合中元素的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a))  <span class="comment"># 输出: 9，因为集合自动去除了重复元素</span></span><br></pre></td></tr></table></figure><h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>由于集合不支持下标索引，所以不能使用<code>while</code>循环通过下标来遍历集合。但可以使用<code>for</code>循环直接遍历集合中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> set1:</span><br><span class="line">    <span class="built_in">print</span>(ele, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 输出: 1 2 3 4 5（顺序可能不同，因为集合是无序的）</span></span><br></pre></td></tr></table></figure><h2 id="字典——dict"><a href="#字典——dict" class="headerlink" title="字典——dict"></a>字典——dict</h2><p>字典（dict）是Python中的一种基本数据结构，用于存储键值对（key-value pairs）。字典是无序的，即元素的插入顺序和迭代顺序可能不一致。<strong>字典的键（key）必须是不可变的类型</strong>，如整数、浮点数、字符串、元组等，而值（value）可以是任意Python对象。</p><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><p>字典可以通过大括号 <code>&#123;&#125;</code> 或 <code>dict()</code> 函数来创建。大括号中，键值对之间用冒号分隔，每对键值对之间用逗号分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line">d2 = &#123;&#125;  <span class="comment"># 空字典</span></span><br><span class="line">d3 = <span class="built_in">dict</span>()  <span class="comment"># 通过dict()函数创建空字典</span></span><br></pre></td></tr></table></figure><h3 id="访问字典元素"><a href="#访问字典元素" class="headerlink" title="访问字典元素"></a>访问字典元素</h3><p>字典中的元素可以通过键来访问。使用方括号 <code>[]</code> 和键名来获取对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1[<span class="string">&quot;b&quot;</span>])  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><h3 id="新增和更新字典元素"><a href="#新增和更新字典元素" class="headerlink" title="新增和更新字典元素"></a>新增和更新字典元素</h3><p>可以通过方括号 <code>[]</code> 来新增或更新字典中的元素。如果键已经存在，则对应的值会被更新；如果键不存在，则会在字典中新增一个键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line">d1[<span class="string">&quot;c&quot;</span>] = <span class="number">99</span>  <span class="comment"># 新增键值对</span></span><br><span class="line">d1[<span class="string">&quot;a&quot;</span>] = <span class="number">100</span>  <span class="comment"># 更新键&quot;a&quot;对应的值</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>字典不支持访问不存在的键，否则会抛出<code>KeyError</code>异常</strong>。如果尝试访问不存在的键，可以使用<code>get()</code>方法，该方法允许指定一个默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d1.get(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;Not Found&quot;</span>))  <span class="comment"># 输出 &quot;Not Found&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>可以使用<code>pop()</code>方法来删除字典中的元素，并返回被删除元素的值。<strong>如果尝试删除不存在的键，<code>pop()</code>方法会抛出<code>KeyError</code>异常，但可以通过提供第二个参数来指定一个默认值</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">value = d1.pop(<span class="string">&quot;b&quot;</span>)  <span class="comment"># 删除键&quot;b&quot;并返回其值</span></span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># 输出 98</span></span><br></pre></td></tr></table></figure><p>另外，<code>clear()</code>方法可以清空字典中的所有元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1.clear()  <span class="comment"># 清空字典</span></span><br><span class="line"><span class="built_in">print</span>(d1)  <span class="comment"># 输出 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="获取字典的键和值"><a href="#获取字典的键和值" class="headerlink" title="获取字典的键和值"></a>获取字典的键和值</h3><p>可以使用<code>keys()</code>方法获取字典中所有的键，<code>values()</code>方法获取所有的值。<strong>这两个方法返回的都是视图对象，它们会反映字典的任何更改。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">keys = d1.keys()</span><br><span class="line">values = d1.values()</span><br><span class="line"><span class="built_in">print</span>(keys)  <span class="comment"># 输出 dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(values)  <span class="comment"># 输出 dict_values([97, 98, 99])</span></span><br></pre></td></tr></table></figure><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p>字典可以通过多种方式进行遍历。最常见的是遍历所有的键，然后使用键来访问对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;d1[key]&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>还可以直接遍历字典的项（键值对），这可以通过<code>items()</code>方法来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d1.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;key=<span class="subst">&#123;key&#125;</span>, value=<span class="subst">&#123;value&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="统计字典元素数量"><a href="#统计字典元素数量" class="headerlink" title="统计字典元素数量"></a>统计字典元素数量</h3><p>使用<code>len()</code>函数可以获取字典中元素的数量（键值对的数量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d1))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><h3 id="判断元素是否在字典内"><a href="#判断元素是否在字典内" class="headerlink" title="判断元素是否在字典内"></a>判断元素是否在字典内</h3><p>可以使用<code>in</code>关键字来判断一个键是否存在于字典中。同样地，<code>not in</code>可以用来判断一个键是否不存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;c&quot;</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in&quot;</span>)  <span class="comment"># 输出 in</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;p&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> d1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not in&quot;</span>)  <span class="comment"># 输出 not in</span></span><br></pre></td></tr></table></figure><h2 id="容器常用功能"><a href="#容器常用功能" class="headerlink" title="容器常用功能"></a>容器常用功能</h2><h3 id="容器之间的转换"><a href="#容器之间的转换" class="headerlink" title="容器之间的转换"></a>容器之间的转换</h3><h4 id="转换为列表-list"><a href="#转换为列表-list" class="headerlink" title="转换为列表(list)"></a>转换为列表(list)</h4><p>在Python中，列表（list）是一种非常常用的数据结构，它可以容纳不同类型的元素，包括数字、字符串、元组、集合甚至字典等。Python提供了便捷的方式将这些容器类型转换为列表。</p><h5 id="从元组-tuple-转换"><a href="#从元组-tuple-转换" class="headerlink" title="从元组(tuple)转换"></a>从元组(tuple)转换</h5><p>元组与列表非常相似，但元组是不可变的。我们可以使用<code>list()</code>函数将元组转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a1))  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h5 id="从字符串-string-转换"><a href="#从字符串-string-转换" class="headerlink" title="从字符串(string)转换"></a>从字符串(string)转换</h5><p>字符串可以被看作字符的序列，因此也可以被转换为列表，每个字符成为列表的一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1 = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(b1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="从集合-set-转换"><a href="#从集合-set-转换" class="headerlink" title="从集合(set)转换"></a>从集合(set)转换</h5><p>集合是一个无序的不重复元素集，转换为列表后会得到一个包含集合中所有元素的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(c1))  <span class="comment"># 输出可能是: [1, 2, 3, 4, 5] （因为集合是无序的，所以实际输出可能不同）</span></span><br></pre></td></tr></table></figure><h5 id="从字典-dictionary-转换"><a href="#从字典-dictionary-转换" class="headerlink" title="从字典(dictionary)转换"></a>从字典(dictionary)转换</h5><p>字典转换为列表时，默认只包含字典的键(key)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">97</span>, <span class="string">&quot;b&quot;</span>: <span class="number">98</span>, <span class="string">&quot;c&quot;</span>: <span class="number">99</span>, <span class="string">&quot;d&quot;</span>: <span class="number">100</span>, <span class="string">&quot;e&quot;</span>: <span class="number">101</span>, <span class="string">&quot;f&quot;</span>: <span class="number">102</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1))  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]（字典的键转换为列表）</span></span><br></pre></td></tr></table></figure><p><strong>如果想要同时获取键和值，可以使用<code>items()</code>方法</strong>，它会返回一个包含键值对的元组列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d1.items()))  <span class="comment"># 输出: [(&#x27;a&#x27;, 97), (&#x27;b&#x27;, 98), (&#x27;c&#x27;, 99), (&#x27;d&#x27;, 100), (&#x27;e&#x27;, 101), (&#x27;f&#x27;, 102)]</span></span><br></pre></td></tr></table></figure><h3 id="转换为其他类型"><a href="#转换为其他类型" class="headerlink" title="转换为其他类型"></a>转换为其他类型</h3><p>当然，Python也允许我们将列表转换为其他类型，如元组、字符串、集合等。</p><h4 id="转换为元组-tuple"><a href="#转换为元组-tuple" class="headerlink" title="转换为元组(tuple)"></a>转换为元组(tuple)</h4><p>使用<code>tuple()</code>函数可以将列表转换为元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(lst))  <span class="comment"># 输出: (1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure><h4 id="转换为字符串-string"><a href="#转换为字符串-string" class="headerlink" title="转换为字符串(string)"></a>转换为字符串(string)</h4><p>在Python中，将列表转化为字符串可以通过多种方式实现。最常见的方法是使用 <code>join()</code> 方法，它可以将列表中的元素连接起来形成一个字符串。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;list&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用空格作为分隔符将列表元素连接成字符串  </span></span><br><span class="line">my_string = <span class="string">&#x27; &#x27;</span>.join(my_list)  </span><br><span class="line"><span class="built_in">print</span>(my_string)  <span class="comment"># 输出：Hello world this is a list  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 如果列表中包含数字或其他非字符串类型，需要先将它们转换为字符串  </span></span><br><span class="line">my_mixed_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用map函数和str将列表中的每个元素转换为字符串，然后再连接  </span></span><br><span class="line">my_string_from_mixed_list = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, my_mixed_list))  </span><br><span class="line"><span class="built_in">print</span>(my_string_from_mixed_list)  <span class="comment"># 输出：1 2 3 apple banana</span></span><br></pre></td></tr></table></figure><h4 id="转换为集合-set"><a href="#转换为集合-set" class="headerlink" title="转换为集合(set)"></a>转换为集合(set)</h4><p>使用<code>set()</code>函数可以将列表转换为集合，从而去除重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(lst))  <span class="comment"># 输出: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="排序功能-sorted"><a href="#排序功能-sorted" class="headerlink" title="排序功能(sorted)"></a>排序功能(sorted)</h3><p>Python的<code>sorted()</code>函数可以对任何可迭代对象进行排序，并返回一个列表。默认情况下，排序是升序的，但<strong>可以通过<code>reverse=True</code>参数进行降序排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1 = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1))  <span class="comment"># 输出: [0, 2, 4, 5, 6] （升序）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a1, reverse=<span class="literal">True</span>))  <span class="comment"># 输出: [6, 5, 4, 2, 0] （降序）</span></span><br></pre></td></tr></table></figure><p>对于字符串和字典的排序，<code>sorted()</code>函数会根据元素的字符顺序或键的顺序进行排序。如果想要根据其他标准进行排序，可以使用<code>key</code>参数指定一个函数来提取用于排序的值。</p><h1 id="头等函数"><a href="#头等函数" class="headerlink" title="头等函数"></a>头等函数</h1><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>在Python中，函数是对象，可以像其他对象一样被传递作为参数。这种能力使得函数变得更加灵活和强大。你可以将函数作为参数传递给其他函数，或者从其他函数中返回函数。</p><h3 id="函数作为参数的示例"><a href="#函数作为参数的示例" class="headerlink" title="函数作为参数的示例"></a>函数作为参数的示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将add函数作为参数传递给test_func</span></span><br><span class="line">test_func(add)</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>test_func</code>接收一个名为<code>compute</code>的函数作为参数，并使用它来计算1和2的和。然后打印结果和<code>compute</code>的类型，显示为<code>&lt;class &#39;function&#39;&gt;</code>，表明<code>compute</code>确实是一个函数对象。</p><h2 id="使用lambda匿名函数作为参数"><a href="#使用lambda匿名函数作为参数" class="headerlink" title="使用lambda匿名函数作为参数"></a>使用lambda匿名函数作为参数</h2><p>lambda函数是一种简洁的写函数的方式，它可以在一行内定义简单的函数。lambda函数是匿名的，因为它们没有正式的函数名，但可以将它们赋值给变量，或者以其他方式使用，例如作为函数的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">compute</span>):</span><br><span class="line">    result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(compute))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将lambda函数作为参数传递给test_func</span></span><br><span class="line">test_func(<span class="keyword">lambda</span> x, y: x + y)<span class="comment">#可以不写出return</span></span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这里，我们创建了一个lambda函数<code>lambda x, y: x + y</code>，它接收两个参数<code>x</code>和<code>y</code>，并返回它们的和。然后我们将这个lambda函数作为参数传递给<code>test_func</code>。输出与前面的例子相同，因为lambda函数的行为与<code>add</code>函数相同。</p><p>请注意，在lambda函数中，虽然我们没有明确写出<code>return</code>关键字，但表达式<code>x + y</code>的结果会被自动返回。这是lambda函数的一个特点：它们总是返回表达式的结果。</p><p>在Python中，<strong><code>lambda</code>函数是设计为单行表达式函数的，它们只能包含一个表达式，该表达式的值会被返回。</strong>因此，<code>lambda</code>函数不支持多行语句或多条指令。如果你想定义一个多行的函数，你应该使用<code>def</code>关键字来定义一个常规函数。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>在Python中，模块（Module）是一个包含Python定义和语句的文件。文件名就是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等功能。模块可以包含可执行的语句和定义函数、类和变量。模块让你能够有逻辑地组织你的Python代码段，实现代码重用。</p><h3 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h3><h4 id="1-使用import语句导入整个模块"><a href="#1-使用import语句导入整个模块" class="headerlink" title="1. 使用import语句导入整个模块"></a>1. 使用<code>import</code>语句导入整个模块</h4><p>你可以使用<code>import</code>语句导入整个模块，并通过模块名来访问其中的函数、类、变量等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  <span class="comment"># 导入整个time模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment"># 使用time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="2-使用from-import-语句导入模块中的特定部分"><a href="#2-使用from-import-语句导入模块中的特定部分" class="headerlink" title="2. 使用from ... import ...语句导入模块中的特定部分"></a>2. 使用<code>from ... import ...</code>语句导入模块中的特定部分</h4><p>如果你只需要模块中的某个函数或类，可以使用<code>from ... import ...</code>语句将其导入到当前命名空间中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep  <span class="comment"># 只导入time模块中的sleep函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="3-使用from-import-语句导入模块中的所有内容"><a href="#3-使用from-import-语句导入模块中的所有内容" class="headerlink" title="3. 使用from ... import *语句导入模块中的所有内容"></a>3. 使用<code>from ... import *</code>语句导入模块中的所有内容</h4><p>虽然这种方式可以导入模块中的所有内容，<strong>但通常不推荐使用，因为它可能导致命名冲突和不可预见的行为。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *  <span class="comment"># 导入time模块中的所有内容（不推荐）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)  <span class="comment"># 直接使用sleep函数，不需要加模块名前缀</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给模块起别名"><a href="#给模块起别名" class="headerlink" title="给模块起别名"></a>给模块起别名</h3><p>如果模块名太长或与其他模块名冲突，你可以使用<code>as</code>关键字给模块起一个别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t  <span class="comment"># 给time模块起别名为t</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">t.sleep(<span class="number">1</span>)  <span class="comment"># 使用别名t来访问time模块中的sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="给函数起别名"><a href="#给函数起别名" class="headerlink" title="给函数起别名"></a>给函数起别名</h3><p>同样地，你也可以使用<code>as</code>关键字给导入的函数起别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl  <span class="comment"># 给sleep函数起别名为sl</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">sl(<span class="number">1</span>)  <span class="comment"># 使用别名sl来调用sleep函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="定义自己的模块"><a href="#定义自己的模块" class="headerlink" title="定义自己的模块"></a>定义自己的模块</h2><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>在Python中，模块是一个包含Python定义和语句的文件。文件名是模块名加上<code>.py</code>后缀。模块可以被其他程序引入，以使用该模块中的函数、类等。在本例中，我们将创建一个简单的模块，并展示如何在其他文件中导入和使用它。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>首先，我们创建一个名为<code>greetings.py</code>的模块，它包含一个名为<code>print_hi</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># greetings.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hi</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Hi, <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print_hi(<span class="string">&#x27;PyCharm&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个模块中：</p><ul><li>我们定义了一个名为<code>print_hi</code>的函数，它接受一个参数<code>name</code>，并打印出问候语。</li><li>我们使用了一个特殊的条件语句<code>if __name__ == &#39;__main__&#39;:</code>。当<strong>这个模块作为主程序运行时（即直接运行<code>greetings.py</code>文件），这个条件语句下的代码会被执行</strong>。因此，它会打印出“Hi, PyCharm”。但是，当这个模块被其他文件导入时，这个条件语句下的代码不会被执行。</li></ul><h2 id="导入和使用模块"><a href="#导入和使用模块" class="headerlink" title="导入和使用模块"></a>导入和使用模块</h2><p>现在，我们可以在另一个Python文件中导入这个模块，并使用它提供的函数。例如，创建一个名为<code>main.py</code>的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> greetings</span><br><span class="line"></span><br><span class="line">greetings.print_hi(<span class="string">&#x27;Alice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个文件中，我们使用<code>import</code>语句导入了<code>greetings</code>模块，并<strong>使用点符号（<code>.</code>）访问模块中的<code>print_hi</code>函数</strong>。当我们运行<code>main.py</code>文件时，它会输出“Hi, Alice”。</p><p>注意，由于我们在<code>greetings.py</code>文件中使用了<code>if __name__ == &#39;__main__&#39;:</code>语句，所以当我们导入这个模块时，它不会自动执行<code>print_hi(&#39;PyCharm&#39;)</code>语句。因此，输出仅为“Hi, Alice”，而不包括“Hi, PyCharm”。</p><h1 id="自定义Python包"><a href="#自定义Python包" class="headerlink" title="自定义Python包"></a>自定义Python包</h1><h2 id="什么是Python包"><a href="#什么是Python包" class="headerlink" title="什么是Python包"></a>什么是Python包</h2><p>从物理结构上看，<strong>Python包就是一个文件夹</strong>，它包含一个<code>__init__.py</code>文件，并且该文件夹内可以包含多个模块文件（即.py文件）。这个文件夹的层级结构可以表示包的层级关系。</p><p>从逻辑层面来看，包可以看作是一个更大规模的模块，它允许我们将相关的模块组织在一起，形成一个有层次的命名空间。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>在Python中，导入包有几种不同的方式：</p><h3 id="方式一：使用import语句"><a href="#方式一：使用import语句" class="headerlink" title="方式一：使用import语句"></a>方式一：使用import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式二：使用from…import语句"><a href="#方式二：使用from…import语句" class="headerlink" title="方式二：使用from…import语句"></a>方式二：使用from…import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> 模块名</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名.目标函数()</span><br></pre></td></tr></table></figure><h3 id="方式三：直接导入目标函数"><a href="#方式三：直接导入目标函数" class="headerlink" title="方式三：直接导入目标函数"></a>方式三：直接导入目标函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名.模块名 <span class="keyword">import</span> 目标函数</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数()</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在使用包中的模块或函数之前，需要确保包已经被正确安装或位于Python的搜索路径中。</li><li><code>__init__.py</code>文件是包的初始化文件，它可以是空的，也可以包含一些初始化代码或定义<code>__all__</code>变量来指定当使用<code>from 包名 import *</code>时应该导入哪些模块。</li></ul><h2 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h2><h3 id="什么是第三方包"><a href="#什么是第三方包" class="headerlink" title="什么是第三方包"></a>什么是第三方包</h3><p>第三方包指的是非Python官方提供的包，它们由Python社区中的开发者创建和维护。这些包通常用于解决特定的问题或提供特定的功能，例如数据处理、机器学习、网络编程等。</p><h3 id="安装第三方包-pip"><a href="#安装第三方包-pip" class="headerlink" title="安装第三方包 - pip"></a>安装第三方包 - pip</h3><p>pip是Python的包管理工具，它允许你轻松地安装、升级和卸载Python包。你可以使用pip来安装第三方包。</p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p>在命令行中，使用以下命令来安装第三方包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名称</span><br></pre></td></tr></table></figure><p>这将会从Python Package Index（PyPI）下载并安装包。</p><h3 id="pip的网络优化"><a href="#pip的网络优化" class="headerlink" title="pip的网络优化"></a>pip的网络优化</h3><p>由于pip默认连接的是国外的PyPI源，有时下载速度可能会很慢。你<strong>可以通过指定国内的镜像源来加速包的下载</strong>。例如，使用清华大学提供的PyPI镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</span><br></pre></td></tr></table></figure><p>或者，你可以永久地修改pip的配置文件，将默认的源替换为国内的镜像源。这样，每次使用pip安装包时都会自动从国内的镜像源下载。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>在安装第三方包之前，确保你的Python环境已经正确设置，并且pip工具已经安装。</li><li>有些第三方包可能依赖于其他包或特定版本的Python，因此在安装之前最好查看包的文档以了解其依赖关系和要求。</li><li><strong>如果你使用的是虚拟环境（virtualenv或conda等），则应在激活虚拟环境后安装第三方包，以确保它们仅在当前虚拟环境中可用。</strong></li></ul><h1 id="定义自己的数据类型——类和对象"><a href="#定义自己的数据类型——类和对象" class="headerlink" title="定义自己的数据类型——类和对象"></a>定义自己的数据类型——类和对象</h1><p>在Python中，类（Class）是一种抽象数据类型，它定义了包含数据（属性）和方法（函数）的对象的行为和状态。对象是类的实例，它具体地表示了类的属性和行为。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类可以通过<code>class</code>关键字来定义，类的名称通常以大写字母开头。类中可以定义属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cla</span>:</span><br><span class="line">    a = <span class="literal">None</span></span><br><span class="line">    b = <span class="literal">None</span></span><br><span class="line">    c = <span class="literal">None</span></span><br><span class="line">    d = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Cla</code>是一个类，它定义了四个类属性<code>a</code>、<code>b</code>、<code>c</code>和<code>d</code>，它们都被初始化为<code>None</code>。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>类中提供了私有成员的形式来支持。</p><ul><li>私有成员变量</li><li>私有成员方法</li></ul><p>定义私有成员的方式非常简单,只需要:</p><ul><li>私有成员变量:变量名以<code>__</code>开头(2个下划线)</li><li>私有成员方法:方法名以<code>__</code>开头（2个下划线）</li></ul><p>即可完成私有成员的设置</p><h2 id="对象的创建和属性赋值"><a href="#对象的创建和属性赋值" class="headerlink" title="对象的创建和属性赋值"></a>对象的创建和属性赋值</h2><p>要创建一个类的实例（对象），可以使用类名加上括号。然后可以通过点操作符<code>.</code>来访问对象的属性或方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = Cla()  <span class="comment"># 创建一个Cla类的实例对象c</span></span><br><span class="line">c.a = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 给对象c的a属性赋值</span></span><br><span class="line">c.b = <span class="number">1</span>      <span class="comment"># 给对象c的b属性赋值</span></span><br><span class="line">c.c = <span class="number">114.514</span>  <span class="comment"># 给对象c的c属性赋值</span></span><br><span class="line">c.d = <span class="literal">True</span>     <span class="comment"># 给对象c的d属性赋值</span></span><br></pre></td></tr></table></figure><p><strong>打印对象<code>c</code>会显示其内存地址</strong>，打印<code>type(c)</code>会显示其类型，而打印<code>c.a</code>则会显示其<code>a</code>属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(c)       <span class="comment"># 输出对象c的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># 输出对象c的类型</span></span><br><span class="line"><span class="built_in">print</span>(c.a)     <span class="comment"># 输出对象c的a属性的值</span></span><br></pre></td></tr></table></figure><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><p>类还可以定义方法，方法是类的函数，它可以在类的对象上执行操作。<strong>方法的第一个参数总是<code>self</code>，它表示对象本身。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self</span>):<span class="comment">#self是必须填写的，调用类的方法的时候会自动传入该对象</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi_with_msg</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Man</code>类定义了两个方法：<code>say_hi</code>和<code>say_hi_with_msg</code>。这两个方法都接受<code>self</code>作为第一个参数，表示对象本身。<code>say_hi</code>方法打印出对象的<code>name</code>属性，而<code>say_hi_with_msg</code>方法则打印出对象的<code>name</code>属性和一个额外的消息。</p><h3 id="对象的方法调用"><a href="#对象的方法调用" class="headerlink" title="对象的方法调用"></a>对象的方法调用</h3><p>要调用对象的方法，<strong>可以使用点操作符<code>.</code>和方法名</strong>。如果方法需要参数，可以在方法名后面的括号中提供。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">he = Man()         <span class="comment"># 创建一个Man类的实例对象he</span></span><br><span class="line">he.name = <span class="string">&quot;某人&quot;</span>   <span class="comment"># 给对象he的name属性赋值</span></span><br><span class="line">he.say_hi()        <span class="comment"># 调用对象he的say_hi方法</span></span><br><span class="line">he.say_hi_with_msg(<span class="string">&quot;hhhhhhh&quot;</span>)  <span class="comment"># 调用对象he的say_hi_with_msg方法并传递一个参数</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>在Python中，类的构造方法是<code>__init__()</code>。当创建类的新实例时，这个方法会自动被调用。构造方法通常用于初始化新创建对象的属性。</strong></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>下面是一个简单的<code>Student</code>类，它使用构造方法来初始化学生的姓名、年龄和电话号码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Student对象</span></span><br><span class="line">stu = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们创建<code>stu</code>对象时，<code>__init__</code>方法被调用，并且我们传递的参数（”张三”, 31, “1145141919810”）被用来初始化对象的属性。</p><h3 id="魔术方法（Magic-Methods）"><a href="#魔术方法（Magic-Methods）" class="headerlink" title="魔术方法（Magic Methods）"></a>魔术方法（Magic Methods）</h3><p>Python中的魔术方法，也称为特殊方法或双下划线方法，是以双下划线开头和结尾的方法。这些方法有特殊的意义，并且通常在某种特定的操作发生时由Python自动调用。</p><h4 id="常见的魔术方法"><a href="#常见的魔术方法" class="headerlink" title="常见的魔术方法"></a>常见的魔术方法</h4><ul><li><code>__init__</code>: 构造方法，用于初始化新创建对象的状态。</li><li><code>__str__</code>: 返回对象的字符串表示形式，当我们尝试打印对象或使用<code>str()</code>转换对象时调用。</li><li><code>__lt__</code>: 定义小于（&lt;）操作符的行为。</li><li><code>__le__</code>: 定义小于等于（&lt;=）操作符的行为。</li><li><code>__eq__</code>: 定义等于（==）操作符的行为。</li></ul><h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>下面是一个扩展的<code>Student</code>类，包含了<code>__str__</code>，<code>__lt__</code>，<code>__le__</code>和<code>__eq__</code>魔术方法的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=<span class="subst">&#123;self.name&#125;</span>, age=<span class="subst">&#123;self.age&#125;</span>, tel=<span class="subst">&#123;self.tel&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.name == other.name <span class="keyword">and</span> self.age == other.age <span class="keyword">and</span> self.tel == other.tel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Student对象</span></span><br><span class="line">stu1 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>, <span class="string">&quot;1234567890&quot;</span>)</span><br><span class="line">stu3 = Student(<span class="string">&quot;张三&quot;</span>, <span class="number">31</span>, <span class="string">&quot;1145141919810&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用魔术方法</span></span><br><span class="line"><span class="built_in">print</span>(stu1)  <span class="comment"># 调用 __str__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt; stu2)  <span class="comment"># 调用 __lt__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &lt;= stu2)  <span class="comment"># 调用 __le__</span></span><br><span class="line"><span class="built_in">print</span>(stu1 == stu3)  <span class="comment"># 调用 __eq__</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student(name=张三, age=31, tel=1145141919810)</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>注意，在实现比较魔术方法时，我们通常首先检查比较的对象是否也是相同类的实例。如果不是，我们可能会抛出一个<code>TypeError</code>异常或者简单地返回<code>False</code>（对于<code>__eq__</code>方法）。在实现<code>__lt__</code>和<code>__le__</code>方法时，我们只比较了学生的年龄属性，但根据实际需要，可以比较更多的属性或应用更复杂的逻辑。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在Python中，继承是面向对象编程的一个重要概念，允许我们创建一个类（称为子类或派生类）来继承另一个类（称为父类或基类）的属性和方法。这样，子类可以重用父类的代码，同时还可以添加或覆盖父类的功能。</p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>单继承是指一个子类只继承一个父类的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student类对象, name = <span class="subst">&#123;self.name&#125;</span>, age = <span class="subst">&#123;self.age&#125;</span>, tel = <span class="subst">&#123;self.tel&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Comparison is only implemented for instances of &#x27;Student&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.age &lt;= other.age</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dalao</span>(<span class="title class_ inherited__">Student</span>):  <span class="comment"># Dalao类继承自Student类</span></span><br><span class="line">    GPA = <span class="number">5.0</span>  <span class="comment"># Dalao类新增了一个类属性GPA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Dalao类的实例</span></span><br><span class="line">d1 = Dalao(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>, <span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d1.GPA)  <span class="comment"># 输出Dalao类的GPA属性值</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.0</span><br></pre></td></tr></table></figure></p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承是指一个子类可以继承多个父类的属性和方法。在Python中，可以通过在类定义时，在括号内列出多个父类来实现多继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A method1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B method2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):  <span class="comment"># C类继承自A类和B类</span></span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># C类没有新增属性和方法，直接继承A和B的属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个C类的实例</span></span><br><span class="line">c1 = C()</span><br><span class="line">c1.method1()  <span class="comment"># 调用继承自A类的方法</span></span><br><span class="line">c1.method2()  <span class="comment"># 调用继承自B类的方法</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A method1</span><br><span class="line">B method2</span><br></pre></td></tr></table></figure></p><p>需要注意的是，多继承可能会引起方法解析顺序（MRO）的问题，Python中使用C3线性化算法来确定方法解析顺序。可以使用<code>类名.mro()</code>或<code>类名.__mro__</code>来查看类的MRO列表。</p><h2 id="复写和调用父类成员"><a href="#复写和调用父类成员" class="headerlink" title="复写和调用父类成员"></a>复写和调用父类成员</h2><p>子类可以复写父类的成员属性和成员方法，即重新定义同名的属性或方法。<strong>当子类对象调用成员时，会调用复写后的新成员。</strong>如果需要使用被复写的父类成员，可以使用特殊的调用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, major</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 调用父类的构造函数初始化name和age属性</span></span><br><span class="line">        self.major = major  <span class="comment"># 新增major属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):  <span class="comment"># 复写父类的introduce方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;我是研究生<span class="subst">&#123;self.name&#125;</span>，今年<span class="subst">&#123;self.age&#125;</span>岁，我的专业是<span class="subst">&#123;self.major&#125;</span>。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个GraduateStudent类的实例并调用introduce方法</span></span><br><span class="line">gs = GraduateStudent(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>, <span class="string">&quot;计算机科学&quot;</span>)</span><br><span class="line">gs.introduce()  <span class="comment"># 调用复写后的新方法输出信息包含专业</span></span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是研究生张三，今年25岁，我的专业是计算机科学。</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，<code>GraduateStudent</code>类复写了<code>Student</code>类的<code>introduce</code>方法，并在其中添加了专业信息。同时，在<code>GraduateStudent</code>类的构造函数中，我们使用<code>super().__init__(name, age)</code>来调用父类的构造函数初始化继承的属性。这样，我们就可以在子类中添加新的属性或方法，同时保留父类的功能。</p><h3 id="访问父类成员"><a href="#访问父类成员" class="headerlink" title="访问父类成员"></a>访问父类成员</h3><h4 id="直接通过父类名调用"><a href="#直接通过父类名调用" class="headerlink" title="直接通过父类名调用"></a>直接通过父类名调用</h4><p>如果要直接通过父类名来调用其成员方法或访问成员变量，可以使用以下语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类名.成员方法(self, 其他参数)</span><br><span class="line">父类名.成员变量</span><br></pre></td></tr></table></figure><p>这里需要注意的是，当直接调用父类的成员方法时，需要显式地将当前对象作为第一个参数传递（通常是<code>self</code>）。</p><blockquote><p>可以对实例化后的对象是用</p></blockquote><h4 id="使用super-调用"><a href="#使用super-调用" class="headerlink" title="使用super()调用"></a>使用<code>super()</code>调用</h4><p><code>super()</code>函数提供了一种动态的方式来访问父类的方法或属性，而不需要显式地引用父类的名字。这在多重继承的场景中特别有用，因为它可以确保正确地调用方法解析顺序（MRO）中的下一个类。</p><p>使用<code>super()</code>调用父类成员的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>().成员方法(其他参数)</span><br><span class="line"><span class="built_in">super</span>().成员变量</span><br></pre></td></tr></table></figure><p>注意，在使用<code>super()</code>时，不需要显式地传递<code>self</code>参数，因为<code>super()</code>会自动处理。</p><blockquote><p>在类定义的时候才可以使用</p></blockquote><h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><p>多态是面向对象编程的三大特性之一，它允许我们使用父类引用来指向子类对象，并且可以调用在子类中重写的方法。<strong>在Python中，多态的实现主要依赖于鸭子类型（duck typing）的概念，即不关注对象的实际类型</strong>，而是关注对象是否具有所需的方法。</p><p>下面我们通过一段代码来演示多态的概念：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:  <span class="comment"># 定义一个Animal类作为父类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 父类中的speak方法为空实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Dog类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪&quot;</span>)  <span class="comment"># Dog类中重写speak方法，输出“汪汪汪”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment"># Cat类继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)  <span class="comment"># Cat类中重写speak方法，输出“喵喵喵”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span>:  <span class="comment"># 定义一个Robot类，它没有继承自Animal类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;滋滋滋&quot;</span>)  <span class="comment"># Robot类中有一个speak方法，输出“滋滋滋”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_noise</span>(<span class="params">obj</span>):  <span class="comment"># 定义一个函数，接受一个对象作为参数</span></span><br><span class="line">    obj.speak()  <span class="comment"># 调用对象的speak方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象并调用make_noise函数</span></span><br><span class="line">a = Animal()  <span class="comment"># 创建Animal对象，但注意Animal类的speak方法为空实现，调用时不会有输出</span></span><br><span class="line">b = Dog()  <span class="comment"># 创建Dog对象</span></span><br><span class="line">c = Cat()  <span class="comment"># 创建Cat对象</span></span><br><span class="line">d = Robot()  <span class="comment"># 创建Robot对象，虽然它没有继承自Animal类，但它有一个speak方法，所以可以在make_noise函数中使用</span></span><br><span class="line"></span><br><span class="line">make_noise(b)  <span class="comment"># 输出“汪汪汪”</span></span><br><span class="line">make_noise(c)  <span class="comment"># 输出“喵喵喵”</span></span><br><span class="line"><span class="comment"># make_noise(a)  # 这行代码如果取消注释会运行但没有输出，因为Animal类的speak方法为空实现</span></span><br><span class="line">make_noise(d)  <span class="comment"># 输出“滋滋滋”，虽然Robot类没有继承自Animal类，但由于它有一个speak方法，所以可以在make_noise函数中使用，这体现了鸭子类型的思想</span></span><br></pre></td></tr></table></figure><p>注意：在上述代码中，我们实际上并没有使用到<code>a = Animal()</code>这个对象，因为<code>Animal</code>类的<code>speak</code>方法是一个空实现。如果我们尝试调用<code>make_noise(a)</code>，它不会产生任何输出。在实际的多态示例中，我们通常会避免创建这样的空实现的父类对象。此外，虽然<code>Robot</code>类没有继承自<code>Animal</code>类，但由于它有一个与<code>Animal</code>类中同名的<code>speak</code>方法，我们仍然可以将其对象传递给<code>make_noise</code>函数并调用其<code>speak</code>方法。<strong>这就是鸭子类型的核心思想：不关注对象的实际类型，只关注对象是否具有所需的方法。</strong>然而，在严格的面向对象设计中，为了让代码更加清晰和可维护，我们通常会建议将具有相同行为（即具有相同方法）的类组织到一个继承体系中，并通过父类引用来操作子类对象。这样可以确保我们的代码更加符合面向对象的设计原则。在上述示例中，我们可以将<code>Robot</code>类也设计为继承自<code>Animal</code>类（如果逻辑上合理的话），这样就可以更加清晰地展示多态的特性。但是需要注意的是，并不是所有的具有相同方法的类都应该被组织到一个继承体系中。在实际开发中，我们需要根据具体的业务逻辑和设计需求来决定如何组织我们的类和对象。另外需要注意的是，Python中的多态与一些其他语言（如Java）中的多态略有不同。在Python中，由于动态类型和鸭子类型的特性，我们可以在不显式地声明接口或继承体系的情况下实现多态。这使得Python的代码更加灵活和简洁。但是在享受这种灵活性的同时，我们也需要注意保持代码的清晰性和可维护性。</p><h1 id="变量的类型注解"><a href="#变量的类型注解" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h1><p>在Python 3.5及以后的版本中，引入了类型注解（Type Annotations）的功能。类型注解允许开发者在代码中显式地标注变量、函数参数以及返回值的数据类型。这些注解主要用于帮助开发者编写更加清晰、易于理解的代码，并且为静态类型检查工具、集成开发环境（IDE）等第三方工具提供更好的支持。</p><h2 id="类型注解的作用"><a href="#类型注解的作用" class="headerlink" title="类型注解的作用"></a>类型注解的作用</h2><ol><li><strong>代码提示</strong>：类型注解可以帮助IDE等开发工具提供更为准确的代码提示和自动补全功能。</li><li><strong>静态类型检查</strong>：配合静态类型检查工具，可以在代码运行前发现潜在的类型错误。</li><li><strong>文档化</strong>：类型注解也可以作为一种文档形式，帮助其他开发者理解代码中的数据类型。</li></ol><h2 id="变量的类型注解-1"><a href="#变量的类型注解-1" class="headerlink" title="变量的类型注解"></a>变量的类型注解</h2><p>变量的类型注解是在变量名后面加上冒号（<code>:</code>）和类型名。需<strong>要注意的是，类型注解仅仅是注释，它不会改变Python的动态类型特性。</strong>也就是说，即使你标注了一个变量为整数类型，Python仍然允许你为这个变量赋值为其他类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量类型注解示例</span></span><br><span class="line">my_var: <span class="built_in">int</span> = <span class="number">42</span>  <span class="comment"># 标注my_var为整数类型</span></span><br></pre></td></tr></table></figure><p>然而，以下代码虽然类型注解为<code>int</code>，但实际上赋值为字符串类型，Python不会报错，但在静态类型检查时会警告类型不匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var: <span class="built_in">int</span> = <span class="string">&quot;itheima&quot;</span>  <span class="comment"># 类型注解为int，但实际赋值为str，这不会引发运行时错误</span></span><br><span class="line"><span class="built_in">print</span>(var)  <span class="comment"># 输出：itheima</span></span><br></pre></td></tr></table></figure><h2 id="函数的类型注解"><a href="#函数的类型注解" class="headerlink" title="函数的类型注解"></a>函数的类型注解</h2><p>函数的类型注解包括函数参数的类型注解和返回值类型的注解。参数的类型注解写在参数名后面，返回值类型的注解写在函数声明后面的箭头（<code>-&gt;</code>）后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数类型注解示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>greet</code>函数的参数<code>name</code>被注解为字符串类型，返回值也被注解为字符串类型。</p><h2 id="Union用法"><a href="#Union用法" class="headerlink" title="Union用法"></a>Union用法</h2><p>当变量或函数参数可以是多种类型之一时，可以使用<code>Union</code>来指定这些类型。<code>Union</code>是从<code>typing</code>模块中导入的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：变量可以是str或int类型  </span></span><br><span class="line">my_var: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = <span class="string">&quot;Hello&quot;</span>  <span class="comment"># my_var可以是str类型  </span></span><br><span class="line">my_var = <span class="number">42</span>  <span class="comment"># my_var也可以是int类型，这不会引发运行时错误  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Union用法示例：列表中的元素可以是str或int类型  </span></span><br><span class="line">my_list: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;itheima&quot;</span>, <span class="string">&quot;itcast&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>my_var</code>被注解为可以是字符串或整数类型，而<code>my_list</code>被注解为一个列表，其中的元素可以是字符串或整数类型。这样，在静态类型检查时，如果这些变量被赋予了不符合注解类型的值，工具就会发出警告。然而，在运行时，Python本身不会因为这些类型注解而引发错误。</p>]]></content>
      
      
      <categories>
          
          <category> 学海泛舟 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch笔记</title>
      <link href="/post/969045566.html"/>
      <url>/post/969045566.html</url>
      
        <content type="html"><![CDATA[<h1 id="调用帮助文档"><a href="#调用帮助文档" class="headerlink" title="调用帮助文档"></a>调用帮助文档</h1><p>在Python中，<code>help()</code>和<code>dir()</code>是两个内置函数，它们提供了对Python对象（如模块、类、方法、函数、变量等）的有用信息。</p><ul><li><p><code>help()</code>函数用于获取有关Python对象的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">print</span>) <span class="comment">#这将显示有关print()函数的详细信息，包括它的用途、参数、返回值等。</span></span><br></pre></td></tr></table></figure></li><li><p><code>dir()</code>函数用于列出Python对象的所有属性和方法。</p><p>获取内置<code>math</code>模块的所有属性和方法：</p></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(math))</span><br></pre></td></tr></table></figure><p>  这将显示<code>math</code>模块中定义的所有函数、变量和常量的名称。</p><p>  也可以在不传递任何参数的情况下调用<code>dir()</code>函数，这将返回一个包含当前作用域中所有名称的列表。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>())</span><br></pre></td></tr></table></figure><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><h2 id="必要的库"><a href="#必要的库" class="headerlink" title="必要的库"></a>必要的库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="读取和显示图像"><a href="#读取和显示图像" class="headerlink" title="读取和显示图像"></a>读取和显示图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(img_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">img.show()  <span class="comment"># 显示图像文件（注意：这可能会打开多个图像查看器窗口）</span></span><br></pre></td></tr></table></figure><p>用<code>PIL</code>中的<code>Image</code>可以通过图像路径来打开某个图像并显示图像文件。</p><h2 id="处理图像"><a href="#处理图像" class="headerlink" title="处理图像"></a>处理图像</h2><h3 id="将PIL图像转换为numpy数组"><a href="#将PIL图像转换为numpy数组" class="headerlink" title="将PIL图像转换为numpy数组"></a>将PIL图像转换为numpy数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image_path = <span class="string">&quot;data/train/ants_image/0013035.jpg&quot;</span>  </span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)  </span><br><span class="line">img_array = np.array(img_PIL)</span><br></pre></td></tr></table></figure><h1 id="TensorBoard可视化"><a href="#TensorBoard可视化" class="headerlink" title="TensorBoard可视化"></a>TensorBoard可视化</h1><p>使用PyTorch进行深度学习实验时，我们经常需要跟踪和可视化训练过程中的各种指标，如损失、准确率等。TensorBoard是一个强大的可视化工具，可以帮助我们实现这一目标。在PyTorch中，我们可以通过<code>SummaryWriter</code>类轻松地将数据写入TensorBoard可以读取的日志文件。</p><blockquote><p>其就相当于一个日志</p></blockquote><h2 id="创建并启动TensorBoard"><a href="#创建并启动TensorBoard" class="headerlink" title="创建并启动TensorBoard"></a>创建并启动TensorBoard</h2><ol><li><p>从<code>torch.utils.tensorboard</code>导入<code>SummaryWriter</code>。</p></li><li><p>创建一个<code>SummaryWriter</code>对象，并指定一个日志目录，例如”logs”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动TensorBoard：</p><p>要在命令行中启动TensorBoard并加载我们的日志，请使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure><p>这将在本地启动一个TensorBoard服务器，并在默认浏览器中打开TensorBoard的Web界面。</p></li></ol><h2 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h2><h3 id="添加标量数据"><a href="#添加标量数据" class="headerlink" title="添加标量数据"></a>添加标量数据</h3><p>可以使用<code>add_scalar</code>方法将标量数据写入日志文件。这个方法接受三个参数：标签（用于在TensorBoard中标识数据），标量值，以及全局步骤值（通常用于表示训练的迭代次数或时间步）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)  </span><br><span class="line"></span><br><span class="line">writer.close()  <span class="comment"># 记得关闭</span></span><br></pre></td></tr></table></figure><h3 id="添加图像"><a href="#添加图像" class="headerlink" title="添加图像"></a>添加图像</h3><p>使用<code>SummaryWriter</code>的<code>add_image</code>方法将图像添加到TensorBoard中。需要注意的是，<code>add_image</code>方法要求图像数据的格式与指定的<code>dataformats</code>参数相匹配。在这里，我们指定为<code>&#39;HWC&#39;</code>，即高度、宽度和通道数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  </span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, img_array, global_step=<span class="number">0</span>, dataformats=<span class="string">&#x27;HWC&#x27;</span>)<span class="comment">#默认是&#x27;CHW&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Pytorch基础"><a href="#Pytorch基础" class="headerlink" title="Pytorch基础"></a>Pytorch基础</h1><h2 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量(Tensors)"></a>张量(Tensors)</h2><h3 id="创建Tensors变量"><a href="#创建Tensors变量" class="headerlink" title="创建Tensors变量"></a>创建Tensors变量</h3><p>有多种创建Tensors变量的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建未初始化的矩阵</span></span><br><span class="line">x = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#随机初始化一个矩阵</span></span><br><span class="line">rand_x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#创建数值皆为 0 的矩阵（类型为 long 的矩阵）</span></span><br><span class="line">zero_x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line"><span class="comment">#创建数值都是 1 的矩阵</span></span><br><span class="line">one_x = torch.ones(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">#直接传递 tensor 数值来创建</span></span><br><span class="line">tensor = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>还可以用<code>tensor.new_ones()</code>和<code>torch.randn_like()</code>从一个<code>tensor</code>变量创建另一个<code>tensor</code>变量。</p><h3 id="处理Tensors变量"><a href="#处理Tensors变量" class="headerlink" title="处理Tensors变量"></a>处理Tensors变量</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>加法有几种实现方式：</p><ul><li><code>+</code> 运算符</li><li><code>torch.add(tensor1, tensor2, [out=tensor3])</code></li><li><code>tensor1.add_(tensor2)</code>：直接修改 tensor 变量</li></ul><blockquote><p>可以改变 tensor 变量的操作都带有一个后缀 <code>_</code>, 例如 <code>x.copy_(y), x.t_()</code> 都可以改变 x 变量</p></blockquote><h4 id="访问tensor数据"><a href="#访问tensor数据" class="headerlink" title="访问tensor数据"></a>访问tensor数据</h4><p>可以使用索引来访问某一维的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问 tensor 第一列数据</span></span><br><span class="line"><span class="built_in">print</span>(tensor[:, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><h4 id="修改维度"><a href="#修改维度" class="headerlink" title="修改维度"></a>修改维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对 Tensor 的尺寸修改，可以采用 torch.view()</span></span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># -1 表示除给定维度外的其余维度的乘积</span></span><br><span class="line">z = x.view(-<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.Size([<span class="number">4</span>, <span class="number">4</span>]) torch.Size([<span class="number">16</span>]) torch.Size([<span class="number">2</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><h3 id="转换为其他数据类型"><a href="#转换为其他数据类型" class="headerlink" title="转换为其他数据类型"></a>转换为其他数据类型</h3><h4 id="转换为Numpy数组"><a href="#转换为Numpy数组" class="headerlink" title="转换为Numpy数组"></a>转换为Numpy数组</h4><p>调用 <code>tensor.numpy()</code> 可以实现这个转换操作。<strong>两者是共享同个内存空间的</strong>,修改 <code>tensor</code> 变量 <code>a</code>，Numpy 数组变量 <code>b</code>也会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br></pre></td></tr></table></figure><h4 id="Numpy-数组转换为-Tensor"><a href="#Numpy-数组转换为-Tensor" class="headerlink" title="Numpy 数组转换为 Tensor"></a>Numpy 数组转换为 Tensor</h4><p>转换的操作是调用 <code>torch.from_numpy(numpy_array)</code> 方法.\</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br></pre></td></tr></table></figure><h2 id="定义自定义数据集类"><a href="#定义自定义数据集类" class="headerlink" title="定义自定义数据集类"></a>定义自定义数据集类</h2><h3 id="创建自定义数据集类"><a href="#创建自定义数据集类" class="headerlink" title="创建自定义数据集类"></a>创建自定义数据集类</h3><p>要创建一个自定义的数据集类，我们首先需要导入必要的库，并继承<code>Dataset</code>类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化函数，接收根目录和标签目录作为参数。</span></span><br><span class="line"><span class="string">        :param root_dir: 根目录路径，包含所有标签的文件夹。</span></span><br><span class="line"><span class="string">        :param label_dir: 标签目录名称，即根目录下的子文件夹名，代表某一类别。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        <span class="comment"># 拼接得到完整的目录路径</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        <span class="comment"># 列出目录中的所有文件，注意这里没有进行文件类型过滤</span></span><br><span class="line">        self.img_path_list = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据索引获取单个样本（图像和标签）。</span></span><br><span class="line"><span class="string">        :param idx: 样本索引。</span></span><br><span class="line"><span class="string">        :return: 返回图像和标签。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_name = self.img_path_list[idx]</span><br><span class="line">        <span class="comment"># 拼接得到完整的图像文件路径</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        <span class="comment"># 使用PIL库打开图像文件</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        <span class="comment"># 这里简单地将标签设置为标签目录的名称</span></span><br><span class="line">        <span class="comment"># 在实际应用中，标签可能需要更复杂的处理，比如转换为数字、one-hot编码等</span></span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回数据集中的样本数量（图像数量）。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path_list)</span><br></pre></td></tr></table></figure><h3 id="使用自定义数据集类"><a href="#使用自定义数据集类" class="headerlink" title="使用自定义数据集类"></a>使用自定义数据集类</h3><p>创建了自定义的数据集类之后，就可以将其传递给PyTorch的数据加载器（<code>DataLoader</code>）来使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化自定义数据集类</span></span><br><span class="line">dataset = MyData(root_dir=<span class="string">&quot;path/to/root&quot;</span>, label_dir=<span class="string">&quot;label_a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集（这里仅为示例，实际使用时需要设置batch_size等参数）</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练循环中迭代dataloader获取数据和标签</span></span><br><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> dataloader:</span><br><span class="line">    <span class="comment"># 训练代码...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="DataLoader的使用"><a href="#DataLoader的使用" class="headerlink" title="DataLoader的使用"></a>DataLoader的使用</h2><p>需要导入必要的库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>加载数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li><p>dataset：</p><ul><li><strong>参数类型</strong>: <code>Dataset</code></li><li><strong>作用</strong>: 指定<code>DataLoader</code>需要加载的数据集。数据集必须实现<code>Dataset</code>接口，这样才能被<code>DataLoader</code>识别和加载。</li></ul></li><li><p>batch_size</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>1</code></p></li><li><p><strong>作用</strong>: 指定每个批次的样本数量。批次大小会影响到模型的收敛速度和更新频率。</p></li></ul></li><li><p>shuffle</p><ul><li><p><strong>参数类型</strong>: <code>bool</code></p></li><li><p><strong>默认值</strong>: <code>False</code></p></li><li><p><strong>作用</strong>: 如果设置为<code>True</code>，则每个epoch开始时，<code>DataLoader</code>会随机打乱数据集中的样本顺序。</p></li></ul></li><li><p>num_workers</p><ul><li><p><strong>参数类型</strong>: <code>int</code></p></li><li><p><strong>默认值</strong>: <code>0</code></p></li><li><p><strong>作用</strong>: 指定有多少个子进程用于加载数据。<code>0</code>表示数据将在主进程中加载（不使用子进程）。增加<code>num_workers</code>可以提高数据加载的效率，特别是在数据预处理较为复杂或者数据存储在慢速存储介质上时。</p></li></ul></li><li><p>drop_last</p><ul><li><strong>参数类型</strong>: <code>bool</code></li><li><strong>默认值</strong>: <code>False</code></li><li><strong>作用</strong>: 当样本数量不能被批次大小整除时，如果<code>drop_last</code>设置为<code>True</code>，则<code>DataLoader</code>会丢弃最后一个不完整的批次。</li></ul></li></ol><h2 id="Torchvision-Transforms"><a href="#Torchvision-Transforms" class="headerlink" title="Torchvision Transforms"></a>Torchvision Transforms</h2><h3 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br></pre></td></tr></table></figure><h3 id="常用的Transforms操作"><a href="#常用的Transforms操作" class="headerlink" title="常用的Transforms操作"></a>常用的Transforms操作</h3><h4 id="PIL图像转换为Tensor"><a href="#PIL图像转换为Tensor" class="headerlink" title="PIL图像转换为Tensor"></a>PIL图像转换为Tensor</h4><p><code>torchvision.transforms</code>库中的<code>ToTensor()</code>函数可以将PIL图像或NumPy ndarray转换为FloatTensor，并且<strong>会将图像的像素值范围从0-255缩放到0-1</strong>。这对于神经网络来说是一个常见的预处理步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br></pre></td></tr></table></figure><p>使用<code>SummaryWriter</code>的<code>add_image()</code>方法将Tensor图像添加到TensorBoard中。这样，我们就可以在TensorBoard中查看和处理这个图像了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.add_image(<span class="string">&quot;Tensor_img&quot;</span>, tensor_img)</span><br></pre></td></tr></table></figure><h4 id="归一化操作"><a href="#归一化操作" class="headerlink" title="归一化操作"></a>归一化操作</h4><p>下面是一个示例代码，展示了如何使用PyTorch的transforms模块进行图像归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Totensor</span></span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">img_tensor = trans_totensor(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize - 注意这里的参数可能不适用于所有图像，应根据实际情况进行调整</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])  <span class="comment"># 假设图像范围为[0, 1]，则均值和标准差都设为0.5进行归一化</span></span><br><span class="line">img_norm = trans_norm(img_tensor)</span><br></pre></td></tr></table></figure><h4 id="图像调整大小"><a href="#图像调整大小" class="headerlink" title="图像调整大小"></a>图像调整大小</h4><p>在调整大小之前，可以通过 <code>img.size</code> 属性获取原始图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 输出原始图像的宽度和高度，例如：(width, height)</span></span><br></pre></td></tr></table></figure><p>创建一个 <code>transforms.Resize</code> 对象，指定新的图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))  <span class="comment"># 调整图像到 512x512 像素大小</span></span><br></pre></td></tr></table></figure><p>使用创建的 <code>trans_resize</code> 转换器来调整图像大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_resize = trans_resize(img)  <span class="comment"># img_resize 是调整大小后的 PIL 图像</span></span><br></pre></td></tr></table></figure><h3 id="使用Compose组合多个操作"><a href="#使用Compose组合多个操作" class="headerlink" title="使用Compose组合多个操作"></a>使用Compose组合多个操作</h3><p>在实际应用中，我们通常需要按顺序执行多个图像预处理操作。这时，可以使用<code>transforms.Compose</code>来组合这些操作，从而创建一个可重复使用的预处理流程。以下是一个示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;test04&quot;</span>)</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义预处理流程：先调整大小，然后转换为张量，并进行归一化（这里省略了归一化步骤以简化示例）</span></span><br><span class="line">preprocessing = transforms.Compose([</span><br><span class="line">    transforms.Resize([<span class="number">300</span>, <span class="number">500</span>]),  <span class="comment"># 调整图像大小（注意保持纵横比或适当填充以避免失真）</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将PIL图像转换为PyTorch张量（值范围在[0, 255]内）</span></span><br><span class="line">    <span class="comment"># 添加归一化等其他操作（如果需要的话）...</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用预处理流程并保存结果到TensorBoard日志中（实际应用中可能需要进一步处理或添加标签等）</span></span><br><span class="line">img_preprocessed = preprocessing(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Preprocessed Image&quot;</span>, img_preprocessed, <span class="number">0</span>)  <span class="comment"># 使用全局步数0，实际应用中应根据需要动态设置（例如训练迭代次数等）</span></span><br></pre></td></tr></table></figure><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>Pytorch中也提供了许多的损失函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L1损失函数</span></span><br><span class="line">loss = L1Loss(reduction=<span class="string">&#x27;sum&#x27;</span>)  </span><br><span class="line">result = loss(inputs, targets)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># MSE损失函数</span></span><br><span class="line">loss_mse = nn.MSELoss()  </span><br><span class="line">result_mse = loss_mse(inputs, targets)  </span><br></pre></td></tr></table></figure><h2 id="计算正确率"><a href="#计算正确率" class="headerlink" title="计算正确率"></a>计算正确率</h2><p><code>output=model(input)</code>得到的是浮点数矩阵，如果想要知道类别，则可以用<code>.argmax()</code>函数得到输出的类别，然后用<code>predict==targets</code>得到布尔矩阵。最后对矩阵<code>torch.sum()</code>得到正确个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line">outputs = torch.tensor([[<span class="number">0.1</span>, <span class="number">0.2</span>], [<span class="number">0.3</span>, <span class="number">0.4</span>]])  </span><br><span class="line"><span class="comment">#.argmax(1)是对每一行求最大值的位置，.argmax(0)是对每一列</span></span><br><span class="line"><span class="built_in">print</span>(outputs.argmax(<span class="number">1</span>))  </span><br><span class="line">preds = outputs.argmax(<span class="number">1</span>)  </span><br><span class="line">targets = torch.tensor([<span class="number">0</span>, <span class="number">1</span>])  </span><br><span class="line"><span class="built_in">print</span>(preds == targets)  </span><br></pre></td></tr></table></figure><h1 id="PyTorch卷积"><a href="#PyTorch卷积" class="headerlink" title="PyTorch卷积"></a>PyTorch卷积</h1><h2 id="PyTorch中torch-nn模块的使用"><a href="#PyTorch中torch-nn模块的使用" class="headerlink" title="PyTorch中torch.nn模块的使用"></a>PyTorch中torch.nn模块的使用</h2><p>在PyTorch中，<code>torch.nn</code>模块提供了构建神经网络所需的所有构建块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个模型类<code>Model</code>，它继承自<code>nn.Module</code>。在构造函数<code>__init__</code>中，我们初始化两个卷积层<code>conv1</code>和<code>conv2</code>。<code>nn.Conv2d</code>是二维卷积层，它接收的参数包括输入和输出通道数、卷积核大小等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__() <span class="comment"># 记得初始化父类</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)  <span class="comment"># 输入通道1，输出通道20，卷积核大小5</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>) <span class="comment"># 输入通道20，输出通道20，卷积核大小5</span></span><br></pre></td></tr></table></figure><br>在<code>forward</code>方法中，我们定义了数据通过网络的方式。这里使用了<code>F.relu</code>作为激活函数，对每个卷积层的输出应用ReLU激活。 </p><blockquote><p>其它的一些层可以在<a href="https://pytorch.org/docs/stable/nn.functional.html">官方文档</a>中找到</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    x = F.relu(self.conv1(x))  <span class="comment"># 第一个卷积层后接ReLU激活</span></span><br><span class="line">    <span class="keyword">return</span> F.relu(self.conv2(x))  <span class="comment"># 第二个卷积层后接ReLU激活</span></span><br></pre></td></tr></table></figure><p>这样，我们就定义了一个简单的卷积神经网络模型。在实际使用时，我们会创建这个模型类的实例，然后传入数据来进行训练和测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment"># 假设我们有一些输入数据x（例如，图像数据），形状为(N, 1, 28, 28)</span></span><br><span class="line"><span class="comment"># N是批量大小，1是通道数，28x28是图像尺寸</span></span><br><span class="line">x = torch.randn(<span class="number">64</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)  <span class="comment"># 随机生成一些输入数据</span></span><br><span class="line"><span class="comment"># 通过模型前向传播数据</span></span><br><span class="line">output = model(x)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><br>以上就是使用<code>torch.nn</code>模块构建和运行一个简单卷积神经网络的基本步骤。在实际应用中，模型通常会包含更多的层和更复杂的结构，但基本原理是相同的。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><h4 id="定义优化器"><a href="#定义优化器" class="headerlink" title="定义优化器"></a>定义优化器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>)  </span><br><span class="line">optimizer = optim.Adam([var1, var2], lr=<span class="number">0.0001</span>)</span><br></pre></td></tr></table></figure><p>主要要定义的有两个：</p><ol><li>模型参数：给定模型参数优化器才知道更新哪些内容</li><li>学习速率<code>lr</code></li></ol><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>训练过程写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">input</span>, target <span class="keyword">in</span> dataset:  </span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">    output = model(<span class="built_in">input</span>)  <span class="comment"># 前向传播</span></span><br><span class="line">    loss = loss_fn(output, target)  <span class="comment">#损失</span></span><br><span class="line">    loss.backward()  <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>与自己的模型综合起来，效果大概是这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss()  </span><br><span class="line">model = Model()  </span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  </span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:  </span><br><span class="line">    imgs, targets = data  </span><br><span class="line">    outputs = model (imgs)  </span><br><span class="line">    result_loss = loss(outputs, targets)  </span><br><span class="line">    optim.zero_grad()  </span><br><span class="line">    result_loss.backward()  </span><br><span class="line">    optim.step()</span><br></pre></td></tr></table></figure><h3 id="利用Sequential简化模块"><a href="#利用Sequential简化模块" class="headerlink" title="利用Sequential简化模块"></a>利用<code>Sequential</code>简化模块</h3><p><code>Sequential</code>也在<code>torch.nn</code>模块中，利用其，可以避免在前向传播的过程中手写每层的输入输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="可视化模块"><a href="#可视化模块" class="headerlink" title="可视化模块"></a>可视化模块</h3><ol><li>可以用<code>print(Model)</code>将模型显示在控制台</li><li>用<code>SummaryWriter</code>的<code>add_graph(Model,input)</code>在TensorBorad中显示</li></ol><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line"><span class="comment">#方式一，保存整个模型</span></span><br><span class="line">torch.save(vgg16, <span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二，只保存参数</span></span><br><span class="line">torch.save(vgg16.state_dict(), <span class="string">&quot;vgg16_method2.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line"><span class="comment">#方式一对应的加载模式</span></span><br><span class="line">model = torch.load(<span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="comment">#方式二对应的加载模式</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&quot;vgg16_method2.pth&quot;</span>))</span><br></pre></td></tr></table></figure><p>加载自身的模型的时候需要给出类的定义。</p><h2 id="PyTorch-2D卷积"><a href="#PyTorch-2D卷积" class="headerlink" title="PyTorch 2D卷积"></a>PyTorch 2D卷积</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><h3 id="1-创建输入张量和卷积核"><a href="#1-创建输入张量和卷积核" class="headerlink" title="1. 创建输入张量和卷积核"></a>1. 创建输入张量和卷积核</h3><p>输入张量（<code>input</code>）和卷积核（<code>kernel</code>）被定义为多维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line">kernel = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="2-调整张量的形状"><a href="#2-调整张量的形状" class="headerlink" title="2. 调整张量的形状"></a>2. 调整张量的形状</h3><p>为了进行二维卷积操作，我们需要将输入张量和卷积核的形状调整为四维张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">kernel = torch.reshape(kernel, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><br>在PyTorch中，使用<code>torch.nn.functional.conv2d</code>函数进行卷积操作时，输入和卷积核需要是四维张量。这四个维度分别是：</p><ol><li><strong>批量大小（Batch size）</strong>：表示输入数据的数量。</li><li><strong>通道数（Channels）</strong>：对于彩色图像，通常是3（红、绿、蓝）。</li><li><strong>高度（Height）</strong>：图像的高度。</li><li><strong>宽度（Width）</strong>：图像的宽度。</li></ol><p><code>input = torch.reshape(input, (1, 1, 5, 5))</code>和<code>kernel = torch.reshape(kernel, (1, 1, 3, 3))</code>这两行代码的作用是将输入和卷积核的形状从二维扩展到四维，以满足<code>conv2d</code>函数的要求。</p><h3 id="3-进行卷积操作"><a href="#3-进行卷积操作" class="headerlink" title="3.进行卷积操作"></a>3.进行卷积操作</h3><p>使用<code>F.conv2d</code>函数进行卷积操作，并设置步长（<code>stride</code>）为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在卷积操作中，<code>stride</code>（步幅）是一个非常重要的参数，它定义了卷积核在输入张量上移动时的步长。</p><p>还可以设置<code>padding</code>参数：<code>padding</code>参数定义了在卷积操作之前，输入数据周围是否要添加额外的边界（通常为0）。</p><h2 id="最大池化层"><a href="#最大池化层" class="headerlink" title="最大池化层"></a>最大池化层</h2><p>最大池化与卷积的区别是，卷积是对窗口中的数对应相乘后求和，最大池化是求窗口中的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个最大池化层，池化窗口大小为2x2，步长为2</span></span><br><span class="line">max_pool = nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其的主要参数为：</p><ol><li><code>kernel_size</code>：表示池化窗口的大小。对于二维最大池化，它可以是单个整数或两个整数的元组（height, width）。如果是一个整数，则池化窗口将是一个正方形。</li><li><code>stride</code>：这是一个元组或整数，表示池化窗口在输入张量上移动的步长。<strong>默认情况下，<code>stride</code>与<code>kernel_size</code>相同。</strong></li><li><code>padding</code>：这是一个元组或整数，表示在输入张量的每个边上添加的填充数量。默认情况下，没有填充（<code>padding=0</code>）。</li></ol><h1 id="完整的训练过程"><a href="#完整的训练过程" class="headerlink" title="完整的训练过程"></a>完整的训练过程</h1><ol><li><p>准备数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">True</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_data = datasets.CIFAR10(root=<span class="string">&quot;/data&quot;</span>, train=<span class="literal">False</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>加载数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure></li><li><p>搭建神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搭建神经网络   </span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self</span>):      </span><br><span class="line">        <span class="built_in">super</span>(Model, self)._init_()       </span><br><span class="line">        self.model = nn.Sequential(                  </span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),               </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),          </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),           </span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),                </span><br><span class="line">            nn.Flatten(),                </span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">64</span>),              </span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>))             </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):                  </span><br><span class="line">        x = self.model(x)                  </span><br><span class="line">        <span class="keyword">return</span> x  </span><br></pre></td></tr></table></figure></li><li><p>创建网络模型，定义损失函数及优化器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建网络模型  </span></span><br><span class="line">model = Model()  </span><br><span class="line"><span class="comment">#损失函数  </span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()  </span><br><span class="line"><span class="comment">#优化器  </span></span><br><span class="line">learning_rate = <span class="number">0.01</span>  </span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure></li><li><p>设置训练网络中的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置训练网络的一些参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮数</span></span><br><span class="line">epoch = <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>开始训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------第&#123;&#125;轮训练开始-------&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    model.train() <span class="comment"># 如果有Dropout层，调用这个会激活其</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = model(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练次数:&#123;&#125;, Loss:&#123;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))</span><br></pre></td></tr></table></figure></li><li><p>在测试集上测试模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试步骤开始</span></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment"># 如果有Dropout层，调用这个会将其失效</span></span><br><span class="line">total_test_loss =<span class="number">0</span>  </span><br><span class="line"><span class="keyword">with</span> torch.no_grad():    </span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:     </span><br><span class="line">        imgs, targets = data      </span><br><span class="line">        outputs = model(imgs)       </span><br><span class="line">        loss = loss_fn(outputs, targets)           </span><br><span class="line">        total_test_loss = total_test_loss + loss</span><br></pre></td></tr></table></figure></li></ol><h2 id="在GPU上训练"><a href="#在GPU上训练" class="headerlink" title="在GPU上训练"></a>在GPU上训练</h2><p>可以用Python命令<code>!nvidia-smi</code>查看GPU配置。</p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>对模型<code>model</code>、训练和测试时的数据<code>imgs,targets</code>、损失函数<code>loss</code>，调用<code>.cuda()</code>，让它们转移到GPU上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():  </span><br><span class="line">    model = model.cuda()</span><br></pre></td></tr></table></figure><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>可以用以下内容代替<code>.cuda()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;gpu&quot;</span>)</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学海泛舟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python与操作系统交互</title>
      <link href="/post/772417664.html"/>
      <url>/post/772417664.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python执行命令行指令"><a href="#Python执行命令行指令" class="headerlink" title="Python执行命令行指令"></a>Python执行命令行指令</h1><h2 id="执行命令行指令"><a href="#执行命令行指令" class="headerlink" title="执行命令行指令"></a>执行命令行指令</h2><p>首先导入<code>subprocess</code>模块，然后通过<code>subprocess.run</code>来执行命令行指令。</p><blockquote><p>指令是在当前运行的脚本的工作目录下执行的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = subprocess.run(<span class="string">f&#x27;ls&#x27;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,text=<span class="literal">True</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>函数的参数说明如下：</p><ul><li><code>args</code>：这个参数可以是一个字符串，也可以是一个程序参数列表。如果是字符串，需要加上<code>shell=True</code>参数，以便通过shell来解释这个命令。在这个例子中，<code>args</code>是<code>f&#39;ls&#39;</code>，表示执行<code>ls</code>命令。</li><li><code>shell=True</code>：这个参数指示<code>subprocess.run()</code>使用shell来执行这个命令。</li><li><code>stdout=subprocess.PIPE</code>和<code>stderr=subprocess.PIPE</code>：这两个参数表示子进程的标准输出和标准错误输出将被捕获，并通过<code>CompletedProcess</code>对象的<code>stdout</code>和<code>stderr</code>属性提供。如果这两个参数没有被设置，子进程的标准输出和标准错误输出将直接显示在屏幕（Python控制台）上。</li><li><code>text=True</code>：这个参数表示在<code>stdout</code>和<code>stderr</code>中的输出将以文本形式返回，而不是字节形式。这个参数需要Python 3.7或更高版本支持。</li><li><code>encoding=&#39;utf-8&#39;</code>：这个参数指定了编码方式，用于将字节转换为文本。在这个例子中，使用的是UTF-8编码。</li></ul><p>可以打印出标准输出和标准错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(result.stdout)</span><br><span class="line"><span class="built_in">print</span>(result.stderr)</span><br></pre></td></tr></table></figure><h2 id="更改工作目录"><a href="#更改工作目录" class="headerlink" title="更改工作目录"></a>更改工作目录</h2><p>因为<code>subprogress.run</code>是在当前工作目录下执行，所以需要切换工作目录，才能在指定的地方执行命令行指令。</p><p>在Python中，<code>os.chdir()</code> 函数用于改变当前工作目录到指定的路径。这个函数是<code>os</code>模块的一部分。另外可以用<code>os.getcwd()</code>来获取当前的工作目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作目录：&quot;</span>, current_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变工作目录到 &#x27;/path/to/another/directory&#x27;</span></span><br><span class="line">os.chdir(<span class="string">&#x27;/path/to/another/directory&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次获取当前工作目录</span></span><br><span class="line">current_directory = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;改变后的工作目录：&quot;</span>, current_directory)</span><br></pre></td></tr></table></figure><h1 id="Python与文件管理"><a href="#Python与文件管理" class="headerlink" title="Python与文件管理"></a>Python与文件管理</h1><h2 id="构建完整路径"><a href="#构建完整路径" class="headerlink" title="构建完整路径"></a>构建完整路径</h2><p><code>os.path.join(root, file)</code>，这个函数用于将两个或多个路径组件合并为一个完整的路径。它智能地处理目录分隔符（如UNIX系统中的<code>/</code>或Windows系统中的<code>\</code>），并确保路径的正确性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">root = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">file = <span class="string">&#x27;example.txt&#x27;</span></span><br><span class="line">full_path = os.path.join(root, file)</span><br></pre></td></tr></table></figure><h2 id="列出目录下的文件和子目录"><a href="#列出目录下的文件和子目录" class="headerlink" title="列出目录下的文件和子目录"></a>列出目录下的文件和子目录</h2><p><code>os.listdir(path)</code>，这个函数用于列出指定路径下的所有文件和目录（子目录）的名称。它返回一个列表，包含<code>path</code>指定的目录中的所有文件和子目录的名称。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">new_articles_dir = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line">files_and_dirs = os.listdir(new_articles_dir)</span><br></pre></td></tr></table></figure><h2 id="检查给定路径是否是文件"><a href="#检查给定路径是否是文件" class="headerlink" title="检查给定路径是否是文件"></a>检查给定路径是否是文件</h2><p><code>os.path.isfile(path)</code>，这个函数用于检查给定的路径是否是一个文件。如果<code>path</code>是一个存在的文件，它返回<code>True</code>；如果<code>path</code>不存在或者是一个目录，它返回<code>False</code>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 是一个文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span> 不是一个文件&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除指定文件"><a href="#删除指定文件" class="headerlink" title="删除指定文件"></a>删除指定文件</h2><p><code>os.remove(file_path)</code>，这个函数用于删除指定的文件。如果<code>file_path</code>是一个文件并且删除成功，函数不会有任何返回值。如果文件不存在或者由于某些原因（如权限问题）无法删除，会抛出一个<code>OSError</code>异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">&#x27;/path/to/file.txt&#x27;</span></span><br><span class="line">os.remove(file_path)</span><br></pre></td></tr></table></figure><h2 id="删除给定文件夹"><a href="#删除给定文件夹" class="headerlink" title="删除给定文件夹"></a>删除给定文件夹</h2><p><code>shutil.rmtree()</code> 函数用于<strong>递归删除目录及其所有子目录和文件</strong>。<code>shutil</code> 是 Python 的一个模块，提供了许多文件操作的高级函数。</p><p><code>shutil.rmtree(path, ignore_errors=False, onerror=None)</code> 函数的参数说明如下：</p><ul><li><code>path</code>：这是一个字符串，表示要删除的目录的路径。</li><li><code>ignore_errors</code>：这是一个布尔值，默认为<code>False</code>。如果设置为<code>True</code>，则在删除过程中忽略发生的错误。</li><li><code>onerror</code>：这是一个函数，用于处理在删除过程中发生的错误。如果指定了这个参数，它应该是一个接受三个参数的函数：(errno, strerror, filename)。在这个函数中，你可以定义错误处理逻辑。</li></ul><p>这是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要删除的目录路径</span></span><br><span class="line">dir_path = <span class="string">&#x27;/path/to/directory&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归删除目录及其所有子目录和文件</span></span><br><span class="line">shutil.rmtree(dir_path)</span><br></pre></td></tr></table></figure><h2 id="复制给定文件夹"><a href="#复制给定文件夹" class="headerlink" title="复制给定文件夹"></a>复制给定文件夹</h2><p><code>shutil.copytree()</code> 函数用于递归地复制一个目录树从一个位置到另一个位置。</p><p><code>shutil.copytree(src, dst)</code> 中参数说明如下：</p><ul><li><code>src</code>：这是一个字符串，表示源目录的路径，即要复制的目录。</li><li><code>dst</code>：这是一个字符串，表示目标目录的路径，即复制的目录将被放置的地方。<strong>如果目标目录已经存在，<code>shutil.copytree()</code> 将会抛出一个 <code>FileExistsError</code> 异常</strong>。如果目标目录不存在，它将会被创建。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="comment"># 源目录和目标目录的路径</span></span><br><span class="line">source_item = <span class="string">&#x27;/path/to/source_directory&#x27;</span></span><br><span class="line">destination_item = <span class="string">&#x27;/path/to/destination_directory&#x27;</span></span><br><span class="line"><span class="comment"># 递归复制目录树</span></span><br><span class="line">shutil.copytree(source_item, destination_item)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学海泛舟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个简易神经网络</title>
      <link href="/post/2484359005.html"/>
      <url>/post/2484359005.html</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络简述"><a href="#神经网络简述" class="headerlink" title="神经网络简述"></a>神经网络简述</h1><h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>神经网络通过模拟人神经元的活动，通过输入预测输出。</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/从零开始搭建一个简易神经网络/image-20240424091712887.png" alt="image-20240424091712887"></p><p>神经网络中的一个神经元的树突接触到输入，然后经过计算之后从轴突上传出信号。</p><p>经过抽象之后，一个神经元就长这样：</p><p><img src="https://xiao--bai.oss-cn-guangzhou.aliyuncs.com/从零开始搭建一个简易神经网络/image-20240430201657690.png" alt="image-20240430201657690"></p><p>其接受3个输入，$x_1,x_2,x_3$，经过线性运算$w^Tx+b$，和激活函数$\sigma(z)$后，输出$a$​​。</p><blockquote><p>$w$是一个$3\times1$的列向量，$x$是一个$3\times1$的列向量，$b$是一个实数</p></blockquote><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>多个神经元（cell）一起就组成了神经网络，一个神经网络可以表示为如下这样：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((年龄))salary((薪水))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1 &amp; x2 &amp; x3-.-&gt;x4((cell)) &amp; x5((cell)) &amp; x6((cell)) -.-&gt;output((sigmoid))--&gt;y((结果))  </pre></div><p>其中从左到右第一层称为输入层，第二、三层称为隐藏层，第四层成为输出层。</p><h2 id="神经网络的工作方式"><a href="#神经网络的工作方式" class="headerlink" title="神经网络的工作方式"></a>神经网络的工作方式</h2><p>神经网络的每一层都是由多个神经元组成的，这里取这样的一层神经元：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{ init : { &#39;flowchart&#39; : { &#39;curve&#39; : &#39;basis&#39; }}}%%flowchart LRage((x1))salary((x2))age-.-&gt;x1((cell)) &amp; x2((cell)) &amp; x3((cell))salary-.-&gt;x1 &amp; x2 &amp; x3x1--&gt;y1((y1))x2--&gt;y2((y2))x3--&gt;y3((y3))  </pre></div><p>那么：</p><ul><li>第一个神经元计算$a_1=w_1^Tx+b_1$与$y_1=\sigma(a_1)$。</li><li>第二个神经元计算$a_2=w_2^Tx+b_2$与$y_2=\sigma(a_2)$</li><li>第三个神经元计算$a_3=w_3^Tx+b_1$与$y_3=\sigma(a_3)$</li></ul><blockquote><p>这里，$w_i$是一个$2\times1$的列向量，$x$是一个$2\times1$的列向量，$b$​是一个实数</p></blockquote><p>因为每个神经元执行的操作类似，所以可以将$w_i$和$b$堆叠起来，以表示输入通过这一层神经元得到的输出。</p><p>我们将所有的 $w^T_i$ 按行堆叠成一个矩阵$W$，其中每一行对应一个神经元的权重向量的转置 $w^T_i$。</p><script type="math/tex; mode=display">W = \left[ \begin{array}{cc}w_1^T \\w_2^T \\w_3^T\end{array} \right]</script><p>将所有的偏置 $b_i$ 按行堆叠成一个列向量，其中每个元素对应一个神经元的偏置 $b_i$。因此，堆叠后的 $b$ 将是一个 $3 \times 1$ 的列向量：</p><script type="math/tex; mode=display">b = \left[ \begin{array}{c}b_1 \\b_2 \\b_3\end{array} \right]</script><p>这里，每个 $b_i$ 是一个实数。</p><p>现在，我们可以用堆叠后的 $W$ 和 $b$ 来表示所有神经元的输出：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><p>其中，$Y$ 是一个 $3 \times 1$ 的列向量，包含了所有神经元的输出；$X$ 是一个 $2 \times 1$ 的列向量，表示输入特征。</p><h2 id="多样本"><a href="#多样本" class="headerlink" title="多样本"></a>多样本</h2><p>到目前为止，神经网络的输入还是单样本，但在实际的问题中，遇到的都是多样本，如果一个个样本输入则太慢了。</p><p>又考虑到每个样本$x_i$在神经网络中所经过的计算是相似的。所以，同样的想法，可以将样本$x_1,x_2,\cdots,x_n$按列的方式堆叠成一个矩阵$X$。</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}| & | &  & | \\x^{(1)} & x^{(2)} & \cdots & x^{(n)} \\| & | &  & |\end{array}\right]</script><p>展开来就是：</p><script type="math/tex; mode=display">X = \left[\begin{array}{cccc}x^{(1)}_1 & x^{(2)}_1 & \cdots & x^{(n)}_1 \\x^{(1)}_2 & x^{(2)}_2 & \cdots & x^{(n)}_2 \\\vdots & \vdots & \ddots & \vdots \\x^{(1)}_{m} & x^{(2)}_{m} & \cdots & x^{(n)}_{m}\end{array}\right]</script><blockquote><p>$m$个特征，$n$个样本</p></blockquote><p>而每层的计算方式并没有因为样本的堆叠发生改变，仍然是：</p><script type="math/tex; mode=display">Y =\sigma( WX + b)</script><blockquote><p>这里意思是每一列都加上$b$</p></blockquote><p>只不过矩阵的维度发生了变化：</p><ul><li>$X$维度变为$(m,n)$</li><li>$Y$的维度变为$(m’,n)$​</li></ul><blockquote><p>$W$矩阵的维度是$(m’,m)$​维</p></blockquote><h2 id="更新参数"><a href="#更新参数" class="headerlink" title="更新参数"></a>更新参数</h2><p>刚才所述统都属于前向传播的过程，而到这里还有一个关键的问题没有解决，就是神经网络的参数$W$和$b$​​要怎么更新。如果不更新，神经网络就无法学习样本中的特征。所以就需要引入反向传播算法，用于更新这两个参数。</p><p>而反向传播算法中常用的是梯度下降。</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>考虑一个函数$z=f(x,y)$，在高数中学过，其在$x_0,y_0$增长最快的方向就是函数$f(x,y)$在这一点的梯度向量的方向。而$f(x,y)$在$(x_0,y_0)$处的梯度向量是$(\frac{\partial f}{\partial x}|_{x_0,y_0},\frac{\partial f}{\partial y}|_{x_0,y_0})$。所以$(x_0+\frac{\partial f}{\partial x}|_{x_0,y_0},y_0+\frac{\partial f}{\partial y}|_{x_0,y_0})$可以使得$f(x,y)$​增长最快。</p><p>那么相反的（如果一个函数是凸的），函数的减小最快的方向就是梯度向量的反方向，即$(x_0-\frac{\partial f}{\partial x}|_{x_0,y_0},y_0-\frac{\partial f}{\partial y}|_{x_0,y_0})$</p><h3 id="神经网络中的梯度下降"><a href="#神经网络中的梯度下降" class="headerlink" title="神经网络中的梯度下降"></a>神经网络中的梯度下降</h3><p>在神经网络中也是类似的，损失函数$f$（也就是神经网络预测的$\hat y$和实际的$y$的偏差）是各层权重矩阵$W$和偏置向量$b$的函数。</p><p>所以也可以用同样的方法去更新$W$和$b$​：</p><script type="math/tex; mode=display">W=W-\alpha \cdot \frac{\partial f}{\partial W}\\b=b-\alpha \cdot \frac{\partial f}{\partial b}</script><blockquote><p>这里的$\alpha$​是学习率</p></blockquote><p>下面直接给出神经网络中单层的梯度下降公式：</p><ul><li><p>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</p></li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ul><blockquote><p>其中，$dA^{[l]}$ 是损失函数对 $A^{[l]}$ 的梯度，$dZ^{[l]}$ 是损失函数对 $Z^{[l]}$​ 的梯度。上标$[l]$指的是第$l$​层。以此类推。</p><p>[!NOTE]</p><p>如果想看详细的证明，推荐吴恩达在B站的深度学习课程，这是相关的几节：</p><p><a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=10&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=15&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">逻辑回归中的梯度下降法</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=16">m个样本的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=33&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">神经网络中的梯度下降</a>、<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=34&amp;vd_source=a72ba0205e5decee94fccb8c6b66a1e2">直观理解反向传播</a></p></blockquote><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>采用<code>Python</code>编写程序，需要用到的库有：</p><ul><li><code>numpy</code>：用于矩阵计算</li><li><code>tensorboard</code>（可选）：用来记录训练数据</li></ul><h1 id="单层神经元"><a href="#单层神经元" class="headerlink" title="单层神经元"></a>单层神经元</h1><p>因为可以将神经网络拆分成一层层神经元的堆叠，所以只要写好一层，将这层复制多份，就可以构建一个神经网络。所以可以创建一个名叫<code>Layer</code>的类，代表一层神经元</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart LRsubgraph 神经网络layer1[layer]layer2[layer]endinput--&gt;layer1--&gt;layer2--&gt;output  </pre></div><p>而如刚才所述，每一层都进行前向传播和反向传播。而在实现前向传播和反向传播之前，先来考虑每一层中应该有什么元素。</p><h2 id="Layer类中的变量"><a href="#Layer类中的变量" class="headerlink" title="Layer类中的变量"></a>Layer类中的变量</h2><p>再回头看抽象出来的神经元以及前向传播和反向传播的过程：</p><p>可以看出，每一层需要有权重矩阵<code>W</code>，偏置矩阵<code>b</code>，还有选用的激活函数$\sigma$。</p><p>除此之外，构建权重矩阵<code>W</code>时还需要知道该层结点数目；在实现反向传播的时候还需要知道该层神经网络的输入$A^{[l-1]}$、该层神经网络的输出对损失函数的导数$dA^{[l]}$、学习率$\alpha$、$WX+b$的输出$Z$以及样本数$m$。</p><p>所以类的成员变量如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="comment"># 神经元参数</span></span><br><span class="line">    __W = <span class="literal">None</span>  <span class="comment"># 权重矩阵</span></span><br><span class="line">    __b = <span class="literal">None</span>  <span class="comment"># 偏置部分</span></span><br><span class="line">    __A_last_layer = <span class="literal">None</span>  <span class="comment"># 上层的输入</span></span><br><span class="line">    __Z = <span class="literal">None</span>  <span class="comment"># Wx+b得到的Z，之后会在反向传播中运用</span></span><br><span class="line">    __activation_function = <span class="literal">None</span>  <span class="comment"># 激活函数类型</span></span><br><span class="line">    __node_amount = <span class="literal">None</span>  <span class="comment"># 结点数目</span></span><br><span class="line">    __alpha = <span class="literal">None</span>  <span class="comment"># 学习率</span></span><br><span class="line">    __sample_amount = <span class="literal">None</span>  <span class="comment"># 样本数</span></span><br></pre></td></tr></table></figure><p>再给出构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, last_layer_node_amount, node_amount=<span class="number">4</span>, activation_function=<span class="string">&quot;relu&quot;</span>, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="comment"># 初始化节点数量和激活函数类型</span></span><br><span class="line">    self.__node_amount = node_amount</span><br><span class="line">    self.__activation_function = activation_function</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化权重矩阵</span></span><br><span class="line">    self.__W = np.random.randn(node_amount, last_layer_node_amount) * np.sqrt(<span class="number">2</span> / last_layer_node_amount)</span><br><span class="line">    <span class="comment"># 初始化偏置矩阵</span></span><br><span class="line">    self.__b = np.random.randn(node_amount, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 设置学习率</span></span><br><span class="line">    self.__alpha = alpha</span><br></pre></td></tr></table></figure><h2 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h2><p>之后，就可以开始实现最简单的前向传播算法，总共就只有两步：</p><ol><li>计算$WX+b$得到$Z$​</li><li>根据激活函数的不同，选择不同的激活函数计算$Y=\sigma(Z)$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X: np.ndarray</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播</span></span><br><span class="line"><span class="string">    :param X: 每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    :return: 该层的输出，保持每一列是一个样本，每一行是一个特征</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置样本数</span></span><br><span class="line">    self.__sample_amount = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    self.__A_last_layer = X</span><br><span class="line">    self.__Z = np.dot(self.__W, X) + self.__b  <span class="comment"># 计算WX+b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> activation_function.tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, Z, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播是整个代码中最复杂的部分，但只要掌握这四条公式，也是四个步骤，写下来也不难：</p><ol><li>计算 $dZ^{[l]}$：$dZ^{[l]} = dA^{[l]} * g^{[l]’}(Z^{[l]})$</li><li><p>计算 $dW^{[l]}$：$dW^{[l]} = \frac{1}{m} dZ^{[l]} \cdot A^{[l-1]T}$</p></li><li><p>计算 $db^{[l]}$：$db^{[l]} = \frac{1}{m}np.sum(dZ^{[l]},axis=1,keepdims=True)$</p></li><li><p>计算 $dA^{[l-1]}$：$dA^{[l-1]} = W^{[l]T} \cdot dZ^{[l]}$</p></li></ol><p>转换为对应代码，即为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dA</span>):</span><br><span class="line">    dZ = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 计算dZ</span></span><br><span class="line">    <span class="keyword">if</span> self.__activation_function == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_relu(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_sigmoid(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;linear&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_linear(self.__Z)</span><br><span class="line">    <span class="keyword">elif</span> self.__activation_function == <span class="string">&quot;tanh&quot;</span>:</span><br><span class="line">        dZ = dA * activation_function.d_tanh(self.__Z)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;invalid activation function!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算上一层的dA</span></span><br><span class="line">    dA_last_layer = np.dot(self.__W.T, dZ)</span><br><span class="line">    <span class="comment"># 更新权重矩阵</span></span><br><span class="line">    self.__W -= self.__alpha * (<span class="number">1</span> / self.__sample_amount) * np.dot(dZ, self.__A_last_layer.T)</span><br><span class="line">    <span class="comment"># 更新偏置量</span></span><br><span class="line">    self.__b -= (<span class="number">1</span> / self.__sample_amount) * np.<span class="built_in">sum</span>(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dA_last_layer</span><br></pre></td></tr></table></figure><p>这里以<code>relu</code>为例，给出激活函数导数的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d_relu</span>(<span class="params">Z: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">return</span> np.where(Z &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="神经网络的封装"><a href="#神经网络的封装" class="headerlink" title="神经网络的封装"></a>神经网络的封装</h1><p>写好单层之后，将单层神经元进行堆叠就可以得到完整的神经网络。</p><p>定义一个Network类，用于保存神经网络。以下是其的成员变量和构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Network</span>:</span><br><span class="line">    __layers = []  <span class="comment"># 保存隐藏层和输出层</span></span><br><span class="line">    __X_train, __Y_train, __X_test, __Y_test = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># 训练集和测试集</span></span><br><span class="line">    __loss_function = <span class="literal">None</span>  <span class="comment"># 损失函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nodes_amount: <span class="built_in">list</span>, X_train, Y_train, X_test, Y_test, learning_speed,</span></span><br><span class="line"><span class="params">             output_layer_function=<span class="string">&quot;sigmoid&quot;</span>,</span></span><br><span class="line"><span class="params">             hidden_layer_function=<span class="string">&quot;relu&quot;</span>,</span></span><br><span class="line"><span class="params">             loss_function=<span class="string">&quot;cross entropy&quot;</span></span>):  <span class="comment"># 通过字符串来选择隐藏层，输出层的激活函数，还有损失函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    初始化神经网络</span></span><br><span class="line"><span class="string">    :param nodes_amount: 每层的结点数</span></span><br><span class="line"><span class="string">    :param X_train: 训练数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_train: 训练标签，每行使不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param X_test: 测试数据，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param Y_test: 测试标签，每行是不同特征，每列是不同样本</span></span><br><span class="line"><span class="string">    :param learning_speed: 学习速率</span></span><br><span class="line"><span class="string">    :param output_layer_function: 输出层激活函数</span></span><br><span class="line"><span class="string">    :param hidden_layer_function: 隐藏层激活函数</span></span><br><span class="line"><span class="string">    :param loss_function: 损失函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断维度是否正确</span></span><br><span class="line">    <span class="keyword">if</span> X_train.shape[<span class="number">0</span>] != X_test.shape[<span class="number">0</span>] <span class="keyword">or</span> Y_train.shape[<span class="number">0</span>] != Y_test.shape[<span class="number">0</span>] <span class="keyword">or</span> X_train.shape[<span class="number">1</span>:] != \</span><br><span class="line">            Y_train.shape[<span class="number">1</span>:] <span class="keyword">or</span> X_test.shape[<span class="number">1</span>:] != Y_test.shape[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存损失函数</span></span><br><span class="line">    <span class="keyword">if</span> loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">        self.__loss_function = loss_function</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;loss function name error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练集、测试集</span></span><br><span class="line">    self.__X_train = X_train</span><br><span class="line">    self.__X_test = X_test</span><br><span class="line">    self.__Y_train = Y_train</span><br><span class="line">    self.__Y_test = Y_test</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nodes_amount)):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(X_train.shape[<span class="number">0</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index &lt; <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], hidden_layer_function, learning_speed))</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="built_in">len</span>(nodes_amount) - <span class="number">1</span>:</span><br><span class="line">            self.__layers.append(</span><br><span class="line">                layer.Layer(nodes_amount[index - <span class="number">1</span>], nodes_amount[index], output_layer_function, learning_speed))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><p>因为每一层的前向传播和反向传播都是已经写好的。所以在整个神经网络的训练过程中，只需要逐层调用前向传播和反向传播即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, times</span>):</span><br><span class="line">    <span class="comment"># 增加计数器</span></span><br><span class="line">    count = increment_counter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#tensorboard记录</span></span><br><span class="line">    writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="comment"># 正向传播</span></span><br><span class="line">        layer_input = self.__X_train</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">        dA = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.__loss_function == <span class="string">&quot;cross entropy&quot;</span>:</span><br><span class="line">            <span class="comment"># 计算误差。最后一层对下一层的输入就是最终输出</span></span><br><span class="line">            loss = loss_function.cross_entropy(layer_input, self.__Y_train)</span><br><span class="line">            <span class="comment">#记录数据</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;iteration:<span class="subst">&#123;iteration&#125;</span>,loss:<span class="subst">&#123;loss&#125;</span>&#x27;</span>)</span><br><span class="line">            writer.add_scalar(<span class="string">f&#x27;loss<span class="subst">&#123;count&#125;</span>&#x27;</span>, loss, iteration)</span><br><span class="line">            <span class="comment"># 计算最终输出对损失函数的偏导数</span></span><br><span class="line">            dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            layer = self.__layers[index]</span><br><span class="line">            dA = layer.backward(dA)</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure><p>因为在反向传播的时候需要给出该层神经元输出对损失函数的偏导数，所以需要计算最终输出对损失函数的偏导数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dA = loss_function.d_cross_entropy(layer_input, self.__Y_train)</span><br></pre></td></tr></table></figure><p>这里的损失函数采取的是交叉熵函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    m = A.shape[<span class="number">1</span>]</span><br><span class="line">    loss = Y * np.log(A) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - A)</span><br><span class="line">    loss = (-<span class="number">1</span> / m) * np.<span class="built_in">sum</span>(loss, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d_cross_entropy</span>(<span class="params">A: np.ndarray, Y: np.ndarray</span>):</span><br><span class="line">    <span class="keyword">if</span> A.shape != Y.shape:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;dimension is not match&quot;</span></span><br><span class="line">    dA = -(Y * (<span class="number">1</span> / A) + (Y - <span class="number">1</span>) * (<span class="number">1</span> / (<span class="number">1</span> - A)))</span><br><span class="line">    <span class="keyword">return</span> dA</span><br></pre></td></tr></table></figure><p>至此，整个训练过程的代码就写完了</p><h2 id="神经网络的预测"><a href="#神经网络的预测" class="headerlink" title="神经网络的预测"></a>神经网络的预测</h2><p>神经网络的预测实际上就是对特征矩阵做一次前向传播，神经网络的输出就是预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">    layer_input = X</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__layers)):</span><br><span class="line">        layer = self.__layers[index]</span><br><span class="line">        layer_input = layer.forward(layer_input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layer_input</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，整个神经网络的框架就搭建好了。主要的两个类是单层神经元<code>Layer</code>以及神经网络类<code>Network</code>：<code>Layer</code>类需要实现前向传播和反向传播，<code>Network</code>类需要实现训练的过程。</p><p>其他的例如激活函数的改变、损失函数的改变，只需要在原有的框架下写一些条件判断即可。</p>]]></content>
      
      
      <categories>
          
          <category> 学海泛舟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫笔记</title>
      <link href="/post/498308509.html"/>
      <url>/post/498308509.html</url>
      
        <content type="html"><![CDATA[<h1 id="模拟发送-HTTP-请求"><a href="#模拟发送-HTTP-请求" class="headerlink" title="模拟发送 HTTP 请求"></a>模拟发送 HTTP 请求</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>GET请求是HTTP协议中定义的一种请求方法，用于从服务器获取数据。当发起一个GET请求时，客户端（通常是用户的网页浏览器）向服务器发送一个请求，请求服务器返回指定的资源或数据。当我们用浏览器打开网页时，其实发送的最原始的请求就是 GET 请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line">res = requests.get(<span class="string">&#x27;http://www.douban.com&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(res) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(res)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">&lt;Response [<span class="number">200</span>]&gt; </span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;requests.models.Response&#x27;</span>&gt; </span><br></pre></td></tr></table></figure><p>可以看到，我们得到的是一个 <code>Response</code> 对象</p><p>如果我们要获取网站返回的数据，可以使用 <code>text</code> 或者 <code>content</code> 属性来获取</p><p><code>text</code>：是以字符串的形式返回数据</p><p><code>content</code>：是以二进制的方式返回数据</p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>POST请求是HTTP协议中定义的另一种请求方法，用于向服务器提交数据。当发起一个POST请求时，客户端向服务器发送数据，并且这些数据通常作为HTTP请求的一部分（称为请求体）被发送。</p><p>对于 POST 请求，一般就是提交一个表单。<code>data</code> 当中，就是需要传递的表单信息，是一个字典类型的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&#x27;http://www.xxxx.com&#x27;</span>, data=&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;) </span><br></pre></td></tr></table></figure><h2 id="header-增强"><a href="#header-增强" class="headerlink" title="header 增强"></a>header 增强</h2><p>requests 发送的请求所带的请求头中 User-Agent 会标识为 python 程序发送的请求。</p><p>由于这种行为仅仅是消耗服务器资源带来成本，但是不会给对方带来任何好处（搜索引擎的爬虫除外），所以有一些网站会加入反爬机制，通过识别 headers 来拒绝对你的请求进行响应。</p><p>所以需要做一些 header 增强。比如：UA，Cookie，host 等等信息。</p><p>浏览器访问网站时的 headers 可以在<a href="https://link.zhihu.com/?target=https%3A//httpbin.org/headers">httpbin.org/headers</a> 中得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, </span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, </span><br><span class="line">    &quot;Accept-Language&quot;: &quot;zh-CN,zh-Hans;q=0.9&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;Referer&quot;: &quot;https://link.zhihu.com/?target=https%3A//httpbin.org/headers&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Dest&quot;: &quot;document&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Mode&quot;: &quot;navigate&quot;, </span><br><span class="line">    &quot;Sec-Fetch-Site&quot;: &quot;cross-site&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-662b0580-3525d80357418fc75f2d3472&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的请求头复制下来，传给 <code>requests.get()</code> 函数，即可将请求伪装成浏览器。</p><p><code>requests.get()</code> 的语法是：<code>requests.get(url,kwargs)</code>。</p><p>其中，url 是我们想要访问的链接，kwargs 是可选参数，包括params、data、json、headers、cookies、auth、files、timeout、proxies、stream、verify、cert等。常用的参数有data、headers。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://httpbin.org/headers&#x27;</span></span><br><span class="line"></span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;image/gif, image/jpeg, image/pjpeg, application/x-ms-application, application/xaml+xml, application/x-ms-xbap, */*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; Tablet PC 2.0; wbx 1.0.0; wbxapp 1.0.0; Zoom 3.6.0)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-628b672d-4d6de7f34d15a77960784504&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(response.text) </span><br></pre></td></tr></table></figure><h1 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 HTML</h1><p>现在我们已经获取到了网页返回的数据，即 HTML 代码，下面就需要解析 HTML，来提取其中有效的信息。</p><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><code>BeautifulSoup</code> 是 Python 的一个库，最主要的功能是从网页解析数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  <span class="comment"># 导入 BeautifulSoup 的方法 </span></span><br><span class="line"><span class="comment"># 可以传入一段字符串，或者传入一个文件句柄。一般都会先用 requests 库获取网页内容，然后使用 soup 解析。 </span></span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">&#x27;html.parser&#x27;</span>)  <span class="comment"># 这里一定要指定解析器，可以使用默认的 html，也可以使用 lxml。 </span></span><br><span class="line"><span class="built_in">print</span>(soup.prettify())  <span class="comment"># 按照标准的缩进格式输出获取的 soup 内容。 </span></span><br></pre></td></tr></table></figure><blockquote><p><code>bs4</code> 是 <code>BeautifulSoup</code> 库的简称，它是一个用于解析 HTML 和 XML 文档的 Python 库，通常用于网页抓取和数据分析。<code>BeautifulSoup</code> 能够处理复杂的 HTML 网页内容，并提供简单易用的 API 来访问和修改数据。</p><p><code>BeautifulSoup</code> 库的名字来源于一个儿童故事中的角色，这个角色喜欢“把字符串咀嚼成美味的网络抓取汤”，因此得名“BeautifulSoup”。</p></blockquote><h3 id="BeautifulSoup-的一些简单用法"><a href="#BeautifulSoup-的一些简单用法" class="headerlink" title="BeautifulSoup 的一些简单用法"></a>BeautifulSoup 的一些简单用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># 获取文档的 title </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.name)  <span class="comment"># 获取 title 的 name 属性 </span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string)  <span class="comment"># 获取 title 的内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p)  <span class="comment"># 获取文档中第一个 p 节点 </span></span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;class&#x27;</span>])  <span class="comment"># 获取第一个 p 节点的 class 内容 </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;a&#x27;</span>))  <span class="comment"># 获取文档中所有的 a 节点，返回一个 list </span></span><br><span class="line"><span class="built_in">print</span>(soup.find_all(<span class="string">&#x27;span&#x27;</span>, attrs=&#123;<span class="string">&#x27;style&#x27;</span>: <span class="string">&quot;color:#ff0000&quot;</span>&#125;))  <span class="comment"># 获取文档中所有的 span 且 style 符合规则的节点，返回一个 list </span></span><br></pre></td></tr></table></figure><p>在HTML和XML文档中，<code>p</code> 结点通常指的是 <code>&lt;p&gt;</code> 标签创建的元素，它代表一个段落（Paragraph）。<code>&lt;p&gt;</code> 标签是块级元素，用于定义文本的一个段落。在网页中，浏览器会在段落之间添加一些垂直的空白，以区分不同的段落。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，每个 <code>&lt;p&gt;</code> 元素都定义了一个文本段落。<br>同样，<code>a</code> 结点指的是 <code>&lt;a&gt;</code> 标签创建的元素，它代表一个锚点（Anchor）。<code>&lt;a&gt;</code> 标签用于创建超链接，允许用户通过点击跳转到其他网页、文件、位置或其他资源。<code>&lt;a&gt;</code> 标签可以包含文本、图片等任何内容，并且通常有一个 <code>href</code> 属性，指定了链接的目标URL。<br>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的HTML代码中，<code>&lt;a&gt;</code> 元素创建了一个文本为“访问示例网站”的超链接，当用户点击这个链接时，浏览器会跳转到 <code>https://www.example.com</code> 这个URL。</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h3><p>在Python的<code>BeautifulSoup</code>库中，<code>find_all</code>方法用于搜索HTML或XML文档，并返回所有匹配指定条件的元素。<code>find_all</code>方法可以接受多种参数，包括要查找的标签名、属性、CSS类等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = content.find_all(<span class="string">&#x27;div&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;cover&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>这行代码的作用是：</p><ol><li><code>content</code> 是一个 <code>BeautifulSoup</code> 对象，它代表了已经解析的HTML文档。</li><li><code>find_all</code> 方法被调用，第一个参数 <code>&#39;div&#39;</code> 指定了要搜索的标签名，即 <code>&lt;div&gt;</code>。</li><li><code>attrs=&#123;&#39;class&#39;: &#39;cover&#39;&#125;</code> 参数指定了要搜索的 <code>&lt;div&gt;</code> 标签必须具有 <code>class</code> 属性，且属性值包含 <code>cover</code>。这意味着 <code>find_all</code> 方法将返回所有类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素。</li></ol><p>结果 <code>data</code> 将是一个列表，包含了文档中所有匹配的 <code>&lt;div&gt;</code> 元素。每个元素都是一个 <code>Tag</code> 对象，你可以对这些对象进行进一步的操作，例如提取文本、属性或其他嵌套的标签。</p><p>例如，如果您想要遍历这些 <code>&lt;div&gt;</code> 元素并打印它们的文本内容，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">print</span>(div.get_text())</span><br></pre></td></tr></table></figure><p>这将会打印出每个类名为 <code>cover</code> 的 <code>&lt;div&gt;</code> 元素中的文本内容。</p><blockquote><p><code>&lt;div&gt;</code>元素是HTML文档中的一个块级元素，它用于定义文档中的一个区域或部分，并且可以用来组合其他HTML元素。<code>&lt;div&gt;</code>是 “division” 的缩写，意为“分区”。</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在 <code>BeautifulSoup</code> 中，<code>find</code> 方法用于搜索当前元素下的子元素，并返回第一个匹配的元素。如果找到了多个匹配的元素，<code>find</code> 方法只返回第一个匹配的元素。如果没有找到匹配的元素，则返回 <code>None</code>。</p><p>例如，假设我们有以下HTML代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们已经有一个 <code>BeautifulSoup</code> 对象 <code>d</code>，它代表上面的 <code>&lt;div&gt;</code> 元素，那么我们可以使用 <code>d.find(&#39;img&#39;)</code> 来找到第一个 <code>&lt;img&gt;</code> 子元素。</p><p>我们可以进一步从 <code>img_tag</code> 中获取 <code>src</code> 属性，得到图片的URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_url = img_tag[<span class="string">&#x27;src&#x27;</span>]</span><br></pre></td></tr></table></figure><p>在这里，<code>img_url</code> 的值将是 <code>&quot;image1.jpg&quot;</code>。</p><h3 id="get-text"><a href="#get-text" class="headerlink" title="get_text"></a>get_text</h3><p>在 <code>BeautifulSoup</code> 中，<code>get_text()</code> 方法是一个用于提取标签内文本内容的方法。它将返回一个字符串，该字符串包含指定标签及其所有子标签的文本内容，而不包含任何HTML标签或属性。</p><p><code>get_text()</code> 方法可以用于任何 <code>Tag</code> 对象，它会递归地提取所有子标签的文本，并将它们连接成一个字符串。<br>这里有一些 <code>get_text()</code> 方法的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># 假设我们有以下HTML内容</span></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Page Title&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;这是一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;a href=&quot;http://example.com&quot;&gt;这是一个链接&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 使用 BeautifulSoup 解析 HTML</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取整个文档的文本内容</span></span><br><span class="line">text = soup.get_text()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page Title</span><br><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br>你也可以在特定的标签上调用 <code>get_text()</code> 方法来提取该标签及其子标签的文本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取特定标签 &lt;div&gt; 的文本内容</span></span><br><span class="line">div_text = soup.div.get_text()</span><br><span class="line"><span class="built_in">print</span>(div_text)</span><br></pre></td></tr></table></figure><br>输出将会是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落。</span><br><span class="line">这是一个链接</span><br></pre></td></tr></table></figure><br><code>get_text()</code> 方法还有一些参数，可以用来控制如何提取文本：</p><ul><li><code>strip</code>: 布尔值，默认为 <code>False</code>，表示是否去除文本前后的空白字符。</li><li><code>separator</code>: 字符串，用于连接各个文本片段的分隔符，默认为 “”，表示不添加分隔符。</li></ul><h1 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_picture</span>(<span class="params">pic_l</span>): </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">r&#x27;picture&#x27;</span>): </span><br><span class="line">        os.mkdir(<span class="string">r&#x27;picture&#x27;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pic_l: </span><br><span class="line">        pic = requests.get(i) </span><br><span class="line">        p_name = i.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">7</span>] </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;picture\\&#x27;</span> + p_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">            f.write(pic.content) </span><br></pre></td></tr></table></figure><ol><li><code>if not os.path.exists(r&#39;picture&#39;):</code><ul><li>这个条件判断语句检查在当前目录下是否存在一个名为 <code>picture</code> 的文件夹。<code>os.path.exists</code>是一个检查路径是否存在的函数，<code>r&#39;picture&#39;</code> 表示 <code>picture</code> 文件夹的路径，<code>r</code> 前缀表示这是一个原始字符串，不处理反斜杠 <code>\</code> 作为转义字符。</li></ul></li><li><code>os.mkdir(r&#39;picture&#39;)</code><ul><li>如果上述条件成立（即 <code>picture</code> 文件夹不存在），这行代码会创建一个名为 <code>picture</code> 的新文件夹。</li></ul></li><li><code>pic = requests.get(i)</code><ul><li>在循环内部，这行代码使用 <code>requests.get</code> 函数从互联网上获取（下载）URL <code>i</code> 指向的图片内容，并将响应内容赋值给变量 <code>pic</code>。</li></ul></li><li><code>p_name = i.split(&#39;/&#39;)[7]</code><ul><li>这行代码将URL <code>i</code> 按照斜杠 <code>/</code> 分割成多个部分，并取出第8个部分（列表索引为7）作为图片的文件名。这里假设URL的第八部分是图片的文件名。</li></ul></li><li><code>with open(&#39;picture\\&#39; + p_name, &#39;wb&#39;) as f:</code><ul><li>这行代码打开一个文件，文件路径是 <code>picture</code> 文件夹加上图片的文件名 <code>p_name</code>，文件以二进制写模式（‘wb’）打开。<code>with</code> 语句确保文件使用后会被正确关闭。变量 <code>f</code> 是打开文件的引用。</li></ul></li><li><code>f.write(pic.content)</code><ul><li>最后，这行代码将下载的图片内容 <code>pic.content</code> 写入到文件 <code>f</code> 中，完成图片的保存。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序猿的那些事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好</title>
      <link href="/post/10739.html"/>
      <url>/post/10739.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
